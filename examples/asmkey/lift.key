schema variables {
    int #L;
}

functions {
    int opposite(int); 

    dynamic int ctl_state(int); // Lift -> { halting (0), moving (1) }
    dynamic int floor(int); // Lift -> Floor
    dynamic int dir(int); // Lift -> Dir
    dynamic int hasToDeliverAt(int, int); // Lift * Floor -> {true, false} -- dynamic predicate

    // Im Beispiel wird die Funktion 'existsCallFromTo' dreistellig
    // definiert, aber nur zweistellig verwendet. Ich definiere sie
    // hier daher auch nur zweistellig, da das wohl gemeint ist.
    dynamic int existsCallFromTo(int, int); // Floor * Dir -> {true, false} -- dynamic predicate
}

predicates {
    // dynamic
    HasToVisit(int, int);
    Attracted(int, int);
    CanContinue(int);
    Departing(int);
    Continuing(int);
    Stopping(int);
    Changing(int);
    Waiting(int);
}

rules {

    // predicates
  
    Continuing1 {
        find (Continuing(#L))
        replacewith (ctl_state(#L) = 0 & Attracted(dir(#L), #L))
    };
}

procedures {
    LIFT(this:int) {
//        call DEPART(this),
//        call CONTINUE(this),
//        call STOP(this),
//        call CHANGE(this),
        call WAIT(this)
    };

    MOVELIFT(L:int) {
        if dir(L) = 0 then // up
            floor(L) := floor(L) + 1
        else skip end,
        if dir(L) = 1 then // down
            floor(L) := floor(L) - 1
        else skip end
    };

    DEPART(L:int) {
        if ctl_state(L) = 0 & Attracted(dir(L), L) then
            call MOVELIFT(L),
            ctl_state(L) := 1
        else skip end
    };

    CONTINUE(L:int) {
        if ctl_state(L) = 1 & CanContinue(L) then
            call MOVELIFT(L),
            ctl_state(L) := 1
        else skip end
    };

    STOP(L:int) {
        if ctl_state(L) = 1 & ! CanContinue(L) then
            call CANCELREQUEST(L, dir(L)),
            ctl_state(L) := 0
        else skip end
    };

    CHANGE(L:int) {
        if ctl_state(L) = 0 then
            let d1:int = dir(L) in let d2:int = opposite(dir(L)) in
                if ! Attracted(d1, L) & Attracted(d2, L) then
                    dir(L) := d2,
                    call CANCELREQUEST(L, d2)
                else skip end
            end end
        else skip end
    };

    WAIT(L:int) {
        if ctl_state(L) = 0 then
            let d1:int = dir(L) in let d2:int = opposite(dir(L)) in
                if ! Attracted(d1, L) & ! Attracted(d2, L) then
                    call CANCELREQUEST(L, d1),
                    call CANCELREQUEST(L, d2)
                else skip end
            end end
        else skip end
    };

    CANCELREQUEST(L:int, d:int) {
        hasToDeliverAt(L, floor(L)) := 1,
        existsCallFromTo(floor(L), d) := 1
    };

}

problem {
    all L:int. (Departing(L) -> [call LIFT(L)] (Continuing(L) | Stopping(L)))
}
