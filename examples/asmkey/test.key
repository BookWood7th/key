functions {
    dynamic int f(int);
}

predicates {
    p(int); q(int);
    P; Q;
}

rules {

  foo1 {
    find (==> Con(#R, #S))
    replacewith (==> Con(#R));
    replacewith (==> Con(#S));
    replacewith (==> #ASM_JOIN(#R, #S))
  };  


}

problem {
    //all x:int. p(x) -> p(0)
    //all x:int. p(x+1) -> all x:int. p(x)
    //p(0) & all x:int. (p(x) -> p(x+1) -> p(2)
    //Con(skip)
    P & (P <-> Q) -> Q
}
