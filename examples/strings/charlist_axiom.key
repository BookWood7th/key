\sorts {
  CharList;
}

\functions {
  CharList empty;
  CharList cons (jchar, CharList);
  jchar charAt (int, CharList);
  int length (CharList);
  int indexOf (jchar, int, CharList);
  CharList substring (int, CharList);
  CharList prefix (int,CharList);
  CharList concat (CharList,CharList);
  int indexOfStr (CharList,int,CharList);
  int lastIndexOf (jchar,int,CharList);
  int lastIndexOfStr (CharList,int,CharList);
  CharList replace (jchar,jchar,CharList);
}

\predicates {
  startsWith (CharList,CharList);
  endsWith (CharList,CharList);
  contains (CharList,CharList);
  equal (CharList,CharList);
}

\rules {

  /***********************************
   * Axiomatization of the functions *
   ***********************************/
  /*
   * int length(CharList)
   */
  cl_lengthEmpty {
    \find (length(empty))
    \replacewith (0)
  };

  cl_lengthCons {
    \schemaVar \term CharList l;
    \schemaVar \term jchar c;
    \find (length(cons(c,l)))
    \replacewith (length(l)+1)
  };

  /*
   * int charAt (int,CharList)
   * cases where the index is greater or equal
   * to the list's length are not specified
   */
  cl_charAt0 {
    \schemaVar \term CharList l;
    \schemaVar \term jchar c;
    \find (charAt(0,cons(c,l)))
    \replacewith (c)
  };

  cl_charAtI {
    \schemaVar \term CharList l;
    \schemaVar \term jchar c;
    \schemaVar \term int i;
    \find (charAt(i,cons(c,l)))
    \replacewith (\if (i>0) \then (charAt(i-1,l)) 
		            \else (charAt(i,cons(c,l))))
  };

  /*
   * equal(CharList,CharList)
   * the equality predicate
   */
  cl_equality {
    \schemaVar \term CharList l1, l2;
    \find (l1 = l2)
    \replacewith (equal(l1,l2))
  };

  cl_equalTrue {
    \find (equal (empty,empty))
    \replacewith (true)
  };

  cl_equalFalse1 {
    \schemaVar \term CharList l;
    \schemaVar \term jchar c;
    \find (equal (empty,cons(c,l)))
    \replacewith (false)
  };

  cl_equalFalse2 {
    \schemaVar \term CharList l;
    \schemaVar \term jchar c;
    \find (equal (cons(c,l),empty))
    \replacewith (false)
  };

  cl_equalReduce {
    \schemaVar \term CharList l1, l2;
    \schemaVar \term jchar c;
    \find (equal (cons(c,l1),cons(c,l2)))
    \replacewith (equal(l1,l2))
  };

  /*
   * structural induction over all CharLists
   */
  cl_induct {
    \schemaVar \variables CharList lv;
    \schemaVar \variables jchar cv;
    \schemaVar \formula phi;
    \varcond ( \notFreeIn(cv,phi)  )
    "Base Case": \add ( ==> {\subst lv; empty}(phi) );
    "Step Case": \add ( ==> \forall lv; \forall cv;
                              (phi -> {\subst lv; cons(cv,lv)}phi) );
    "Use Case":  \add ( \forall lv; (phi) ==> )
  };

  /*
   * jchar indexOf (int,int,CharList)
   */
  cl_indexOf {
    \schemaVar \term CharList l;
    \schemaVar \term jchar c;
    \schemaVar \term int i;
    \schemaVar \variables int iv;
    \find (indexOf (c,i,l))
    \varcond ( \notFreeIn(iv,l), \notFreeIn(iv,c), \notFreeIn(iv,i) )
    \replacewith ( \ifEx iv; ( iv >= 0 & iv >= i & iv < length(l) & charAt(iv,l) = c )
                     \then (iv)
                     \else (-1) )
  };

  /*
   * CharList substring(int,CharList)
   * cases where the index is greater or equal than
   * the length of the list are not specified
   */
  cl_substring {
    \schemaVar \term CharList l;
    \find ( substring (0,l) )
    \replacewith ( l )
  };

  cl_substringReduce {
    \schemaVar \term CharList l;
    \schemaVar \term jchar c;
    \schemaVar \term int i;
    \find ( substring (i,cons(c,l)) )
    \replacewith ( \if (i>0) \then (substring(i-1,l))
                             \else (substring (i,cons(c,l))) )
  };

  /*
   * CharList prefix(int,CharList)
   * calculate prefix of a certain length
   * cases with length greater than the length
   * of the list are not specified
   */
   cl_prefixCons {
     \schemaVar \term int i;
     \schemaVar \term CharList l;
     \schemaVar \term jchar c;
     \find ( prefix(i,cons(c,l)) )
     \replacewith ( \if (i>0) \then (cons(c,prefix(i-1,l)))
     		    	      \else (prefix(i,cons(c,l))) )
   };

   cl_prefixZero {
     \schemaVar \term CharList l;
     \find ( prefix(0,l) )
     \replacewith ( empty )
   };

  /*
   * endsWith(CharList,CharList)
   * predicate indicating if the first list
   * is a suffix of the second one
   */
  cl_endsWith {
    \schemaVar \term CharList l1, l2;
    \find (endsWith(l1,l2))
    \replacewith ( \if (length(l1) <= length(l2))
    		   \then (equal(substring(length(l2)-length(l1),l2),l1))
		   \else (false) )
  };

  /*
   * startsWith(CharList,CharList)
   * predicate indicating if the first list
   * is a prefix of the second one
   */
  cl_startsWithCons {
    \schemaVar \term CharList l1, l2;
    \schemaVar \term jchar c1,c2;
    \find (startsWith(cons(c1,l1),cons(c2,l2)))
    \replacewith (\if (c1=c2) \then (startsWith(l1,l2))
    		      	      \else (false))
  };

  cl_startsWithTrue {
    \schemaVar \term CharList l;
    \find (startsWith(empty,l))
    \replacewith (true)
  };

  cl_startsWithFalse {
    \schemaVar \term CharList l;
    \schemaVar \term jchar c;
    \find (startsWith(cons(c,l),empty))
    \replacewith (false)
  };

  /*
   * CharList concat (CharList,CharList)
   * concatenate the two lists
   */
  cl_concatEmpty {
    \schemaVar \term CharList l;
    \find (concat(empty,l))
    \replacewith (l)
  };

  cl_concatCons {
    \schemaVar \term CharList l1, l2;
    \schemaVar \term jchar c;
    \find (concat(cons(c,l1),l2))
    \replacewith (cons(c,concat(l1,l2)))
  };

  /*
   * contains (CharList,CharList)
   * predicate indicating whether the first list
   * is contained in the second
   */
  cl_contains {
    \schemaVar \term CharList l1, l2;
    \schemaVar \variables int iv;
    \find (contains(l1,l2))
    \varcond ( \notFreeIn (iv,l1), \notFreeIn (iv,l2) )
    \replacewith ( \ifEx iv; (iv >= 0
    		   	      & iv < length(l2)
                              & startsWith(l1,substring(iv,l2)) )
                   \then (true)
                   \else (false) )
  };

  /*
   * int indexOfStr (CharList,int,CharList)
   */
  cl_indexOfStr {
    \schemaVar \term CharList l1, l2;
    \schemaVar \term int i;
    \schemaVar \variables int iv;
    \find (indexOfStr(l1,i,l2))
    \varcond ( \notFreeIn (iv,l1), \notFreeIn (iv,l2), \notFreeIn (iv,i) )
    \replacewith ( \ifEx iv; (iv >= 0
			      & iv >= i
                              & iv < length(l2)
                              & startsWith(l1,substring(iv,l2)) )
                   \then (iv)
                   \else (-1) )
  };

  /*
   * int lastIndexOf (jchar,int,CharList)
   */
  cl_lastIndexOf {
    \schemaVar \term CharList l;
    \schemaVar \term jchar c;
    \schemaVar \term int i;
    \schemaVar \variables int iv;
    \find (lastIndexOf (c,i,l))
    \varcond ( \notFreeIn (iv,c), \notFreeIn (iv,i), \notFreeIn (iv,l) )
    \replacewith ( \ifEx iv; (iv < length(l)
                              & iv >= i
                              & charAt(iv,l) = c
                              & indexOf (c,iv+1,l) = -1)
                   \then (iv)
                   \else (-1) )
  };

  /*
   * int lastIndexOfStr (CharList,int,CharList)
   */
  cl_lastIndexOfStr {
    \schemaVar \term CharList l1, l2;
    \schemaVar \term int i;
    \schemaVar \variables int iv;
    \find (lastIndexOfStr (l1,i,l2))
    \varcond ( \notFreeIn (iv,l1), \notFreeIn (iv,i), \notFreeIn (iv,l2) )
    \replacewith ( \ifEx iv; (iv < length(l2)
                              & iv >= i
                              & indexOfStr (l1,iv,l2) = iv
                              & indexOfStr (l1,iv+1,l2) = -1)
                   \then (iv)
                   \else (-1) )
  };

  /*
   * CharList replace (jchar,jchar,CharList)
   * replace all occurences of first character
   * against the second character
   */
  cl_replaceEmpty {
    \schemaVar \term jchar c1, c2;
    \find (replace(c1,c2,empty))
    \replacewith (empty)
  };

  cl_replaceCons {
    \schemaVar \term CharList l;
    \schemaVar \term jchar c, c1, c2;
    \find (replace(c1,c2,cons(c,l)))
    \replacewith ( \if (c=c1) \then (cons(c2,replace(c1,c2,l)))
                              \else (cons(c,replace(c1,c2,l))) )
  };

}

