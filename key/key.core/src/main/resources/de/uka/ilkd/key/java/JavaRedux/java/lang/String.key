\functions {
  Seq \dl_strContent(java.lang.String);
  java.lang.String strPool(Seq);
}


\contracts {
  stringCopyValueOfNormal {
      \programVariables {
          java.lang.String \result;
          char[] data;
          Heap heapAtPre;
      }
      (data != null) ->
      {heapAtPre := heap}
      \<{
      \result = java.lang.String.copyValueOf(data);
      }\>(   \dl_seqLen(\dl_strContent(\result)) = data.length
          && \forall int i; ((i >= 0 && i < data.length)
                  -> int::seqGet(\dl_strContent(\result),i) = data[i] )
          && boolean::select(heapAtPre, \result, java.lang.Object::<created>) = FALSE
          && \result != null )
      assignable \strictly_nothing;
  };

  stringCopyValueOfExc {
      \programVariables {
          java.lang.String \result;
          char[] data;
          java.lang.Throwable exc;
      }
      (data = null) ->
      \<{
          #catchAll (exc) {
              \result = java.lang.String.copyValueOf(data);
      }}\> (  exc != null
           && java.lang.NullPointerException::instance(exc) = TRUE)
      assignable \strictly_nothing;
  };

  stringCopyValueOfRangeNormal {
      \programVariables {
          java.lang.String \result;
          char[] data;
          int offset, count;
          Heap heapAtPre;
      }
      (  data != null 
       && offset >= 0
       && count >= 0
       && offset+count <= data.length)
      ->
      {heapAtPre := heap}
      \<{
          \result = java.lang.String.copyValueOf(data, offset, count);
      }\>(  \dl_seqLen(\dl_strContent(\result)) = count
          && \forall int i; ((i >= 0 && i < count)
                         -> int::seqGet(\dl_strContent(\result), i) = data[i+offset] )
          && boolean::select(heapAtPre, \result, java.lang.Object::<created>) = FALSE
          && \result != null )
      assignable \strictly_nothing;
  };

  stringCopyValueOfRangeExcBounds {
      \programVariables {
          java.lang.String \result;
          char[] data;
          int offset, count;
          java.lang.Throwable exc;
      }
      (  data != null
       && ( offset < 0
          || count < 0
          || offset+count > data.length))
      ->
      \<{
          #catchAll (exc) {
              \result = java.lang.String.copyValueOf (data,offset,count);
      }}\>(  exc != null
           && java.lang.IndexOutOfBoundsException::instance(exc) = TRUE)
      assignable \strictly_nothing;
  };

  stringCopyValueOfRangeExcNull {
      \programVariables {
          java.lang.String \result;
          char[] data;
          int offset, count;
          java.lang.Throwable exc;
      }
      (data = null) ->
      \<{
          #catchAll (exc) {
              \result = java.lang.String.copyValueOf(data, offset, count);
      }}\> (  exc != null
           && java.lang.NullPointerException::instance(exc) = TRUE)
      assignable \strictly_nothing;
  };


  //
  // getChars
  //
  stringGetCharsNormal {
      \programVariables {
          java.lang.String s;
          char[] dst;
          int srcBegin, srcEnd, dstBegin;
          Heap heapAtPre;
      }
      (  dst != null
       && srcBegin >= 0
       && srcBegin <= srcEnd
       && srcEnd <= \dl_seqLen(\dl_strContent(s))
       && dstBegin >= 0
       && dstBegin + (srcEnd - srcBegin) <= dst.length )
      ->
      {heapAtPre := heap}
      \<{
          s.getChars(srcBegin, srcEnd, dst, dstBegin);
      }\>(\forall int i; ( ((i >= 0 && i < (srcEnd - srcBegin))
		    	      -> int::seqGet(\dl_strContent(s), srcBegin + i) = dst[dstBegin + i])
			     && ((i >= 0 && i < dstBegin)
			       -> dst[i] = int::select(heapAtPre, dst, arr(i)))
			     && ((i >= dstBegin + (srcEnd - srcBegin) && i < dst.length)
			       -> dst[i] = int::select(heapAtPre, dst, arr(i))) ))
      \modifies allFields(dst)
  };

  stringGetCharsExcBounds {
      \programVariables {
          java.lang.String s;
          char[] dst;
          int srcBegin, srcEnd, dstBegin;
          java.lang.Throwable exc;
      }
      (  dst != null
       && (  srcBegin < 0
          || srcBegin > srcEnd
          || srcEnd > \dl_seqLen(\dl_strContent(s))
          || dstBegin < 0 
          || dstBegin + (srcEnd - srcBegin) > dst.length ))
      ->
      \<{
          #catchAll (exc) {
              s.getChars(srcBegin, srcEnd, dst, dstBegin);
      }}\>( exc != null
          && java.lang.IndexOutOfBoundsException::instance(exc) = TRUE)
      assignable \strictly_nothing;
  };

  stringGetCharsExcNull {
      \programVariables {
          java.lang.String s;
          char[] dst;
          int srcBegin, srcEnd, dstBegin;
          java.lang.Throwable exc;
      }
      (dst = null) ->
      \<{
          #catchAll (exc) {
              s.getChars(srcBegin, srcEnd, dst, dstBegin);
      }}\>( exc != null
           && java.lang.NullPointerException::instance(exc) = TRUE)
      assignable \strictly_nothing;
  };


  //
  // valueOf
  //
  stringValueOfBoolean {
      \programVariables {
          java.lang.String \result;
          boolean bVal;
          Heap heapAtPre;
      }
      true ->
      {heapAtPre := heap}
      \<{
          \result = java.lang.String.valueOf(bVal);
      }\>(\dl_strContent(\result) = \if (bVal = TRUE)
                               \then ( "true" ) 
                               \else ( "false" ) 
          && boolean::select(heapAtPre, \result, java.lang.Object::<created>) = FALSE
          && \result != null )
      assignable \strictly_nothing;
  };

  stringValueOfChar {
      \programVariables {
          java.lang.String \result;
          char charVal;
          Heap heapAtPre;
      }
      true ->
      {heapAtPre := heap}
      \<{
          \result = java.lang.String.valueOf(charVal);
      }\>(   \dl_strContent(\result) = seqSingleton(charVal)
          && boolean::select(heapAtPre, \result, java.lang.Object::<created>) = FALSE
          && \result != null )
      assignable \strictly_nothing;
  };

  stringValueOfCharArrayNormal {
      \programVariables {
          java.lang.String \result;
          char[] data;
          Heap heapAtPre;
      }
      (data != null) ->
      {heapAtPre := heap}
      \<{
          \result = java.lang.String.valueOf(data);
      }\>(   (\forall int i; ((i >= 0 && i < data.length)
                      -> int::seqGet(\dl_strContent(\result), i) = data[i]))
          && \dl_seqLen(\dl_strContent(\result)) = data.length
          && boolean::select(heapAtPre, \result, java.lang.Object::<created>) = FALSE
          && \result != null )
      assignable \strictly_nothing;
  };

  stringValueOfCharArrayExc {
      \programVariables {
          java.lang.String \result;
          char[] data;
          java.lang.Throwable exc;
      }
      (data = null) ->
      \<{
          #catchAll (exc) {
             \result = java.lang.String.valueOf(data);
      }}\>( exc != null
           && java.lang.NullPointerException::instance(exc) = TRUE )
      assignable \strictly_nothing;
  };

  stringValueOfInt {
      \programVariables {
          java.lang.String \result;
          int iVal;
          Heap heapAtPre;
      }
      true ->
      {heapAtPre := heap}
      \<{
          \result = java.lang.String.valueOf(iVal);
      }\>(   \dl_strContent(\result) = clRemoveZeros(clTranslateInt(iVal))
          && boolean::select(heapAtPre, \result, java.lang.Object::<created>) = FALSE
          && \result != null )
      assignable \strictly_nothing;
  };

  stringValueOfLong {
      \programVariables {
          java.lang.String \result;
          long lVal;
          Heap heapAtPre;
      }
      true ->
      {heapAtPre := heap}
      \<{
          \result = java.lang.String.valueOf(lVal);
      }\>(   \dl_strContent(\result) = clRemoveZeros(clTranslateInt(lVal))
          && boolean::select(heapAtPre, \result, java.lang.Object::<created>) = FALSE
          && \result != null )
      assignable \strictly_nothing;
  };

  stringValueOfCharArrayRangeNormal {
      \programVariables {
          java.lang.String \result;
          char[] data;
          int offset, count;
          Heap heapAtPre;
      }
      ( data != null && offset >= 0 && count >= 0
       && offset + count <= data.length)
      ->
      {heapAtPre := heap}
      \<{
          \result = java.lang.String.valueOf(data, offset, count);
      }\>(   (\forall int i; ((i >= 0 && i < count)
                        -> int::seqGet(\dl_strContent(\result), i) = data[offset + i]))
          && \dl_seqLen(\dl_strContent(\result)) = count
          && boolean::select(heapAtPre, \result, java.lang.Object::<created>) = FALSE
          && \result != null )
      assignable \strictly_nothing;
  };

  stringValueOfCharArrayRangeExcBounds {
      \programVariables {
          java.lang.String \result;
          char[] data;
          int offset, count;
          java.lang.Throwable exc;
      }
      (  data != null
       && (offset < 0 || count < 0 || offset+count > data.length))
      ->
      \<{
          #catchAll (exc) {
              \result = java.lang.String.valueOf(data, offset, count);
      }}\>(  exc != null
           && java.lang.IndexOutOfBoundsException::instance(exc) = TRUE )
      assignable \strictly_nothing;
  };

  stringValueOfCharArrayRangeExcNull {
      \programVariables {
          java.lang.String \result;
          char[] data;
          int offset, count;
          java.lang.Throwable exc;
      }
      (data = null) ->
      \<{
          #catchAll (exc) {
              \result = java.lang.String.valueOf(data, offset, count);
      }}\>(  exc != null
           && java.lang.NullPointerException::instance(exc) = TRUE )
      assignable \strictly_nothing;
  };

  stringValueOfObjectNull {
      \programVariables {
          java.lang.String \result;
          java.lang.Object obj;
          Heap heapAtPre;
      }
      obj = null ->
      {heapAtPre := heap}
      \<{
          \result = java.lang.String.valueOf(obj);
      }\>(   \dl_strContent(\result) = "null"
          && boolean::select(heapAtPre, \result, java.lang.Object::<created>) = FALSE
          && \result != null )
      assignable \strictly_nothing;
  };

  stringValueOfObjectNonNull {
      \programVariables {
          java.lang.String \result;
          java.lang.Object obj;
      }
      obj != null ->
      \<{
          \result = java.lang.String.valueOf(obj);
      }\>( \result = obj.toString() )
      assignable \strictly_nothing;
  };


}

/*
 * Program Rules for Strings
 */
\rules {

  poolKeyIsContentOfValue {
  	\schemaVar \term Seq slit;
  	\find (\dl_strContent(strPool(slit))) 
  	\replacewith(slit)
  	\heuristics (simplify)  	
  };


  poolIsInjective {
  	\schemaVar \term Seq slit1, slit2;
  	\find (strPool(slit1) = strPool(slit2))
  	\replacewith(slit1 = slit2)
  	\heuristics (simplify)
  };


  insert_constant_string_value {  
  	\schemaVar \program ConstantStringVariable #csv;
  	\assumes(wellFormed(heap) ==>)                           
        \find(#csv) 
        \sameUpdateLevel
  		\replacewith(\if (#constantvalue(#csv) = null) \then (null) \else (strPool((Seq)#constantvalue(#csv))) )
        \heuristics(concrete)  
  };
  
  
  nullString {
  	\find ( \dl_strContent(null) )
  	\replacewith("null")
  	\heuristics(concrete)
  };

    
  //
  // Assignment of a Literal
  //
  stringAssignment  {
      \schemaVar \modalOperator { diamond, box} #normalassign;
      \schemaVar \program Variable #v;
      \schemaVar \program StringLiteral #slit;
      \schemaVar \formula post;
      
      \find (\modality{#normalassign}{.. #v = #slit; ...}\endmodality(post))
      \sameUpdateLevel
       
      \replacewith ({ #v := strPool(#slit) }
                    \modality{#normalassign}{.. ...}\endmodality(post))
      \add(strPool(#slit) != null, boolean::select(heap, strPool(#slit), java.lang.Object::<created>) = TRUE ==>)

      \heuristics (simplify_prog, simplify_prog_subset)
  };


  //
  // The "+" operator
  //
  stringConcat {
      \schemaVar \modalOperator { diamond, box } #normalassign;
      \schemaVar \program Variable #v;
      \schemaVar \program SimpleStringExpression #sstr1, #sstr2;
      \schemaVar \formula post;
      \schemaVar \skolemTerm java.lang.String sk;

      \find ( \modality{#normalassign} {.. 
                        #v = #sstr1 + #sstr2; 
              ...}\endmodality(post))
      \sameUpdateLevel
      \varcond(\newDependingOn(sk, post))
              
      \replacewith ( { #v := sk }
                     { heap := create(heap, sk) }
                      \modality{#normalassign}{.. ...}\endmodality(post) )
      \add(\dl_strContent(sk) = seqConcat(\dl_strContent(#sstr1), \dl_strContent(#sstr2)) ==> sk = null)
      \heuristics (simplify_prog, simplify_prog_subset)
  };


  stringConcatIntExpLeft {
      \schemaVar \modalOperator { diamond, box } #normalassign;
      \schemaVar \program Variable #v;
      \schemaVar \program SimpleStringExpression #sstrRight;
      \schemaVar \program AnyJavaTypeExpression #seLeft;
      \schemaVar \formula post;
      \schemaVar \skolemTerm java.lang.String sk;

      \find ( \modality{#normalassign}
              {.. #v = #seLeft + #sstrRight; ...}
              \endmodality(post))
      \sameUpdateLevel              
      \varcond(\newDependingOn(sk, post))
      
      \replacewith ( { #v := sk }
                     { heap := create(heap, sk) }
                      \modality{#normalassign}{.. ...}\endmodality(post) )
      \add(\dl_strContent(sk) = seqConcat(clTranslateInt(#seLeft), \dl_strContent(#sstrRight)) ==> sk = null)
      \heuristics (simplify_prog, simplify_prog_subset)
  };

  
  stringConcatIntExpRight {
      \schemaVar \modalOperator { diamond, box } #normalassign;
      \schemaVar \program Variable #v;
      \schemaVar \program SimpleStringExpression #sstrLeft;
      \schemaVar \program AnyJavaTypeExpression #seRight;
      \schemaVar \formula post;
      \schemaVar \skolemTerm java.lang.String sk;

      \find ( \modality{#normalassign}
              {.. #v = #sstrLeft + #seRight; ...}
              \endmodality(post))
      \sameUpdateLevel              
      \varcond(\newDependingOn(sk, post))
              
      \replacewith ( { #v := sk }
                     { heap := create(heap, sk) }
                      \modality{#normalassign}{.. ...}\endmodality(post) )
      \add(\dl_strContent(sk) = seqConcat(\dl_strContent(#sstrLeft), clTranslateInt(#seRight)) ==> sk = null)
      \heuristics (simplify_prog, simplify_prog_subset)
  };
  
  stringConcatCharExpLeft {
      \schemaVar \modalOperator { diamond, box } #normalassign;
      \schemaVar \program Variable #v;
      \schemaVar \program SimpleStringExpression #sstrRight;
      \schemaVar \program JavaCharExpression #seLeft;
      \schemaVar \formula post;
      \schemaVar \skolemTerm java.lang.String sk;

      \find ( \modality{#normalassign}
              {.. #v = #seLeft + #sstrRight; ...}
              \endmodality(post))
      \sameUpdateLevel              
      \varcond(\newDependingOn(sk, post))
      
      \replacewith ( { #v := sk }
                     { heap := create(heap, sk) }
                      \modality{#normalassign}{.. ...}\endmodality(post) )
      \add(\dl_strContent(sk) = seqConcat(seqSingleton(#seLeft), \dl_strContent(#sstrRight)) ==> sk = null)
      \heuristics (simplify_prog, simplify_prog_subset)
  };

  
  stringConcatCharExpRight {
      \schemaVar \modalOperator { diamond, box } #normalassign;
      \schemaVar \program Variable #v;
      \schemaVar \program SimpleStringExpression #sstrLeft;
      \schemaVar \program JavaCharExpression #seRight;
      \schemaVar \formula post;
      \schemaVar \skolemTerm java.lang.String sk;

      \find ( \modality{#normalassign}
              {.. #v = #sstrLeft + #seRight; ...}
              \endmodality(post))
      \sameUpdateLevel              
      \varcond(\newDependingOn(sk, post))
              
      \replacewith ( { #v := sk }
                     { heap := create(heap, sk) }
                      \modality{#normalassign}{.. ...}\endmodality(post) )
      \add(\dl_strContent(sk) = seqConcat(\dl_strContent(#sstrLeft), seqSingleton(#seRight)) ==> sk = null)
      \heuristics (simplify_prog, simplify_prog_subset)
  };
  
  stringConcatBooleanLeft {
      \schemaVar \modalOperator { diamond, box } #normalassign;
      \schemaVar \program Variable #v;
      \schemaVar \program SimpleStringExpression #sstrRight;
      \schemaVar \program SimpleJavaBooleanExpression #seLeft;
      \schemaVar \formula post;
      \schemaVar \skolemTerm java.lang.String sk;

      \find ( \modality{#normalassign}
              {.. #v = #seLeft + #sstrRight; ...}
              \endmodality(post))
      \sameUpdateLevel
      \varcond(\newDependingOn(sk, post))
              
      \replacewith ( { #v := sk }
                     { heap := create(heap, sk) }
                      \modality{#normalassign}{.. ...}\endmodality(post) )
      \add(\dl_strContent(sk) = seqConcat(\if (#seLeft = TRUE) 
                                     \then ( "true" )
                                     \else ( "false" ), 
                                     \dl_strContent(#sstrRight)) ==> sk = null)
      \heuristics (simplify_prog, simplify_prog_subset)
  };
  

  stringConcatBooleanRight {
      \schemaVar \modalOperator { diamond, box } #normalassign;
      \schemaVar \program Variable #v;
      \schemaVar \program SimpleStringExpression #sstrLeft;
      \schemaVar \program SimpleJavaBooleanExpression #seRight;
      \schemaVar \formula post;
      \schemaVar \skolemTerm java.lang.String sk; 

      \find ( \modality{#normalassign}
              {.. #v = #sstrLeft + #seRight; ...}
              \endmodality(post))
      \sameUpdateLevel              
      \varcond(\newDependingOn(sk, post))
              
      \replacewith ( { #v := sk }
                     { heap := create(heap, sk) }
                      \modality{#normalassign}{.. ...}\endmodality(post) )
      \add(\dl_strContent(sk) = seqConcat(\dl_strContent(#sstrLeft),
                                    \if (#seRight = TRUE) 
                                    \then ("true") 
                                    \else ("false") )==> sk = null)
      \heuristics (simplify_prog, simplify_prog_subset)
  };
  
  
  stringConcatObjectLeft {
      \schemaVar \modalOperator { diamond, box } #normalassign;
      \schemaVar \program Variable #v;
      \schemaVar \program SimpleStringExpression #sstrRight;
      \schemaVar \program SimpleNonStringObjectExpression #seLeft;
      \schemaVar \formula post;    
      \schemaVar \skolemTerm java.lang.String sk;      

      \find ( \modality{#normalassign}
              {.. #v = #seLeft + #sstrRight; ...}
              \endmodality(post))
      \sameUpdateLevel              
      \varcond(\newDependingOn(sk, post))
              
      "#seLeft not null":              
      \replacewith (  
      	\modality{#normalassign}
              {.. #v = #seLeft.toString() + #sstrRight; ...}
        \endmodality(post) )
      \add(==> #seLeft = null);

      "#seLeft null":
      \replacewith ( { #v := sk }
                     { heap := create(heap, sk) }
                      \modality{#normalassign}{.. ...}\endmodality(post) )
      \add(#seLeft = null, \dl_strContent(sk) = seqConcat(\dl_strContent(null), \dl_strContent(#sstrRight)) ==> sk = null)              
        
      \heuristics (simplify_prog, simplify_prog_subset)
  };


  stringConcatObjectRight {
      \schemaVar \modalOperator { diamond, box } #normalassign;
      \schemaVar \program Variable #v;
      \schemaVar \program SimpleStringExpression #sstrLeft;
      \schemaVar \program SimpleNonStringObjectExpression #seRight;
      \schemaVar \formula post;
      \schemaVar \skolemTerm java.lang.String sk;            

      \find ( \modality{#normalassign}
              {.. #v = #sstrLeft + #seRight; ...}
              \endmodality(post))
      \sameUpdateLevel              
      \varcond(\newDependingOn(sk, post))
              
      "#seRight not null":              
      \replacewith (  
      	\modality{#normalassign}
              {.. #v = #sstrLeft + #seRight.toString(); ...}
        \endmodality(post) )
      \add(==> #seRight = null);
        
      "#seRight null":              
      \replacewith ( { #v := sk }
                     { heap := create(heap, sk) }
                      \modality{#normalassign}{.. ...}\endmodality(post) )
      \add(#seRight = null, \dl_strContent(sk) = seqConcat(\dl_strContent(#sstrLeft), \dl_strContent(null)) ==> sk = null)        
        
      \heuristics (simplify_prog, simplify_prog_subset)
  };
}
