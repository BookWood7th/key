// This file is part of KeY - Integrated Deductive Software Design
// Copyright (C) 2001-2005 Universitaet Karlsruhe, Germany
//                         Universitaet Koblenz-Landau, Germany
//                         Chalmers University of Technology, Sweden
//
// The KeY system is protected by the GNU General Public License. 
// See LICENSE.TXT for details.
//
//

/* Generated by Together */

package de.uka.ilkd.key.casetool.together.keydebugclassloader;

import java.lang.reflect.Field;
import java.util.Vector;

import com.togethersoft.openapi.sci.pattern.SciPattern;

import de.uka.ilkd.key.casetool.together.patterns.HelperClasses.MyPatternBase.MyClassPatternBase;
import de.uka.ilkd.key.util.Debug;


public abstract class KeyPattern extends MyClassPatternBase implements SciPattern {

    public String KEY_SET_METHOD;
    public String KEY_CONSTRUCTOR_PARAMETER;
    public String KEY_NONE;

    {   Field field = null;
	try {
	    field = getClass().getField("UI_NONE");
	    if (field == null) {
		Debug.out("Together-API<6.0");
		KEY_SET_METHOD=(String)getClass().getField("SET_METHOD").get(this);
		KEY_CONSTRUCTOR_PARAMETER=(String)getClass().getField("CONSTRUCTOR_PARAMETER").get(this);
		KEY_NONE=(String)getClass().getField("NONE").get(this);
	    } else {
		Debug.out("Together-API>=6.0");
		KEY_SET_METHOD=(String)getClass().getField("UI_SET_METHOD").get(this);
		KEY_CONSTRUCTOR_PARAMETER=(String)getClass().getField("UI_CONSTRUCTOR_PARAMETER").get(this);
		KEY_NONE=(String)getClass().getField("UI_NONE").get(this);
	    }
	} catch (IllegalAccessException iae) {
	    System.err.println("keypattern: underlying constructor is inaccesible."); 
	    System.err.println("The exception was: "+iae); 
	    iae.printStackTrace(); 
	} catch (IllegalArgumentException iae) {
	    System.err.println("keypattern: specified object is not an "+
			       "instance of the class or interface declaring"+
			       "the underlying field (or a subclass or implementor"+
			       "thereof).field is not accessible."); 
	    System.err.println("The exception was: "+iae); 
	    iae.printStackTrace(); 
	} catch (NoSuchFieldException e) {
	    String message = 
		"Together renamed some fields, when changing from API <6.0 to >=6.0.\n";
	    message += 
		"The thrown exception indicates that you have a (probably) new version,\n";
	    message += "where the fields have been renamed once again.\n";
	    message +=" Please mail this error to: key@ira.uka.de\n";
	    message += "The thrown exception was "+e;
	    System.err.println("keypattern:" + message);
	    e.printStackTrace();
	} catch (SecurityException se) {
	    String message = 
		"Together renamed some fields, when changing from API <6.0 to >=6.0.\n";
	    message += "The thrown exception indicates, that you use (probably) a newer\n";
	    message += "version, where the access permissions have been restricted.";
	    message +=" Please mail this error to: key@ira.uka.de\n";
	    message += "The thrown exception was: "+se;
	    System.err.println("keypattern:"+message);
	    se.printStackTrace();	    
	}
	
    }

    private KeyPattern thisclone;

    public final boolean prepare(){
	int i;
	if("on".equals(System.getProperty("KeyDebugClassLoader"))){
	    thisclone = reloadClassDef();
	    //	    IdeMessageManagerAccess.printMessage(IdeMessageType.INFORMATION, "jetzt habe ich reload gemacht!\n");
	    Class cl = this.getClass();
	    Vector fieldVector = new Vector();
	    Field[] fields = cl.getDeclaredFields();
	    for (i = 0; i < fields.length; i++){fieldVector.addElement(fields[i]);}
	    Class help = cl;
	    while (help.getSuperclass()!=null){
		help = help.getSuperclass();
		fields = help.getDeclaredFields();
		for (i = 0; i < fields.length; i++){
		    fields[i].setAccessible(true);  // damit auch private der Oberklassen lesbar werden
		    fieldVector.addElement(fields[i]);}
	    }
	    for(i = 0; i < fieldVector.size(); i++){
		Field actField = (Field) fieldVector.elementAt(i);
		try{
		    //    System.out.println(actField.getName() + " mit wert " +  actField.get(this)+"\n");
		    actField.set(thisclone, actField.get(this));
		} catch (IllegalAccessException iae) {
		    System.err.println("keypattern: setting/getting of field failed. Reason:\n" +				       
				       "the underlying constructor is inaccessible.");
		    System.err.println("The exception was:"+iae);
		    iae.printStackTrace();
		} catch (IllegalArgumentException iarg) {
		    System.err.println("keypattern: setting/getting of field failed. Reason:\n" +
				       "The specified object is not an instance of the\n" +
				       "class or interface declaring the underlying field\n" +
				       "(or a subclass or implementor thereof), or if an\n" + 
				       "unwrapping conversion fails.");
		    System.err.println("The exception was:"+iarg);
		    iarg.printStackTrace();
		} catch (NullPointerException ne) {
		    System.err.println("keypattern: setting of field failed. Reason:\n" +
				       "the specified object is null and the field is\n"+
				       "an instance field.");
		    System.err.println("The exception was:"+ne);
		    ne.printStackTrace();
		} catch (ExceptionInInitializerError ei) {
		    System.err.println("keypattern: setting of field failed. Reason:\n" +
				       "the initialization provoked by this method fails.");
		    System.err.println("The exception was:"+ei);
		    ei.printStackTrace();
		}
		
	    }
	}
	else { 
	    thisclone = this;
	}

    return thisclone.prepare1();
    }

    /* because we change the semantics of the original prepare method, we introduce this simulation method
       to invoke the prepare method in the super class */
    public final void superPrepareSimu(){
	super.prepare();
    }

    public boolean prepare1(){ return true; }

    public boolean canApply() { 
	return thisclone.canApply1();
    }
    
    public boolean canApply1(){
	return true;
    }

    public void apply() {
	thisclone.apply1();
    }
    
    public void apply1(){
    }

    public final void superApplySimu(){
	super.apply();
    }


    protected void finalize() throws Throwable {
	thisclone.finalize1();
    }

    protected void finalize1() throws Throwable{
    }

    protected void superFinalizeSimu() throws Throwable {
	super.finalize();
    }
    
    // reloads the class-definition of the this-object
    // and returns a new instance of it.
    private KeyPattern reloadClassDef() {
       	String thisClassName = this.getClass().getName();
	//	IdeMessageManagerAccess.printMessage(IdeMessageType.INFORMATION,"Name der nachgeladenen Klasse: "+thisClassName+"\n");
	KeyPattern pattern = null;
	try{
	    KeyDebugClassLoader classLoader = new KeyDebugClassLoader();
	    // Because of the explicit cast later KeyScript must not be 
	    // reloaded by KeyDebugClassLoader (otherwise we get an cast-error)
	    classLoader.setClassAlwaysAskParent(KeyPattern.class);
	    Class cl = classLoader.loadClass(thisClassName);
	    pattern = (KeyPattern) cl.newInstance();
	} catch (ExceptionInInitializerError ei) {
	    System.err.println("keypattern: the initialization provoked "+
			       "by this method fails.");
	    System.err.println("The exception was: "+ei);
	    ei.printStackTrace();
	} catch (IllegalAccessException iae) {
			System.err.println("keypattern: class or "+
					   "initializer is not accessible."); 
			System.err.println("The exception was: "+iae); 
			iae.printStackTrace(); 
	} catch (InstantiationException ie) { 
	    System.err.println
		("keypattern: class tried to\n"+
		 "instantiate represents an abstract class, an interface,"+
		 "an array class, a primitive type, or void; or if the"+
		 "instantiation fails for some other reason.");  
	    System.err.println("The exception was: "+ie);  
	    ie.printStackTrace();
	} catch (SecurityException se) {
	    System.err.println("keypattern: no permission to create"+
					   "a new instance"); 
	    System.err.println("The exception was: "+se); 
	    se.printStackTrace(); 
	} 
	return pattern;	
    }
}
