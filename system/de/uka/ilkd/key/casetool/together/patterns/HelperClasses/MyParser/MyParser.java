// This file is part of KeY - Integrated Deductive Software Design
// Copyright (C) 2001-2005 Universitaet Karlsruhe, Germany
//                         Universitaet Koblenz-Landau, Germany
//                         Chalmers University of Technology, Sweden
//
// The KeY system is protected by the GNU General Public License. 
// See LICENSE.TXT for details.
//
//
/* Generated By:JavaCC: Do not edit this line. MyParser.java */
package de.uka.ilkd.key.casetool.together.patterns.HelperClasses.MyParser;

import java.util.Vector;

import com.togethersoft.openapi.util.propertyMap.PropertyMapEvent;
import com.togethersoft.openapi.util.propertyMap.PropertyMapListener;

import de.uka.ilkd.key.casetool.together.patterns.HelperClasses.MyPatternBase.MyClassPatternBase;

public class MyParser extends MyClassPatternBase implements MyParserConstants {


//    private PropertyMap properties;
    private String oclSchemeName;
    private final static String SubclassesOf = "Subclasses of ";
    private final static String nameOfMethod = "Name of method ";
    private final static String nameOfClassAttribute = "Name of class-attribute ";
    private final static String inClass = " in class ";
    private Vector additionalProperties = new Vector();
    // the format of an entry in mappingVector is: OCL-Scheme , Scheme-Name, Name of field containing the real name
    private Vector mappingVector = new Vector();
    private Vector constraintVector=new Vector();
    private String commentString="";
    private String headerString="";
    private String constraint="";
    private Vector itemVector = new Vector();
    private Vector placeVector = new Vector();
    private Vector helpVector = new Vector();
    private Vector idVector = new Vector();
    private int id = 0;

    private static int counter=0;

    public Vector getAdditionalPropertiesVector(){
        return additionalProperties;
    }

    public Vector getConstraintVector(){
        return constraintVector;
    }

    public Vector getMappingVector(){
        return mappingVector;
    }

    public Vector getPlaceVector(){
        return placeVector;
    }

    public String getCommentString(){
        return commentString;
    }

        public void parse( String oclName) throws ParseException {

        oclSchemeName = oclName;


        mappingVector.addElement(oclSchemeName);
        mappingVector.addElement("selectedMethod");
        mappingVector.addElement("");


        mappingVector.addElement(oclSchemeName);
        mappingVector.addElement("selectedClass");
        mappingVector.addElement("");

        mappingVector.addElement(oclSchemeName);
        mappingVector.addElement("selectedParameter");
        mappingVector.addElement("");

        mappingVector.addElement(oclSchemeName);
        mappingVector.addElement("selectedAttribute");
        mappingVector.addElement("");



        id=0;

        start();

    }

  public final void start() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case PATTERNMOD:
      patternModifications();
      break;
    default:
      jj_la1[0] = jj_gen;     
    }
    label_1:
    while (true) {
      schema();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case POSTCONDITION:
      case PRECONDITION:
      case PREPOSTCONDITION:
      case INVARIANT:       
        break;
      default:
        jj_la1[1] = jj_gen;
        break label_1;
      }
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case COMMENT:
      comment();
      break;
    default:
      jj_la1[2] = jj_gen;     
    }
    jj_consume_token(0);
  }

  public final void patternModifications() throws ParseException {
    jj_consume_token(PATTERNMOD);
    label_2:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case MAPPINGS:
      case SEVERALSUBCLASSES:
      case MULTIINSTANCES:
      case ADDSTRINGFIELD:
      case ADDCLASSATTRIBUTE:
      case ADDPARAMETER:
      case ADDMETHOD:       
        break;
      default:
        jj_la1[3] = jj_gen;
        break label_2;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case SEVERALSUBCLASSES:
        jj_consume_token(SEVERALSUBCLASSES);
        jj_consume_token(STRING1);
        // create a multiple StringField
        addClassPropertyItem(SubclassesOf+token.image, false, true);
        setMultiple(SubclassesOf+token.image, true);
        // initially invisible
        showItem(SubclassesOf+token.image, false);
        // create an entry in the global vector, that contains the additional parsed classes and properties
        additionalProperties.addElement( new Entry(oclSchemeName,"canHaveSeveralSubclasses#",token.image,SubclassesOf +token.image));
        // add a propertyListener to do something, when the checkboxes change
        // add this stringfield to the vector, which contains all fields etc. for this OCL-Schema
        final String fieldName1 = token.image;
        itemVector.addElement(oclSchemeName);
        itemVector.addElement("visible");
        itemVector.addElement(SubclassesOf +fieldName1);
        addPropertyMapListener(oclSchemeName, new PropertyMapListener() {
                boolean on = false;
                public void propertiesChanged(PropertyMapEvent event){
                //IdeMessageManagerAccess.printMessage(IdeMessageType.INFORMATION, "Event: "+event.toString());		
                    if (on){
                        on = false;
                        showItemVector(itemVector, oclSchemeName , false);
                    }
                    else{
                        on = true;
                        showItemVector(itemVector, oclSchemeName, true);
                    }
                }
            });
        break;
      case MULTIINSTANCES:
        jj_consume_token(MULTIINSTANCES);
        jj_consume_token(STRING1);
        // create an entry in the global vector, that contains the additional parsed classes and properties
        additionalProperties.addElement( new Entry(oclSchemeName,"canHaveMultipleInstances#",token.image,""));

        final String fieldName2 = token.image;
        itemVector.addElement(oclSchemeName);
        itemVector.addElement("multiple");
        itemVector.addElement(fieldName2);
        addPropertyMapListener(oclSchemeName, new PropertyMapListener() {
                boolean on = false;
                public void propertiesChanged(PropertyMapEvent event){
                    //IdeMessageManagerAccess.printMessage(IdeMessageType.INFORMATION, "Event: "+event.toString());
                    if (on){
                        counter -= 1;
                        on = false;
                        if (counter==0)
                            showItemVector(itemVector, oclSchemeName , false);
                    }
                    else{
                        counter += 1;
                        on = true;
                        if (counter>0)
                            showItemVector(itemVector, oclSchemeName , true);
                    }
                }
            });
        break;
      case ADDMETHOD:
        jj_consume_token(ADDMETHOD);
        jj_consume_token(STRING1);
         String methodName = token.image;
        jj_consume_token(24);
        jj_consume_token(STRING1);
         // add a stringfield to enter the name of the new method
         addStringFieldItem(nameOfMethod + methodName + inClass +token.image);
         showItem(nameOfMethod + methodName + inClass +token.image, false);
         additionalProperties.addElement( new Entry(oclSchemeName,"addMethod#",token.image,nameOfMethod + methodName + inClass +token.image));
         // add a listener to turn the stringfield on (if OCL-constraint is selected) and off 
         final String fieldName3 = methodName;
         final String fieldName4 = token.image;
         itemVector.addElement(oclSchemeName);
         itemVector.addElement("visible");
         itemVector.addElement(nameOfMethod +fieldName3 +inClass +fieldName4);
         addPropertyMapListener(oclSchemeName, new PropertyMapListener() {
                 boolean on = false;
                 public void propertiesChanged(PropertyMapEvent event){
                     //IdeMessageManagerAccess.printMessage(IdeMessageType.INFORMATION, "Event: "+event.toString());
                     if (on){
                         on = false;
                         showItemVector(itemVector, oclSchemeName , false);
                     }
                     else{
                         on = true;
                         showItemVector(itemVector, oclSchemeName , true);
                     }
                 }
             });
        break;
      case ADDSTRINGFIELD:
        jj_consume_token(ADDSTRINGFIELD);
        jj_consume_token(25);
        jj_consume_token(STRING1);
         String stringFieldName = token.image;
        jj_consume_token(25);
         // add a stringfield to enter the name of the new attribute
         addStringFieldItem(stringFieldName);
         showItem(stringFieldName, false);
         additionalProperties.addElement( new Entry(oclSchemeName,"addStringField#", "", stringFieldName));
         // add a listener to turn the stringfield on (if OCL-constraint is selected) and off 
         final String fieldName13 = stringFieldName;
         itemVector.addElement(oclSchemeName);
         itemVector.addElement("visible");
         itemVector.addElement(fieldName13);
         addPropertyMapListener(oclSchemeName, new PropertyMapListener() {
                 boolean on = false;
                 public void propertiesChanged(PropertyMapEvent event){
                     //IdeMessageManagerAccess.printMessage(IdeMessageType.INFORMATION, "Event: "+event.toString());
                     if (on){
                         on = false;
                         showItemVector(itemVector, oclSchemeName , false);
                     }
                     else{
                         on = true;
                         showItemVector(itemVector, oclSchemeName , true);
                     }
                 }
             });
        break;
      case ADDPARAMETER:
        jj_consume_token(ADDPARAMETER);
        jj_consume_token(STRING1);
              String name = token.image;
              Vector values = new Vector();
        jj_consume_token(24);
        jj_consume_token(STRING1);
              String type="";
              if (token.image.equals("ComboBox"))
                type = "ComboBox";
        label_3:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case 24:            
            break;
          default:
            jj_la1[4] = jj_gen;
            break label_3;
          }
          jj_consume_token(24);
          jj_consume_token(25);
          jj_consume_token(STRING1);
              values.addElement(token.image);
          jj_consume_token(25);
        }
              if (type.equals("ComboBox")) {
                 addComboboxFieldItem(name, values, values.elementAt(0).toString());
                 showItem(name, false);
                 itemVector.addElement(oclSchemeName);
                 itemVector.addElement("visible");
                 itemVector.addElement(name);
                 addPropertyMapListener(oclSchemeName, new PropertyMapListener() {
                         boolean on = false;
                         public void propertiesChanged(PropertyMapEvent event){
                             //IdeMessageManagerAccess.printMessage(IdeMessageType.INFORMATION, "Event: "+event.toString());
                             if (on){
                                 on = false;
                                 showItemVector(itemVector, oclSchemeName , false);
                             }
                             else{
                                 on = true;
                                 showItemVector(itemVector, oclSchemeName , true);
                             }
                         }
                     });
              }
        break;
      case ADDCLASSATTRIBUTE:
        jj_consume_token(ADDCLASSATTRIBUTE);
        jj_consume_token(STRING1);
              String className = token.image;
        jj_consume_token(24);
        jj_consume_token(STRING1);
             String attrName = token.image;
        jj_consume_token(24);
        jj_consume_token(STRING1);
             additionalProperties.addElement( new Entry(oclSchemeName,"addClassAttribute#",className+"#"+token.image, nameOfClassAttribute + attrName + inClass +className));

             // add a stringfield to enter the name of the new attribute
             addStringFieldItem(nameOfClassAttribute + attrName + inClass + className);
             showItem(nameOfClassAttribute + attrName + inClass + className, false);
             // add a listener to turn the stringfield on (if OCL-constraint is selected) and off 
             final String fieldName10 = attrName;
             final String fieldName11 = className;
             itemVector.addElement(oclSchemeName);
             itemVector.addElement("visible");
             itemVector.addElement(nameOfClassAttribute +fieldName10 +inClass +fieldName11);
             addPropertyMapListener(oclSchemeName, new PropertyMapListener() {
                     boolean on = false;
                     public void propertiesChanged(PropertyMapEvent event){
                         //IdeMessageManagerAccess.printMessage(IdeMessageType.INFORMATION, "Event: "+event.toString());
                         if (on){
                             on = false;
                             showItemVector(itemVector, oclSchemeName , false);
                         }
                         else{
                             on = true;
                             showItemVector(itemVector, oclSchemeName , true);
                         }
                     }
                 });
        break;
      case MAPPINGS:
        jj_consume_token(MAPPINGS);
        jj_consume_token(STRING1);
                                mappingVector.addElement(oclSchemeName);
                                mappingVector.addElement(token.image);
                                String helper = "";
        jj_consume_token(24);
        jj_consume_token(25);
        jj_consume_token(STRING1);
                            helper += token.image;
        jj_consume_token(25);
            mappingVector.addElement(helper);
        break;
      default:
        jj_la1[5] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
  }

 public final void schema() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case POSTCONDITION:
    case PRECONDITION:
    case INVARIANT:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case POSTCONDITION:
        jj_consume_token(POSTCONDITION);
        break;
      case PRECONDITION:
        jj_consume_token(PRECONDITION);
        break;
      case INVARIANT:
        jj_consume_token(INVARIANT);
        break;
      default:
        jj_la1[6] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
                placeVector.addElement(oclSchemeName);
                String prepost = token.image;
                placeVector.addElement(prepost);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 26:
        jj_consume_token(26);
        jj_consume_token(STRING1);
                placeVector.addElement("method");
                placeVector.addElement(token.image);
        jj_consume_token(24);
        jj_consume_token(STRING1);
                     placeVector.addElement(token.image);
                     placeVector.addElement((new Integer(id)).toString());
        break;
      case 27:
        jj_consume_token(27);
        jj_consume_token(STRING1);
                placeVector.addElement("class");
                placeVector.addElement(token.image);
                // dummy-element to keep the same length
                placeVector.addElement("");
                placeVector.addElement((new Integer(id)).toString());
        break;
      default:
        jj_la1[7] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      jj_consume_token(SCHEMA);
                  constraint="";
      label_4:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case STRING1:          
          break;
        default:
          jj_la1[8] = jj_gen;
          break label_4;
        }
        jj_consume_token(STRING1);
                 constraint = constraint + token.image + "\n";

                 if (headerString.equals("")){
                   headerString = "<h3>"+ oclSchemeName +"</h3>";
                   if (prepost.equals("precondition#")) headerString = headerString + "<h4>Precondition</h4>";
                   if (prepost.equals("postcondition#")) headerString = headerString + "<h4>Postcondition</h4>";
                   if (prepost.equals("invariant#")) headerString = headerString + "<h4>Invariant</h4>";
                }
                commentString = commentString + "<br>" + token.image + "\n";
      }
                constraintVector.addElement(constraint);
                constraintVector.addElement((new Integer(id)).toString());
                id++;
      break;
    case PREPOSTCONDITION:
      jj_consume_token(PREPOSTCONDITION);
           placeVector.addElement(oclSchemeName);
           helpVector.removeAllElements();
           helpVector.addElement(oclSchemeName);
           String s = "";
           helpVector.addElement("postcondition#");
           placeVector.addElement("precondition#");
      jj_consume_token(26);
      jj_consume_token(STRING1);
             placeVector.addElement("method");
             helpVector.addElement("method");
             s = token.image;
             placeVector.addElement(s);
             helpVector.addElement(s);
      jj_consume_token(24);
      jj_consume_token(STRING1);
                     s = token.image;
                     placeVector.addElement(s);
                     placeVector.addElement((new Integer(id)).toString());
                     helpVector.addElement(s);
                     for (int i=0; i<helpVector.size(); i++)
                        placeVector.addElement(helpVector.elementAt(i));
                     placeVector.addElement((new Integer((id+1))).toString());
      jj_consume_token(SCHEMA);
                   constraint="";
      label_5:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case STRING1:          
          break;
        default:
          jj_la1[9] = jj_gen;
          break label_5;
        }
        jj_consume_token(STRING1);
                constraint = constraint + token.image + "\n";

                if (headerString.equals("")){
                  headerString = "<h3>"+ oclSchemeName +"</h3><h4>Precondition</h4>";
                }
                commentString = commentString + "<br>" + token.image + "\n";
      }
                constraintVector.addElement(constraint);
                constraintVector.addElement((new Integer(id)).toString());
                id++;
      jj_consume_token(SCHEMA);
                   constraint="";
      label_6:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case STRING1:          
          break;
        default:
          jj_la1[10] = jj_gen;
          break label_6;
        }
        jj_consume_token(STRING1);
                constraint = constraint + token.image + "\n";

                if (headerString.equals("")){
                  headerString = "<h3>"+ oclSchemeName +"</h3><h4>Postcondition</h4>";
                }
                commentString = commentString + "<br>" + token.image + "\n";
      }
                constraintVector.addElement(constraint);
                constraintVector.addElement((new Integer(id)).toString());
                id++;
      break;
    default:
      jj_la1[11] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

 public final void comment() throws ParseException {
    jj_consume_token(COMMENT);
    label_7:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case STRING1:        
        break;
      default:
        jj_la1[12] = jj_gen;
        break label_7;
      }
      jj_consume_token(STRING1);
        commentString = "<p>"+headerString+"</p>"
                        +"<p>"+token.image+"</p>"
                        + "<p>" + commentString+ "</p>";
    }
  }

  public MyParserTokenManager token_source;
  ASCII_CharStream jj_input_stream;
  public Token token, jj_nt;
  private int jj_ntk;
  private int jj_gen;
  private final int[] jj_la1 = new int[13];
  private final static int[] jj_la1_0 = {0x20,0x78000,0x80,0x7f00,0x1000000,0x7f00,0x58000,0xc000000,0x800000,0x800000,0x800000,0x78000,0x800000,};

  public MyParser(java.io.InputStream stream) {
    jj_input_stream = new ASCII_CharStream(stream, 1, 1);
    token_source = new MyParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 13; i++) jj_la1[i] = -1;
  }

  public void ReInit(java.io.InputStream stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 13; i++) jj_la1[i] = -1;
  }

  public MyParser(java.io.Reader stream) {
    jj_input_stream = new ASCII_CharStream(stream, 1, 1);
    token_source = new MyParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 13; i++) jj_la1[i] = -1;
  }

  public void ReInit(java.io.Reader stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 13; i++) jj_la1[i] = -1;
  }

  public MyParser(MyParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 13; i++) jj_la1[i] = -1;
  }

  public void ReInit(MyParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 13; i++) jj_la1[i] = -1;
  }

 private final Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = token).next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) {
      jj_gen++;
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }

 public final Token getNextToken() {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    jj_gen++;
    return token;
  }

 public final Token getToken(int index) {
    Token t = token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

 private final int jj_ntk() {
    if ((jj_nt=token.next) == null)
      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }

  private java.util.Vector jj_expentries = new java.util.Vector();
  private int[] jj_expentry;
  private int jj_kind = -1;

 public final ParseException generateParseException() {
    jj_expentries.removeAllElements();
    boolean[] la1tokens = new boolean[28];
    for (int i = 0; i < 28; i++) {
      la1tokens[i] = false;
    }
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 13; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 28; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.addElement(jj_expentry);
      }
    }
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = (int[])jj_expentries.elementAt(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

 public final void enable_tracing() {
  }

 public final void disable_tracing() {
  }

}
