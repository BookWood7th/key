// This file is part of KeY - Integrated Deductive Software Design
// Copyright (C) 2001-2005 Universitaet Karlsruhe, Germany
//                         Universitaet Koblenz-Landau, Germany
//                         Chalmers University of Technology, Sweden
//
// The KeY system is protected by the GNU General Public License. 
// See LICENSE.TXT for details.
//
//
package de.uka.ilkd.key.counterexample;

import java.util.StringTokenizer;
import java.util.Vector;

/**
 * This class is a representation of the Model generated by mgtp 
 * displaying the values that the variables are assigned, the 
 * interpretation of subterms, the statistics of the latest mgtp 
 * run etc. All this in a hopefully
 * readable text format which one can extract with the toString() Method
 * @author Sonja Pieper
 * @since 13/08/01
 * @version 0.1 
 */
public class ModelRepresentation {

    private Vector vars;
    private Vector subterms;
    private Vector termeval;
    private String model;
    
    public ModelRepresentation(String mgtpprove){

	vars = new Vector();
	subterms = new Vector();
	termeval = new Vector();

	model = this.extractModel(mgtpprove);
	this.processModel(this.model);

    }
    
    public String getVars(){
        String s = new String();
	for(int i=0;i<vars.size();i++){
            s= s + vars.elementAt(i) + "\n";
        }
        return s;
    }
    
    public String getTermeval(){
	String s = new String();
	for(int i=0;i<termeval.size();i++){
            s= s + termeval.elementAt(i) + "\n";
        }
        return s;
    }
    
    public String getSubterms(){
	String s = new String();
	for(int i=0;i<subterms.size();i++){
            s= s + subterms.elementAt(i) + "\n";
        }
        return s;
    }
    
    private String extractModel(String prove){
	String m = new String();
	//@@@ extract model from prove is not yet implemented
	return m;
    }
    

    private void processModel(String m){

	String intpr = new String();
	String zeile = new String();
	
	StringTokenizer zeilenteiler = new StringTokenizer(m,"\n");

	int i=0;
	
	while (zeilenteiler.hasMoreElements()){
	    i++;
	    zeile = zeilenteiler.nextToken();
	    
	    //interpretation: intpr kommt vor, val kommt nicht vor
	    if (zeile.startsWith("intpr") && zeile.lastIndexOf("val")<0){
		intpr = intpr + zeile +"\n";
	    } 

	    //Term evaluation: is kommt vor, arg kommt nicht vor
	    else if (zeile.startsWith("is") && zeile.lastIndexOf("arg")<0) {
		
		//Variable extraction "is(val(sk_....),...)":
		if(zeile.startsWith("is(val(sk_")){
		    int par = zeile.indexOf("),");
		    String sko = zeile.substring(7,par);
		    String val = zeile.substring(par+2,zeile.length()-1);
		    if(val.lastIndexOf("val")<0){
			vars.add(sko + " : " + val +"\n");
		    }
		}
		//Subterm extraction:
		else{
		    zeile = zeile.substring(3,zeile.length()-1);

		    //schliessende klammer von val finden:
		    int open = 1;
		    int pos = 4;
		    while(open>0){
			switch(zeile.charAt(pos)){
			case '(' : open++; break;
			case ')' : open--; break;
			}
			pos++;
		    }
		
		    //subterms = subterms + zeile + "\n";
		    String sub = zeile.substring(4,pos-1);
		    String val = zeile.substring(pos+1,zeile.length());
		    if(val.lastIndexOf("val")<0){
			if(sub.lastIndexOf("sk_")>=0){
			    subterms.add(sub +" : "+ val +"\n");
			}
			else{
			    termeval.add(termeval + sub +" : "+ val +"\n"); 
			}
		    }
		}

		
		
	    }
	}


	/* @@@ die ersetzung ist auskommentiert sk_var
	   for(int j=0;j<variables.size();j++){
	   String name = (variables.elementAt(j)).toString();
	   name = name.substring(5,name.lastIndexOf("->")-1);
	   ausgabe = mc.substitute(ausgabe,name);
	   }
	*/

    }



}
