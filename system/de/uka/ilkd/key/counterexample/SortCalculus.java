// This file is part of KeY - Integrated Deductive Software Design
// Copyright (C) 2001-2005 Universitaet Karlsruhe, Germany
//                         Universitaet Koblenz-Landau, Germany
//                         Chalmers University of Technology, Sweden
//
// The KeY system is protected by the GNU General Public License. 
// See LICENSE.TXT for details.
//
//
//


package de.uka.ilkd.key.counterexample;

import java.util.Vector;

import de.uka.ilkd.key.logic.op.ConstructorFunction;
import de.uka.ilkd.key.logic.sort.ArrayOfSort;
import de.uka.ilkd.key.logic.sort.GenSort;
import de.uka.ilkd.key.logic.sort.Sort;

/**
 * This class generates the clauses which depend on the generated sorts, 
 * it includes the static clauses generated by <code>Calculus</code> 
 * which this class extends.
 *
 * These clauses are different for each adt, depending on the generated
 * sorts that are used. To these belong the domain generation and search,
 * the rewriting of constructor arguments and the 'freely generated'
 * property clauses.
 *
 * In the 'all' attribute inherited from Calculus are all Clauses
 * generated by the Calculus class, which means, that if you use an
 * instance of this class, you have both the static clauses of Calculus
 * and the Sort-dependent clauses of this class.
 * 
 * @author Sonja Pieper
 * @version 0.1 
 */
public class SortCalculus extends Calculus { 

    Vector sortdata;
    Clauses sorts;

    /**
     * Creates a new instance of SortCalculus. First calls the
     * constructor of the super-class, the effect is that you
     * already have the static clauses in the all-List after that
     * is done. Afterwards all clauses SortCalculus generates
     * are added to the list.
     *
     * @param s The generated sorts of the adt are needed to generate
     *          the clauses of this class
     */
    SortCalculus(Vector s){
	super();
        sortdata = s;
        sorts = new Clauses();
        sorts.add(this.domains());
	sorts.add(this.domainsearch());
        sorts.add(this.constrRewriting());
        sorts.add(this.freelyGenerated());
	this.all.add(sorts);
    }

    /**
     * This method returns a subset of the clauses of the complete
     * calculus, the clauses that generate the domain and search the domain,
     * constructor rewriting and the clauses that ensure the 
     * adt's 'freely generated' generated property.
     *
     * @return The clauses that are dependent on knowing the adt's sorts.
     */
    public Clauses getSortClauses(){
	return sorts;
    }

    /**
     * This method returns a list of clauses which contains one clause 
     * for each constructor in each sort. These clauses generate the domain.
     *
     * @return The list of domain generating clauses.
     */
    private Clauses domains(){

	Clauses cs = new Clauses();

	// for each sort generate domain clauses:
	for(int sortidx=0;sortidx<sortdata.size();sortidx++){
	    
	    GenSort currentsort = (GenSort)sortdata.elementAt(sortidx);
	    String sortname = currentsort.name().toString();
	    String gen = "gen"+sortname;
	    Vector constructors = currentsort.getConstructors();

	    cs.addComment("Generating domain for "+sortname);

	    // for each constructor generate one clause:
	    for(int constridx=0;constridx<constructors.size();constridx++)
		{
		    
		    ConstructorFunction konstr = (ConstructorFunction)constructors.elementAt(constridx);
		    ArrayOfSort params = konstr.argSort();
		    
		    if (konstr.arity()==0)
			{
			    // f.e. "-> gensort(constr,1) ."
			    cs.add(new Clause("",gen+"("+konstr.name().toString()+",1)"));
			} 
		    else 
			{
			    //  "max(M),gensort_0(X_0,Y_0),...,gensort_n(X_n,Y_n),
			    //  {Y_(n+1)=1+Y_0+...+Y_n},{1+Y0+...+Y_n<=M} 
			    //  -> gensort(push(X_0,...,X_n),Y_(n+1)) ."

			    String aconj = new String();

			    { /* begin antecedent generation */

				aconj = "max(M)";
			    
				// "gensort(X_i,Y_i)"
				for(int paramidx=0;paramidx<params.size();paramidx++)
				    {
					aconj = aconj + ",gen"+(params.getSort(paramidx)).name().toString()
					    +"(X"+paramidx+",Y"+paramidx+")";
				    }
			    
				//{Y_(n+1)=1+Y_0+...+Y_n},{1+Y0+...+Y_n<=M}
				
				String Y0toYn = new String();
				for(int i = 0;i<konstr.arity();i++)
				    {
					Y0toYn = Y0toYn + "+Y"+i;
				    }
				
				aconj = aconj + "{Y"+konstr.arity()+"=1"+Y0toYn+"},{1"
				    +Y0toYn+"<=M}";

			    }/* end antecedent generation */

			    String cnsq = new String();

			    {/* begin consequent generation */

				//gensort(constr(X_0 ... X_n),Y_(n+1))
			    
				String X0toXn = new String("X0");
				for(int i = 1;i<konstr.arity();i++)
				    {
					X0toXn = X0toXn + ",X"+i;
				    }
			    
				cnsq = "gen"+sortname+"("+konstr.name().toString()+"("+X0toXn+")"
				    +",Y"+konstr.arity()+")";

			    }/* end consequent generation */
			    
			    //add clause to list:
			    cs.add(new Clause(aconj,cnsq));
			    
			}/* else constr.arity()>0 */

		}/* for constridx */

	    //redirecting from gennat predicate to nat predicate:
	    cs.add(new Clause("gen"+sortname+"(X,_)",sortname+"(X)",
			      "Redirecting domain for "+sortname));

	}/* for sortidx */

        return cs;

    }/* domains() */
    

    /**
     * For each sort there is on clause that searches the domain of that sort for
     * elements of that sort to match with other clauses. This method generates these
     * search clauses.
     *
     * @return the list of domainsearch clauses
     */
    private Clauses domainsearch(){
	
	Clauses cs = new Clauses();

	for(int sortidx=0;sortidx<sortdata.size();sortidx++)
	    {
		GenSort currentsort = (GenSort)sortdata.elementAt(sortidx);
		String sortname = currentsort.name().toString();
		Vector constructors = currentsort.getConstructors();
		
		cs.addComment("Search domain of sort "+sortname);
		
		//--------- begin consequent generation ------------------
		
		String cnsq = new String();
		
		for(int constridx = 0;constridx<constructors.size();constridx++)
		    {
			ConstructorFunction konstr = (ConstructorFunction)constructors.elementAt(constridx);
			ArrayOfSort params = konstr.argSort();
			
			String or = (constridx>0 ? ";" : "");
			
			String search = new String();
			String is = "is(X,"+konstr.name().toString()+"(";
			
			for(int paramidx=0;paramidx<konstr.arity();paramidx++)
			    {
				is = is + "arg"+paramidx+"(X)";
				Sort paramsort = params.getSort(paramidx);
				search = search + ",search_"+paramsort.name().toString()+"(arg"+paramidx+"(X))";
			    }/* paramidx */
			
			is = ")";
			cnsq = cnsq + or + is + search;
			
		    }/* constridx */
		
		// ------------- end consequent generation --------------

		cs.add(new Clause("search_"+sortname+"(X)",cnsq));
		      
	    } /* for sortidx */
		
	return cs;
	
    }/* domainsearch() */

    	
    
    /**
     * The following rules implement the sort dependent rewrite rules
     * @return the list of clauses for the rewriting of arguments
     *         of the constructors. These clauses differ from the normal
     *         argument rewriting clauses because constructors do not
     *         have an interpretation.
     */
    private Clauses constrRewriting(){ 
	Clauses cs = new Clauses();
	
	cs.addComment("Constructor Rewriting clauses for each sort:");
	

	for(int sortidx = 0;sortidx<sortdata.size();sortidx++)
	    {
		GenSort currentsort = (GenSort)sortdata.elementAt(sortidx);
		String sortname = currentsort.name().toString();
		Vector constructors = currentsort.getConstructors();

		for(int constridx = 0;constridx<constructors.size();constridx++)
		    {
			ConstructorFunction konstr = (ConstructorFunction)constructors.elementAt(constridx);
			String pre = "is(X,"+konstr.name().toString();

			for(int rewriteidx = 0;rewriteidx<konstr.arity();rewriteidx++)
			    {/* the currently rewritten param */

				String aconjparams = new String();
				String cnsqparams = new String();

				for(int paramidx = 0;paramidx<konstr.arity();paramidx++)
				    {
					String comma = (paramidx>0 ? "," : "" );
					aconjparams = aconjparams + comma + "Y" + paramidx;
					cnsqparams = cnsqparams + comma + 
					    (paramidx==rewriteidx ? "Z" : "Y" + paramidx); 
				    }/* paramidx */

			   
				String aconj = "is(X,"+konstr.name().toString()
				    +"("+aconjparams+")),is(Y"+rewriteidx+",Z)";
				String cnsq = "is(X,"+konstr.name().toString()+"("+cnsqparams+"))";
				
				cs.add(new Clause(aconj,cnsq));
			    }/* rewriteidx */

		    }/* constridx */

	    }/* sortidx */

	return cs;

    }/* sort dependent constructor rewriting */

    
    /**
     * the following rules implement equality under the
     * assumption that the data types are 'freely generated'
     * for each Konstruktor there is one rule that says when the
     * atom is the same so must be the parameters. 'freely generated' backwards.
     * f.e. 'same(push(N,ST),push(N1,ST1)) -> same(N,N1),same(ST,ST1) .'
     * or   'same(succ(N),succ(N1)) -> same(N,N1) .'
     * %%% what about konstruktors with zero parameters?
     */

    private Clauses freelyGenerated(){ //@@@

	Clauses cs = new Clauses();

      	cs.addComment("For each Konstruktor 'freely generated' backwards rules:");

	//---for each sort
	for(int sortidx = 0;sortidx<sortdata.size();sortidx++) {

	    GenSort currentsort = (GenSort)sortdata.elementAt(sortidx);
	    String sortname = currentsort.name().toString();
	    Vector constructors = currentsort.getConstructors();
	    
	    //---take each constructor
	    for(int constridx = 0;constridx<constructors.size();constridx++) {

		ConstructorFunction konstr = (ConstructorFunction)constructors.elementAt(constridx);
		
		//---and compare with each other construcotr
		for(int comp=0;comp<constructors.size();comp++){
		    
		    ConstructorFunction compkonstr = (ConstructorFunction)constructors.elementAt(comp);

		    //---comparison with self generates a 'different'-clause
		    if(constridx == comp) {
			
			if (konstr.arity()==0){ 

			    //f.e. different(nil,nil) ->  .
			    cs.add(new Clause("different("+konstr.name().toString()
					      +","+konstr.name().toString()+")",""));
			} /* if konstr.arity() !=0 */
			else{
			    
			    String argX = new String();
			    String argY = new String();
			    String cnsqsame = new String();
			    String cnsqdiff = new String();

			    for(int i=0;i<konstr.arity();i++){

				String comma = (i>0?",":"");
				String semicolon = (i>0?";":"");
				argX = argX + comma + "X" + i;
				argY = argY + comma + "Y" + i;
				cnsqsame = cnsqsame + comma + "same(X"+i+",Y"+i+")";
				cnsqdiff = cnsqdiff + semicolon + "different(X"+i+",Y"+i+")";
				
			    } /* for i */
			    
			    String args = konstr.name().toString()
				+"("+argX+"),"+konstr.name().toString()+"("+argY+")";
			    Clause same = new Clause("same("+args+")",cnsqsame);
			    Clause different = new Clause("different("+args+")",cnsqdiff);
			    cs.add(same);
			    cs.add(different);

			} /* else */
		    } /* if constridx != comp*/			

		    //---comparison with other constructor generates 'same'-clause
		    else{

			// f.e. same(succ(_),null) ->  .

			String args = new String();
			for(int n=0;n<compkonstr.arity();n++){

			    args = args + ( (n>0) ? "," : "" ) + "_";

			}
			args = "("+args+")";
			String compstr = new String(compkonstr.name().toString()+args);

			String args1 = new String();
			for(int n=0;n<konstr.arity();n++){

			    args1 = args1 + ( (n>0) ? "," : "" ) + "_";

			}
			args1 = "("+args1+")";
			String konstrstr = konstr.name().toString()+args;

			cs.add(new Clause("same("+konstrstr+","+compstr+")",""));

		    } /*else */

		} /* for comp */
	    } /* for constridx */
	} /* for sortidx */

        return cs;
    }

}
