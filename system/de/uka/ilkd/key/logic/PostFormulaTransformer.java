// This file is part of KeY - Integrated Deductive Software Design
// Copyright (C) 2001-2007 Universitaet Karlsruhe, Germany
//                         Universitaet Koblenz-Landau, Germany
//                         Chalmers University of Technology, Sweden
//
// The KeY system is protected by the GNU General Public License. 
// See LICENSE.TXT for details.
//
//

/* Generated by Together */


package de.uka.ilkd.key.logic;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Stack;

import de.uka.ilkd.key.logic.op.ArrayOfQuantifiableVariable;
import de.uka.ilkd.key.logic.op.Function;
import de.uka.ilkd.key.logic.op.NonRigidFunction;
import de.uka.ilkd.key.logic.op.Operator;
 
/** 
 * Only for use in the generation of the translation of an OCL constaint !!!
 * 
 * creates a mapping of the names of functions (as strings) to the
 * corresponding functionsymbol (object) ...
 */ 
public class PostFormulaTransformer extends Visitor {
    
    private java.util.Map funcNameSymbolMap;
    private java.util.Map nonrigidFunctionSymbolMap;
    private Term computedResult;
    
    /**
     * the stack contains the subterms that will be added in the next step of
     * execPostOrder in Term in order to build the new term. A boolean value
     * between or under the subterms on the stack indicate that a term using
     * these subterms should build a new term instead of using the old one,
     * because one of its subterms has been built, too.
     */
    private Stack subStack; //of Term (and Boolean)
    private TermFactory tf=TermFactory.DEFAULT;
    private Boolean newMarker=new Boolean(true);

    // SUFFIX FOR NEW FUNCTION SYMBOLS ...
    public final static String  NEW_FUNCSYMBOL_SUFFIX = "'";

    public PostFormulaTransformer(java.util.Set nonrigidFunctionSymbols,
				  java.util.Map funcNameSymbolMap) {
	this.funcNameSymbolMap = funcNameSymbolMap;
	computedResult=null;
	subStack = new Stack(); // of Term

	// Now we have to initialze the mapping which maps every nonrigid function symbol
	// in a postcondition onto a new function symbol ...
	nonrigidFunctionSymbolMap = new HashMap();
	Function currentFunction,newFunction;
	String fNameString;
	String newFuncNameString;
	Name newFuncName;


	for(Iterator fSymbIt = nonrigidFunctionSymbols.iterator();fSymbIt.hasNext();){
	    currentFunction = (Function) fSymbIt.next();
	    fNameString = currentFunction.name().toString();
	    if (!fNameString.endsWith("@pre")){
		// REMARK: @pre-functions will be handled specially in visit(..)-method !
	        
	        newFuncNameString = fNameString + NEW_FUNCSYMBOL_SUFFIX;
	        
	        
	        
	        newFuncName = new Name(newFuncNameString);
	        
	        // System.err.println("created NEW SINGLE NAME == " + newFuncName);
	        
	        
	        newFunction = new NonRigidFunction(newFuncName,
	                                           currentFunction.sort(),
	                                           currentFunction.argSort());
	        nonrigidFunctionSymbolMap.put(currentFunction,newFunction);
	        
	    }
	}

    }
    

    private Term[] neededSubs(int n) {
	boolean newTerm=false;
	Term[] result=new Term[n];
	for (int i=n-1; i>=0; i--) {
	    Object top=subStack.pop();
	    if (top==newMarker){
		newTerm=true; 
		top=subStack.pop();
	    }
	    result[i]=(Term) top;
	}
	if (newTerm && (subStack.empty() || subStack.peek()!=newMarker) ) {
	    subStack.push(newMarker);
	}
	return result;
    }

    public void visit(Term visited) {
	
	 // System.err.println("Currently VISITING : " + visited);


	boolean changed = false;
	Function newFunctionSymbol=null;
	Function functionToReplaceForAtPre;

	if (visited.op() instanceof Function){
	    Function currentFunction = (Function) visited.op();
	    newFunctionSymbol = currentFunction;
	    String funcNameString = currentFunction.name().toString();
	    if(funcNameString.endsWith("@pre")){
		// we have an @pre-function, therefore we have to check, whether
		// we must replace 
		
		// Check whether we already have a corresponding function symbol in the
		// map from the preconditionFormulas ...
		String searchFuncName = funcNameString.substring(0, funcNameString.length() - 4);

		  // System.err.println("REPLACING " + funcNameString + "; Searching for : " + searchFuncName);

		
		if (funcNameSymbolMap.containsKey(searchFuncName)){
		    functionToReplaceForAtPre = (Function) funcNameSymbolMap.get(searchFuncName);
		     // System.err.println("FOUND ! REPLACE WITH :" + functionToReplaceForAtPre);
		} else {
		    // the corresponding function (in the pre state) has not been used in
		    // the preconditionFormula therefore we have to create a new such symbol
		    // and store it in the map ...
		    Name newFuncName = new Name(searchFuncName);

		    functionToReplaceForAtPre = new NonRigidFunction(newFuncName,
							     currentFunction.sort(),
							     currentFunction.argSort());
		    funcNameSymbolMap.put(searchFuncName,functionToReplaceForAtPre);
		    
		     // System.err.println("NOT FOUND ! REPLACE WITH :" + functionToReplaceForAtPre);

		}

		newFunctionSymbol = functionToReplaceForAtPre;
		changed = true;
	    } else {
		// Check other case in which a function symbol has to be replaced 
		// by a new one:
		// If we have a rigidFunctionSymbol (but not with @pre)
		// , we have to replace it by a new
		// function symbol ( specified in nonrigidFunctionMap ) ...
		
		if(nonrigidFunctionSymbolMap.containsKey(currentFunction)){
		    // we have to replace the current function symbol by 
		    // the function symbol specified by the nonrigidFunctionMap ...
		    
		    // System.err.println("REPLACING (rigid) " + funcNameString );
		    
		    newFunctionSymbol = (Function) nonrigidFunctionSymbolMap.get(currentFunction);
		    // System.err.println("REPLACE WITH :" + newFunctionSymbol);
		    
		    changed = true;
		}
		
	    }
	
	    
	}

	if (changed && (subStack.empty() || subStack.peek()!=newMarker)) {
	    subStack.push(newMarker);
	}
	
	
	ArrayOfQuantifiableVariable boundVars 
	    = ((visited.varsBoundHere(0).size() == 0) ?
	       visited.varsBoundHere(1) :
	       visited.varsBoundHere(0)); 
	
	
	Term[] neededsubs = neededSubs(visited.arity());
	if (changed || (!subStack.empty() && 
			subStack.peek() == newMarker)) {

	    //System.err.println("Create new term with : " );
	    //System.err.println("func symbol ==  : " + newFunctionSymbol );
	    //System.err.println("boundVars ==  : " + boundVars);

	    Operator newOp;
	    if (changed) {
		// Take the newly generated function symbol ...
		newOp = newFunctionSymbol;
	    } else {
		// Take the existing one ...
		newOp = visited.op();
	    }

	    subStack.push(tf.createTerm(newOp, 
					neededsubs,
					boundVars,
					visited.javaBlock()));
	} else {
	    subStack.push(visited);
	}		
	
    }

    /**
     * delivers the new built term
     */
    public Term getTerm() {
	if (computedResult==null) {
	    Object o=null;
	    do {
		o=subStack.pop();
	    } while (o==newMarker);
	    Term t=(Term) o;
	    if(t != null){
		computedResult = t;
	    }
	}
	return computedResult;
    }



    
}
