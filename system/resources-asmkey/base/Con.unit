unit Con

export *

import * from Base;
import * from Bool;
import * from Asm;


taclet con_skip_left {
        find (con(:skip;) ==>) 
	replacewith (TRUE ==>)
        rule sets(simplify_asm)
    };
    
taclet con_skip_right {
        find (==> con(:skip;)) 
	replacewith (==> TRUE)
        rule sets(simplify_asm)
    };
      
taclet con_assign_left {
        find (con(:#t := #s;) ==>)
	replacewith (TRUE ==>)
        rule sets(simplify_asm)
    };
   
taclet con_assign_right {
        find (==> con(:#t := #s;))
	replacewith (==> TRUE)
        rule sets(simplify_asm)
    };

taclet con_par_left {
        find (con(:#R par #S;) ==>)
	replacewith (con(:#R;) & con(:#S;) & joinable(:#R, #S;) ==>)
	rule sets(simplify_asm)
    };
    
taclet con_par_right {
        find (==> con(:#R par #S;))
	replacewith (==> con(:#R;) & con(:#S;) & joinable(:#R, #S;))
	rule sets(simplify_asm)
    };

taclet con_branch_left {
        find (con(:if #b then #R else #S end;) ==>)
        replacewith (#b = true, con(:#R;) ==>);
	replacewith (#b = false, con(:#S;) ==>)
        rule sets(split_asm_if)
    };

taclet con_branch_right {
        find (==> con(:if #b then #R else #S end;))
        replacewith (#b = true ==> con(:#R;));
	replacewith (#b = false ==> con(:#S;))
        rule sets(split_asm_if)
    };

taclet con_let_left {
        find (con(:let #x = #s in #R end;) ==>)
	cond(#x not free in #s, #sk new depending on #s)
        replacewith (#sk = #s, con(:{#x #sk} #R;) ==>)
    };

taclet con_let_right {
        find (==> con(:let #x = #s in #R end;))
	cond(#x not free in #s, #sk new depending on #s)
        replacewith (#sk = #s ==> con(:{#x #sk} #R;))
    };

taclet con_all_left {
        find (con(:forall #x with #b do #R end;) ==>)
        cond (#y not free in #b, #y not free in #R)
	replacewith (all #x; (#b = true -> con(:#R;) &
                              all #y; ({#x #y} #b = true -> joinable(:#R, {#x #y} #R;))) ==>)
    };

taclet con_all_right {
        find (==> con(:forall #x with #b do #R end;))
        cond (#y not free in #b, #y not free in #R)
	replacewith (==> all #x; (#b = true -> con(:#R;) &
	                          all #y; ({#x #y} #b = true -> joinable(:#R, {#x #y} #R;))))
    };
    
taclet con_seq_left {
        find (con(:#R seq #S;) ==>)
        replacewith (con(:#R;) & [[#R]] con(:#S;) ==>)
        //rule sets(split_asm) 
    };
    
taclet con_seq_right {
        find (==> con(:#R seq #S;))
        replacewith (==> con(:#R;) & [[#R]] con(:#S;))
        //rule sets(split_asm) 
    };
    
taclet con_try_left {
        find  (con(:try #R else #S end;) ==>)
        replacewith (con(:#R;) | (def(:#R;) & con(:#S;)) ==>)
        //rule sets(split_asm_try)
    };
    
taclet con_try_right {
        find  (==> con(:try #R else #S end;))
        replacewith (==> con(:#R;) | (def(:#R;) & con(:#S;)))
        //rule sets(split_asm_try)
    };
    
taclet con_name_left {
        find (con(:#rho;)==>)
	cond (derived #rho)
	replacewith (con(:@#META_DERIVED(#rho);)==>)
	rule sets(simplify_asm_named)
    };
   
taclet con_name_right {
        find (==> con(:#rho;))
	cond (derived #rho)
	replacewith (==> con(:@#META_DERIVED(#rho);))
	rule sets(simplify_asm_named)
    };
    
