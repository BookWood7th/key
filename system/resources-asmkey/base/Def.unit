unit Def

export *

import * from Base
import * from Bool
import * from Asm

taclet def_skip_left {
        find ([[#H]] def(:skip;) ==>) 
	replacewith ([[#H]] TRUE ==>)
        rule sets(simplify_asm)
    };

taclet def_skip_right {
        find (==> [[#H]] def(:skip;)) 
	replacewith (==> [[#H]] TRUE)
        rule sets(simplify_asm)
    };

taclet simple_def_skip_right {
        find (==> def(:skip;))
	replacewith (==> TRUE)
	rule sets(simplify_asm)
    };

taclet def_assign_left {
        find ([[#H]] def(:#s := #t;) ==>)
	replacewith ([[#H]] TRUE ==>)
        rule sets(simplify_asm)
    };
    
taclet def_assign_right {
        find (==> [[#H]] def(:#s := #t;))
	replacewith (==> [[#H]] TRUE)
        rule sets(simplify_asm)
    };

taclet def_par_left {
        find ([[#H]] def(:#R par #S;) ==>)
        replacewith ([[#H]] (def(:#R;) & def(:#S;)) ==>)
        rule sets(simplify_asm)
    };
    
taclet def_par_right {
        find (==> [[#H]] def(:#R par #S;))
        replacewith (==> [[#H]] (def(:#R;) & def(:#S;)))
        rule sets(simplify_asm)
    };
    
taclet def_branch_left {
        find ([[#H]] def(:if #b then #R else #S end;) ==>)
        replacewith ([[#H]] #b = true, [[#H]] def(:#R;) ==>);
	replacewith ([[#H]] #b = false, [[#H]] def(:#S;) ==>)
        rule sets(split_asm_if)
    };
    
taclet def_branch_right {
        find (==> def(:if #b then #R else #S end;))
        replacewith (#b = true ==> def(:#R;));
	replacewith (#b = false ==> def(:#S;))
        rule sets(split_asm_if)
    };

taclet def_let_left {
        find (def(:let #x = #s in #R end;) ==>)
	cond(#x not free in #s, #sk new depending on #s)
        replacewith (#sk = #s, def(:{#x #sk} #R;) ==>)
        rule sets(simplify_asm)
    };
    
taclet def_let_right {
        find (==> def(:let #x = #s in #R end;))
	cond(#x not free in #s, #sk new depending on #s)
        replacewith (#sk = #s ==> def(:{#x #sk} #R;))
        rule sets(simplify_asm)
    };
   
taclet def_all_left {
        find (def(:forall #x with #b do #R end;) ==>)
	replacewith (all #x ; (#b = true ->  def(:#R;)) ==>)
    };
   
taclet def_all_right {
        find (==> def(:forall #x with #b do #R end;))
	replacewith (==> all #x ; (#b = true ->  def(:#R;)))
    };
    
taclet def_seq_left {
        find (def(:#R seq #S;) ==>)
	replacewith (def(:#R;) & [[#R]] def(:#S;) ==>)
	//rule sets(simplify_asm)
    };
    
taclet def_seq_right {
        find (==> def(:#R seq #S;))
	replacewith (==> def(:#R;) & [[#R]] def(:#S;))
	//rule sets(simplify_asm)
    };
    
taclet def_try_left {
        find (def(:try #R else #S end;) ==>)
	replacewith (def(:#R;) &  (con(:#R;) | def(:#S;)) ==>)
        rule sets(split_asm_try)
    };
    
taclet def_try_right {
        find (==> def(:try #R else #S end;))
	replacewith (==> def(:#R;) &  (con(:#R;) | def(:#S;)))
        rule sets(split_asm_try)
    };
    
taclet def_name_left {
	find (def(:#rho;) ==>)
	cond (derived #rho)
	replacewith (def(:@#META_DERIVED(#rho);) ==>)
	rule sets(simplify_asm_named)
    };
    
taclet def_name_right {
	find (==> def(:#rho;))
	cond (derived #rho)
	replacewith (==> def(:@#META_DERIVED(#rho);))
	rule sets(simplify_asm_named)
    };
