unit Int;

export *;

import * from Base;
import * from Bool;

sort int
sort numbers

static function numbers #;
static function numbers 0 (numbers);
static function numbers 1 (numbers);
static function numbers 2 (numbers);
static function numbers 3 (numbers);
static function numbers 4 (numbers);
static function numbers 5 (numbers);
static function numbers 6 (numbers);
static function numbers 7 (numbers);
static function numbers 8 (numbers);
static function numbers 9 (numbers);
static function numbers neg (numbers);

static function int z (numbers);

static function int succ(int);
static function int pred(int);
static function int ~p(int,int);
static function int ~m(int);
static function int ~d(int,int);
  
static function int mul(int, int);
static function int mod(int, int);
static function int div(int, int);

static function int posdiv(int, int);

static function bool f_lt(int, int);
static function bool f_leq(int, int);
static function bool f_gt(int, int);
static function bool f_geq(int, int);

predicate lt(int, int);
predicate leq(int, int);
predicate gt(int, int);
predicate geq(int, int);

schema int #i, #i0, #i1, #i2, #i3, #i4, #j, #j0, #j1;
schema variable int #k, #k1, #nv;
schema numbers #iz, #jz;


//--------------------------------------------------------------------
// some of these taclets are from Isabelle theory IntArith
//--------------------------------------------------------------------


 //reviewed 04/16/2004, St.S.
taclet less_iff_diff_less_0  {find (lt(#i0,#i1)) replacewith (lt(~d(#i0,#i1),0)) };

 //reviewed 04/16/2004, St.S.
taclet leq_iff_diff_leq_0    {find (leq(#i0,#i1)) replacewith (leq(~d(#i0,#i1),0))};

 //reviewed 04/16/2004, St.S.
taclet minus_distribute_1 { find (~m(~p(#i,#i1))) replacewith (~p(~m(#i),~m(#i1))) 
	rule sets(simplify_int) 
	displayname "minus_distribute"};
 //reviewed 04/16/2004, St.S.
taclet minus_distribute_2 { find (~m(~d(#i,#i1))) replacewith (~p(~m(#i),#i1)) 
	rule sets(simplify_int) 
	displayname "minus_distribute"};

 //reviewed 04/16/2004, St.S.
taclet left_add_mult_distrib {find (~p(mul(#i0,#i1), ~p(mul(#i2,#i1),#i3) ) ) 
                           replacewith (~p(mul(~p(#i0,#i2), #i1), #i3)) };

 //reviewed 04/16/2004, St.S.
taclet eq_add_iff1            {find ( ~p(mul(#i0,#i1),#i2)=~p(mul(#i3,#i1),#i4) ) 
                           replacewith (~p(mul(~d(#i0,#i3),#i1),#i2)=#i4) };

 //reviewed 04/16/2004, St.S.
taclet eq_add_iff2            {find (~p(mul(#i0,#i1),#i2)=~p(mul(#i3,#i1),#i4)) 
                           replacewith (#i2=~p(mul(~d(#i3,#i0),#i1),#i4)) };

 //reviewed 04/16/2004, St.S.
taclet less_add_iff1          {find (lt(~p(mul(#i0,#i1),#i2),~p(mul(#i3,#i1),#i4))) 
                           replacewith (lt(~p(mul(~d(#i0,#i3),#i1),#i2),#i4)) };

 //reviewed 04/16/2004, St.S.
taclet less_add_iff2          {find (lt(~p(mul(#i0,#i1),#i2),~p(mul(#i3,#i1),#i4)))
                           replacewith (lt(#i2,~p(mul(~d(#i3,#i0),#i1),#i4))) };

 //reviewed 04/16/2004, St.S.
taclet leq_add_iff1           {find (leq(~p(mul(#i0,#i1),#i2),~p(mul(#i3,#i1),#i4))) 
                           replacewith (leq(~p(mul(~d(#i0,#i3),#i1),#i2),#i4)) };

 //reviewed 04/16/2004, St.S.
taclet leq_add_iff2           {find (leq(~p(mul(#i0,#i1),#i2),~p(mul(#i3,#i1),#i4)))
                           replacewith (leq(#i2,~p(mul(~d(#i3,#i0),#i1),#i4))) };

 //reviewed 04/16/2004, St.S.
taclet leq_diff1_eq           {find (leq(#i0,~d(#i1,1))) 
                           replacewith (lt(#i0,#i1)) };

 //reviewed 04/16/2004, St.S.
taclet le1_add1_eq_le         {find (lt(#i0,~p(#i1,1))) 
                           replacewith (leq(#i0,#i1)) };

 //reviewed 04/16/2004, St.S.
taclet zadd_left_cancel0      {find (#i0=~p(#i0,#i1)) replacewith (#i1=0) };

 //reviewed 04/16/2004, St.S.
taclet int_diff_minus_eq      {find (~d(#i0,~m(#i1))) replacewith (~p(#i0,#i1)) };

 //reviewed 04/16/2004, St.S.
taclet mult_pos               {find (lt(0,#i0) & lt(0,#i1)) 
                           replacewith (lt(0,mul(#i0,#i1))) };

 //reviewed 04/16/2004, St.S.
taclet mult_neg               {find (lt(#i0,0) & lt(#i1,0)) 
                           replacewith (lt(0,mul(#i0,#i1))) };

 //reviewed 04/16/2004, St.S.
taclet mult_pos_neg           {find (lt(#i0,0) & lt(0,#i1)) 
                           replacewith (lt(mul(#i0,#i1),0)) };

 //reviewed 04/16/2004, St.S.
taclet 0_less_mult_iff        {find (lt(0, mul(#i0,#i1))) 
                           replacewith (lt(0,#i0) & lt(0,#i1) | lt(#i0,0) & lt(#i1,0)) 
                           };

 //reviewed 04/16/2004, St.S.  
taclet 0_leq_mult_iff         {find (leq(0,mul(#i0,#i1))) 
                           replacewith (leq(0,#i0) & leq(0,#i1) | leq(#i0,0) & leq(#i1,0)) 
                           };

 //reviewed 04/16/2004, St.S.
taclet mult_less_0_iff        {find (lt(mul(#i0,#i1),0)) 
                           replacewith (lt(#i0,0) & lt(0,#i1) | lt(0,#i0) & lt(#i1,0)) 
                           };

 //reviewed 04/16/2004, St.S.
taclet mult_leq_0_iff         {find ( leq(mul(#i0,#i1),0) )
                           replacewith (leq(#i0,0) & leq(0,#i1) | leq(0,#i0) & leq(#i1,0)) 
                           };

  //reviewed 04/16/2004, St.S.
taclet square_nonneg          {find (leq(0,mul(#i0,#i0))) replacewith (true) };

  //reviewed 04/16/2004, St.S.
taclet mult_eq_self_iff       {find (#i0=mul(#i0,#i1)) replacewith (#i0=0 | #i1=1) 
                           };

  //reviewed 04/16/2004, St.S.
taclet less_1_mult            {find (lt(1,#i0) & lt(1,#i1)) 
                           replacewith (lt(1,mul(#i0,#i1))) };

  //reviewed 04/16/2004, St.S.
taclet pos_mult_eq_1_iff      {find (lt(0,#i0) -> mul(#i0,#i1)=1 )
                           replacewith (#i0=1 & #i1=1) };

  //reviewed 04/16/2004, St.S.
taclet mult_eq_1_iff          {find (mul(#i0,#i1)=1) 
                           replacewith (#i0=1 & #i1=1| #i0=z(neg(1(#))) & #i1=z(neg(1(#))))
                           };

  //reviewed 04/16/2004, St.S.
taclet multiply_distribute_1    {find (mul(~p(#i0,#i1),~p(#j0,#j1))) replacewith 
                           (~p( ~p(mul(#i0,#j0),mul(#i0,#j1)), ~p(mul(#i1,#j0),mul(#i1,#j1)) ))                            
                            displayname "multiply_distribute"};                           

 //reviewed 04/16/2004, St.S.
taclet multiply_distribute_2    {find (mul(~p(#i0,#i1),~d(#j0,#j1))) replacewith 
                           (~p( ~d(mul(#i0,#j0),mul(#i0,#j1)), ~d(mul(#i1,#j0),mul(#i1,#j1)) ))                            
                            displayname "multiply_distribute"};

 //reviewed 04/16/2004, St.S.
taclet multiply_distribute_3    {find (mul(~d(#i0,#i1),~d(#j0,#j1))) replacewith 
                           (~p( ~d(mul(#i0,#j0),mul(#i0,#j1)), ~d(mul(#i1,#j1),mul(#i1,#j0)) ))                            
                            displayname "multiply_distribute"};                           

 //reviewed 04/16/2004, St.S.
taclet collect_same_terms_1          {find (~p(mul(#i,#j),mul(#i,#j))) 
                           replacewith (mul(2,mul(#i,#j)))                           
                           displayname "collect_same_terms"};                           

 //reviewed 04/16/2004, St.S.
taclet collect_same_terms_2          {find (~p(~p(mul(#i,#j),mul(#i0,#i1)),~p(mul(#i,#j),mul(#j0,#j1)))) 
                           replacewith (~p(mul(2,mul(#i,#j)),~p(mul(#i0,#i1),mul(#j0,#j1))))                           
                           displayname "collect_same_terms"};

 //reviewed 04/16/2004, St.S.
taclet collect_same_terms_3          {find (~p( ~p(~m(mul(#i,#j)),mul(#i0,#i1)), ~p(~m(mul(#i,#j)),mul(#j0,#j1)))) 
                           replacewith (~p(~m(mul(2,mul(#i,#j))), ~p(mul(#i0,#i1), mul(#j0,#j1))))                           
                           displayname "collect_same_terms"};

 //reviewed 04/16/2004, St.S.
taclet addition_associative   {find ( ~p(~p(#i0,#i1),~p(#j0,#j1)) ) 
                           replacewith ( ~p(~p(#j0,#i1),~p(#i0,#j1)) ) };

 //reviewed 04/16/2004, St.S.
taclet leq_add_one                {find (leq(#i0,#i1)) replacewith (leq(~p(#i0,1),~p(#i1,1)))
			   };

 //reviewed 04/16/2004, St.S.
taclet less_add_one               {find (lt(#i0,#i1)) replacewith (lt(~p(#i0,1),~p(#i1,1)))
			   };

 //reviewed 04/16/2004, St.S.
taclet geq_add_one                {find (geq(#i0,#i1)) replacewith (geq(~p(#i0,1),~p(#i1,1)))
			   };

 //reviewed 04/16/2004, St.S.
taclet greater_add_one            {find (gt(#i0,#i1)) replacewith (gt(~p(#i0,1),~p(#i1,1)))
			   };
 //reviewed 04/16/2004, St.S.
taclet equal_add_one              {find (#i0=#i1) replacewith (~p(#i0,1)=~p(#i1,1))
			   };

 //reviewed 04/16/2004, St.S.
taclet leq_add                {find (==> leq(#i0,#i1)) replacewith (==> ex int j2 ; leq(~p(#i0,j2),~p(#i1,j2)))
			   };

 //reviewed 04/16/2004, St.S.
taclet less_add               {find (==> lt(#i0,#i1)) replacewith (==> ex int j2 ; lt(~p(#i0,j2),~p(#i1,j2)))
			   };

 //reviewed 04/16/2004, St.S.
taclet geq_add                {find (==> geq(#i0,#i1)) replacewith (==> ex int j2 ; geq(~p(#i0,j2),~p(#i1,j2)))
			   };

 //reviewed 04/16/2004, St.S.
taclet greater_add            {find (==> gt(#i0,#i1)) replacewith (==> ex int j2 ; gt(~p(#i0,j2),~p(#i1,j2)))
			   };

 //reviewed 04/16/2004, St.S.
taclet equal_add              {find (==> #i0=#i1) replacewith (==> ex int j2 ; ~p(#i0,j2)=~p(#i1,j2))
			   };

 //reviewed 04/16/2004, St.S.  
taclet leq_diff_1             { find (leq(#i0,~p(#i0,1))) replacewith (TRUE)
			   rule sets (int_arithmetic)};

 //reviewed 04/16/2004, St.S.  
taclet lt_diff_1              { find (lt(#i0,~p(#i0,1))) replacewith (TRUE)
			   rule sets (int_arithmetic)};

 //reviewed 04/16/2004, St.S.  
taclet geq_diff_1             { find (geq(~p(#i0,1),#i0)) replacewith (TRUE)
			   rule sets (int_arithmetic)};

 //reviewed 04/16/2004, St.S.  
taclet gt_diff_1              { find (gt(~p(#i0,1),#i0)) replacewith (TRUE)
			   rule sets (int_arithmetic)};

 //reviewed 04/16/2004, St.S.  
taclet i_minus_i_is_zero { find (~d(#i,#i)) replacewith (0) rule sets(simplify_int) };

 //reviewed 04/16/2004, St.S.  
taclet add_two_inequations_1 {if (lt(#i,#i0)==>) find (lt(#j,#j0)==>) add (lt(~p(#i,#j),~p(#i0,#j0))==>)};
 //reviewed 04/16/2004, St.S.  
taclet add_two_inequations_2 {if (leq(#i,#i0)==>) find (leq(#j,#j0)==>) add (leq(~p(#i,#j),~p(#i0,#j0))==>)};


 //reviewed 04/16/2004, St.S.  
taclet relax_inequation_1 {find (lt(#i,#i0)==>)  add (lt(#j,#i0)==>); add (lt(#i,#j)==>) displayname "relax_inequation"};
 //reviewed 04/16/2004, St.S.  
taclet relax_inequation_2 {find (leq(#i,#i0)==>)  add (leq(#j,#i0)==>); add (leq(#i,#j)==>) displayname "relax_inequation"};
 //reviewed 04/16/2004, St.S.  
taclet relax_inequation_3 {find (==>lt(#i,#i0))  add (==>lt(#j,#i0) & lt(#i,#j)) displayname "relax_inequation"};
 //reviewed 04/16/2004, St.S.  
taclet relax_inequation_4 {find (==>leq(#i,#i0))  add (==>leq(#j,#i0) & leq(#i,#j)) displayname "relax_inequation"};

 //reviewed 04/16/2004, St.S.  
taclet relax_inequation_5 {find (gt(#i,#i0)==>)  add (gt(#j,#i0)==>); add (gt(#i,#j)==>) displayname "relax_inequation"};
 //reviewed 04/16/2004, St.S.  
taclet relax_inequation_6 {find (geq(#i,#i0)==>)  add (geq(#j,#i0)==>); add (leq(#i,#j)==>) displayname "relax_inequation"};
 //reviewed 04/16/2004, St.S.  
taclet relax_inequation_7 {find (==>gt(#i,#i0))  add (==>gt(#j,#i0) & lt(#i,#j)) displayname "relax_inequation"};
 //reviewed 04/16/2004, St.S.  
taclet relax_inequation_8 {find (==>geq(#i,#i0))  add (==>geq(#j,#i0) & leq(#i,#j)) displayname "relax_inequation"};


 //reviewed 04/16/2004, St.S.  
taclet partition_inequation {if (==>lt(#i,#i0)) find (lt(#i,#i1)==>) add (==>lt(#i1, #i0)) };

  //reviewed 04/16/2004, St.S.  
taclet eq_sides { find (#i=#j) replacewith ( ~d(#i,#j)=0 ) };

  //reviewed 04/15/2004, St.S.
taclet mod_fold_minus { find (~d(mod(#i0,#i),mod(#i1,#i))) replacewith (mod(~d(#i0,#i1),#i)) };
  //reviewed 04/15/2004, St.S.
taclet mod_fold_plus  { find ( ~p(mod(#i0,#i),mod(#i1,#i))) replacewith (mod( ~p(#i0,#i1),#i)) };
  //reviewed 04/15/2004, St.S.
taclet times2mod_left  {find (mul(#i1,#i0)=#i) replacewith (mod(#i,#i1)=0)};
  //reviewed 04/15/2004, St.S.
taclet times2mod_right {find (mul(#i1,#i0)=#i) replacewith (mod(#i,#i0)=0)};


  //reviewed 04/15/2004, St.S.
taclet times_one {find (mul(#i,1)) replacewith (#i) rule sets (simplify_int)};
  //reviewed 04/15/2004, St.S.
taclet times_minus_one {find (mul(#i,~m(1))) replacewith (~m(#i)) rule sets (simplify_int)};
  //reviewed 04/15/2004, St.S.
taclet times_zero {find (mul(#i,0)) replacewith (0) rule sets (simplify_int)};


  //reviewed 04/15/2004, St.S.
taclet leq_to_gt { find (leq(#i,#j)) replacewith(!gt(#i,#j)) 
              rule sets (simplify_int)};

  //reviewed 04/15/2004, St.S.
taclet geq_to_lt { find (geq(#i,#j)) replacewith(!lt(#i,#j)) 
              rule sets (simplify_int)};

  //reviewed 04/15/2004, St.S.
taclet leq_to_gt_alt {find (leq(#i,#j)) replacewith(lt(#i,#j) | #i=#j) };

  //reviewed 04/15/2004, St.S.
taclet geq_to_lt_alt {find (geq(#i,#j)) replacewith(gt(#i,#j) | #i=#j) };


  //reviewed 04/15/2004, St.S.
taclet mod_rewr { find ( mod(#i,#i0) = 0 ) 
             varcond (#k not free in #i, #k not free in #i0) 
             replacewith ( ex #k;(mul(#k, #i0)=#i) ) };

  //reviewed 04/15/2004, St.S.
taclet mul_assoc { find(mul(mul(#i, #i0), #i1)) replacewith(mul(#i, mul(#i0, #i1))) 
              rule sets(simplify_int) };
  //reviewed 04/15/2004, St.S.
taclet mul_comm  { find(mul(#i0, #i1)) replacewith(mul(#i1, #i0)) };

  //reviewed 04/15/2004, St.S.
taclet div_same  { if(!#i0 = 0 ==>) find(div(#i0, #i0)) replacewith(1) 
	rule sets(simplify_int) sameUpdateLevel };

  //reviewed 04/15/2004, St.S.
taclet division_by_1  { 
	find (div(#i0,1)) replacewith (#i0) rule sets(simplify_int)};

  //reviewed 04/15/2004, St.S.
taclet division_by_minus_1  { 
	find (div(#i0,~m(1))) replacewith (~m(#i0)) 	rule sets(simplify_int) };

  //reviewed 04/15/2004, St.S.
taclet mod_same  { if(!#i0 = 0 ==>) find(mod(#i0, #i0)) replacewith(0) 
	rule sets(simplify_int) sameUpdateLevel };

  //reviewed 04/15/2004, St.S.
taclet succ_pred { find (pred(succ(#i))) replacewith (#i) rule sets (simplify_int) };
  //reviewed 04/15/2004, St.S.
taclet pred_succ { find (succ(pred(#i))) replacewith (#i) rule sets (simplify_int) };

  //reviewed 04/15/2004, St.S.
taclet succ_eq_step { find (succ(#i) = succ(#i0)) replacewith (#i = #i0) rule sets (simplify_int) };
  //reviewed 04/15/2004, St.S.
taclet pred_eq_step { find (pred(#i) = pred(#i0)) replacewith (#i = #i0) rule sets (simplify_int) };

  //reviewed 04/15/2004, St.S.
taclet succ_not_eq_1 { find(succ(#i) = #i) replacewith (FALSE) rule sets (simplify_int) };
  //reviewed 04/15/2004, St.S.
taclet succ_not_eq_2 { find(succ(succ(#i)) = #i) replacewith (FALSE) rule sets (simplify_int) };
  //reviewed 04/15/2004, St.S.
taclet pred_not_eq_1 { find(pred(#i) = #i) replacewith (FALSE) rule sets (simplify_int) };
  //reviewed 04/15/2004, St.S.
taclet pred_not_eq_2 { find(pred(pred(#i)) = #i) replacewith (FALSE) rule sets (simplify_int) };

  //reviewed 04/15/2004, St.S.
taclet greater { find(gt(#i, #i0)) replacewith (lt(#i0, #i)) rule sets (simplify_int) };

 
  //reviewed 04/15/2004, St.S.
taclet less_is_total_heu { if (==> lt(#i, #i0), (#i = #i0), lt(#i0, #i)) close goal rule sets(simplify_int) noninteractive};
  //reviewed 04/15/2004, St.S.
taclet less_is_total { find (#i) add (lt(#i, #i0) ==>); add ((#i = #i0) ==>); add (lt(#i0, #i) ==>) };
  //reviewed 04/15/2004, St.S.
taclet less_zero_is_total { find (#i) add (lt(#i, 0) ==>); add (#i = 0 ==>); add (lt(0, #i) ==>) };

  //reviewed 04/15/2004, St.S.
taclet less_is_alternative_1 { if (lt(#i, #i0), lt(#i0, #i) ==>) close goal rule sets(simplify_int) noninteractive };
  //reviewed 04/15/2004, St.S.
taclet less_is_alternative_2 { if (==> lt(#i, #i0)) find (==> lt(#i0, #i)) add ((#i = #i0) ==>) 
                         rule sets(simplify_int) noninteractive };

  //reviewed 04/15/2004, St.S.
taclet less_trans{ if(lt(#i, #i0) ==>) find(lt(#i0, #i1) ==>) add (lt(#i, #i1) ==>) rule sets(simplify_int)};
  //reviewed 04/15/2004, St.S.
taclet leq_trans{ if(leq(#i, #i0) ==>) find(leq(#i0, #i1) ==>) add (leq(#i, #i1) ==>) rule sets(simplify_int)};
  //reviewed 04/15/2004, St.S.
taclet less_neg { find (lt(#i, #i0)) replacewith (!(lt(#i0, succ(#i)))) };

  //reviewed 04/15/2004, St.S.
taclet less_base { find (lt(#i, #i)) replacewith (FALSE) rule sets(simplify_int) };
  //reviewed 04/15/2004, St.S.
taclet less_succ_step_1 { find (lt(#i, #i0)) replacewith ((succ(#i) = #i0) | lt(succ(#i), #i0)) };
  //reviewed 04/15/2004, St.S.
taclet less_succ_step_2 { find (lt(#i, #i0) ==>) add (lt(#i, succ(#i0)) ==>) };
  //reviewed 04/15/2004, St.S.
taclet less_succ_step_3 { find (==> lt(#i, #i0)) add (==> lt(succ(#i), #i0)) };
  //reviewed 04/15/2004, St.S.
taclet less_pred_step_1 { find (lt(#i, #i0)) replacewith ((#i = pred(#i0)) | lt(#i, pred(#i0))) };
  //reviewed 04/15/2004, St.S.
taclet less_pred_step_2 { find (lt(#i, #i0) ==>) add (lt(pred(#i), #i0) ==>) };
  //reviewed 04/15/2004, St.S.
taclet less_pred_step_3 { find (==> lt(#i, #i0)) add (==> lt(#i, pred(#i0))) };

  //reviewed 04/15/2004, St.S.
taclet less_succ_true  { find (lt(#i, succ(#i))) replacewith (TRUE) rule sets(simplify_int) };
  //reviewed 04/15/2004, St.S.
taclet less_pred_true  { find (lt(pred(#i), #i)) replacewith (TRUE) rule sets(simplify_int) };
  //reviewed 04/15/2004, St.S.
taclet less_succ_false { find (lt(succ(#i), #i)) replacewith (FALSE) rule sets(simplify_int) };
  //reviewed 04/15/2004, St.S.
taclet less_pred_false { find (lt(#i, pred(#i))) replacewith (FALSE) rule sets(simplify_int) };

  //reviewed 04/15/2004, St.S.
taclet add_zero_left  { find (~p(0, #i)) replacewith (#i) rule sets (simplify_int) };
  //reviewed 04/15/2004, St.S.
taclet add_zero_right { find (~p(#i, 0)) replacewith (#i) rule sets (simplify_int) };
  //reviewed 04/15/2004, St.S.
taclet add_succ_step_left  { find (~p(succ(#i), #i0)) replacewith (succ(~p(#i, #i0))) rule sets (simplify_int) };
  //reviewed 04/15/2004, St.S.
taclet add_succ_step_right { find (~p(#i, succ(#i0))) replacewith (succ(~p(#i, #i0))) rule sets (simplify_int) };
  //reviewed 04/15/2004, St.S.
taclet add_pred_step_left  { find (~p(pred(#i), #i0)) replacewith (pred(~p(#i, #i0))) rule sets (simplify_int) };
  //reviewed 04/15/2004, St.S.
taclet add_pred_step_right { find (~p(#i, pred(#i0))) replacewith (pred(~p(#i, #i0))) rule sets (simplify_int) };

  //reviewed 04/15/2004, St.S.
taclet switch_brackets { find(~p(~p(#i, #i0), #i1)) replacewith(~p(#i, ~p(#i0, #i1))) rule sets(simplify_int) };
  //reviewed 04/15/2004, St.S.
taclet switch_params { find(~p(#i0, #i1)) replacewith(~p(#i1, #i0)) };
  //reviewed 04/15/2004, St.S.
taclet rotate_params { find(~p(#i, ~p(#i0, #i1))) replacewith(~p(#i0, ~p(#i, #i1))) };
  //reviewed 04/15/2004, St.S.
taclet add_eq { find(#i0 = #i1) replacewith(~p(#i, #i0) = ~p(#i, #i1)) };
  //reviewed 04/15/2004, St.S.
taclet add_eq_back { find(~p(#i1, #i) = ~p(#i1, #i0)) replacewith(#i = #i0) };

  //reviewed 04/15/2004, St.S.
taclet add_less { find(lt(#i, #i0)) replacewith(lt(~p(#i1, #i), ~p(#i1, #i0))) };
  //reviewed 04/15/2004, St.S.
taclet add_less_back { find(lt(~p(#i1, #i), ~p(#i1, #i0))) replacewith(lt(#i, #i0)) };
  //reviewed 04/15/2004, St.S.
taclet add_less_back_zero_1 { find(lt(#i,~p(#i,#i1))) replacewith(lt(0,#i1)) displayname "add_less_back"};
  //reviewed 04/15/2004, St.S.
taclet add_less_back_zero_2 { find(lt(~p(#i,#i1),#i)) replacewith(lt(#i1,0)) displayname "add_less_back"};

  //reviewed 04/15/2004, St.S.
taclet sub { find (~d(#i, #i0)) replacewith (~p(#i, ~m(#i0)))rule sets(simplify_int) };
  //reviewed 04/15/2004, St.S.
taclet sub_succ { find (~m(succ(#i))) replacewith (pred(~m(#i))) rule sets(simplify_int) };
  //reviewed 04/15/2004, St.S.
taclet sub_pred { find (~m(pred(#i))) replacewith (succ(~m(#i))) rule sets(simplify_int) };
  //reviewed 04/15/2004, St.S.
taclet sub_zero_1 { find (z(neg(0(#)))) replacewith (z(0(#))) rule sets(simplify_int) };
  //reviewed 04/15/2004, St.S.
taclet sub_zero_2 { find (~d(#i,0)) replacewith (#i) rule sets(simplify_int) };
  //reviewed 04/15/2004, St.S.
taclet add_sub_elim_left  { find (~p(~m(#i), #i)) replacewith (0) rule sets(simplify_int) };
  //reviewed 04/15/2004, St.S.
taclet add_sub_elim_right { find (~p(#i, ~m(#i))) replacewith (0) rule sets(simplify_int) };
  //reviewed 04/15/2004, St.S.
taclet add_sub_step { find (~p(~m(#i), ~m(#i0))) replacewith (~m(~p(#i, #i0))) };
  //reviewed 04/15/2004, St.S.
taclet sub_sub_elim { find (~m(~m(#i))) replacewith (#i) rule sets(simplify_int) };
  //reviewed 04/15/2004, St.S.
taclet less_sub { find (lt(#i, #i0)) replacewith (lt(~m(#i0), ~m(#i))) };

  //reviewed 04/15/2004, St.S.
taclet less_plus { find (lt(0, ~p(#i0, #i1))) replacewith(lt(~m(#i0),#i1)) };

  //reviewed 04/15/2004, St.S.
taclet close_by_lt_leq { if (lt (#i,#j) ==>) 
           find (==> leq(~p(#i,1), #j) )
           replacewith (==> TRUE) };

  //reviewed 04/15/2004, St.S.
taclet lt_to_leq_1 {find (lt(#i,#j)|#i=#j) replacewith (leq(#i,#j))};

  //reviewed 04/15/2004, St.S.
taclet lt_to_leq_2 {if (==> lt(#i,#j)) 
              find (==> #i=#j) 
              replacewith (==> leq(#i,#j))};

  //reviewed 04/15/2004, St.S.
taclet lt_to_gt {find (lt(#i,#i0)) replacewith (gt(#i0,#i))};
  //reviewed 04/15/2004, St.S.
taclet gt_to_lt {find (gt(#i,#i0)) replacewith (lt(#i0,#i))};
  //reviewed 04/15/2004, St.S.
taclet leq_to_geq {find (leq(#i,#i0)) replacewith (geq(#i0,#i))};
  //reviewed 04/15/2004, St.S.
taclet geq_to_leq {find (geq(#i,#i0)) replacewith (leq(#i0,#i))};


  //reviewed 04/15/2004, St.S.
taclet succ_to_plusone { find (succ(#i)) replacewith(~p(#i,1)) rule sets (simplify_int)};
  //reviewed 04/15/2004, St.S.
taclet pred_to_minusone { find (pred(#i)) replacewith(~d(#i,1)) rule sets (simplify_int)};

  //reviewed 04/15/2004, St.S.
taclet neg_to_literal{ find (~m(z(#iz))) replacewith (z(neg(#iz))) rule sets (simplify_int)};


// ------------------------------
// ------- modulo taclets ---------
// ------------------------------

  //reviewed 04/15/2004, St.S.
taclet mod_not_necessary {
	find (mod(#i0,#i))
	replacewith (#i0);
	add (==> lt(#i0,#i) & leq(0,#i0)) 
	sameUpdateLevel
  };

  //reviewed 04/15/2004, St.S.
taclet mod_lt_mod {
	find (mod(mod(#i0,#i),#j))
	replacewith (mod(#i0,#i)) ;
        add  (==> leq(#i,#j) & lt(0,#i)) 
	sameUpdateLevel
  };

  //reviewed 04/15/2004, St.S.
taclet mod_gt_mod_and_multiple {
	find (mod(mod(#i0,#i),#j))
	replacewith (mod(#i0,#j)) ;
        add  (==> (mod(#i,#j)=0) & lt(0,#i)) 
	sameUpdateLevel
  };

  //reviewed 04/15/2004, St.S.
taclet mod_mod_eq {
	find (mod(mod(#i0,#i1),#i1)) 
	replacewith (mod(#i0,#i1))
	rule sets(simplify_int)
  };
 
  //reviewed 04/15/2004, St.S.
taclet mod_plus {find ( lt(~p(mod(#i,#j),#i0), #j)) 
            replacewith (~p(mod(#i,#j),#i0) = mod(~p(#i,#i0), #j)) };

  //reviewed 04/15/2004, St.S.
taclet mod_sum_1 {
	find (mod(~p(mod(#i0,#j), mod(#i1,#j)), #j))
	replacewith(mod(~p(#i0,#i1), #j))
	displayname "mod_sum_reduce"
  };

  //reviewed 04/15/2004, St.S.
taclet mod_sum_2 {
	find (mod(~p(#i0,#i1), #j))
	replacewith(mod(~p(mod(#i0,#j), mod(#i1,#j)), #j))
	displayname "mod_sum_expand"
  };

  //reviewed 04/15/2004, St.S.
taclet mod_sum_3 {
	find (mod(~p(mod(#i0,#j), mod(#i1,#j)), #j))
	replacewith(mod(~p(#i0, mod(#i1,#j)), #j))
	displayname "mod_sum_reduce_left"
  };

  //reviewed 04/15/2004, St.S.
taclet mod_sum_4 {
	find (mod(~p(mod(#i0,#j), mod(#i1,#j)), #j))
	replacewith(mod(~p(mod(#i0,#j), #i1), #j))
	displayname "mod_sum_reduce_right"
  };

  //reviewed 04/15/2004, St.S.
taclet mod_sum_5 {
	find (mod(~p(mod(#i0,#j), #i1), #j))
	replacewith(mod(~p(#i0, #i1), #j))
	displayname "mod_sum_reduce_left"
  };

  //reviewed 04/15/2004, St.S.
taclet mod_sum_6 {
	find (mod(~p(#i0, mod(#i1,#j)), #j))
	replacewith(mod(~p(#i0, #i1), #j))
	displayname "mod_sum_reduce_right"
  };
	
  //reviewed 04/15/2004, St.S.
taclet mod_negative_1 {
	find (mod(#i0, ~m(#i1)))
	replacewith(~m(mod(~m(#i0), #i1)))
	displayname "mod_negative_right"
  };
  
  //reviewed 04/15/2004, St.S.
taclet mod_negative_3 {
	find (mod(~m(#i0), ~m(#i1)))
	replacewith(~m(mod(#i0, #i1)))
	displayname "mod_negative_both"
  };

  //reviewed 04/15/2004, St.S.
taclet mod_one {
	find (mod(#i0,1))
	replacewith(0)
  };

  //reviewed 04/15/2004, St.S.
taclet mod_minus_one {
	find (mod(#i0,~m(1)))
	replacewith(0)
  };


// -------------------------------------------------------
// ------------- Taclets for integer literals --------------
// -------------------------------------------------------
/*
  //reviewed 04/20/2004, St.S.
taclet double_unary_minus_literal { find (z(neg(neg(#iz)))) 
	  replacewith (z(#iz)) 
	  displayname "double_unary_minus"};


 //reviewed 04/16/2004, St.S.  
//taclet charLiteral_to_int {find (C(#iz)) replacewith (z(#iz)) rule sets (charLiteral_to_intLiteral)};

 //reviewed 04/15/2004, St.S.
taclet add_literals {find (~p(z(#iz),z(#jz)))        
    replacewith (#add(z(#iz),z(#jz)))
    rule sets (simplify_literals)};

 //reviewed 04/15/2004, St.S.
taclet sub_literals {find (~d(z(#iz),z(#jz)))   
    replacewith (#sub(z(#iz),z(#jz))) 
    rule sets (simplify_literals)};

 //reviewed 04/15/2004, St.S.
taclet mul_literals {find (mul(z(#iz),z(#jz))) 
    replacewith (#mul(z(#iz),z(#jz))) 
    rule sets (simplify_literals)};

 //reviewed 04/15/2004, St.S.
taclet div_literals {find (div(z(#iz),z(#jz)))     
    replacewith (#div(z(#iz),z(#jz))) 
    rule sets (simplify_literals)};

 //reviewed 04/15/2004, St.S.
taclet mod_literals {find (mod(z(#iz),z(#jz)))   
    replacewith (#mod(z(#iz),z(#jz)))
    rule sets (simplify_literals)};

 //reviewed 04/15/2004, St.S.
taclet less_literals {find (lt(z(#iz),z(#jz)))   
    replacewith (#less(z(#iz),z(#jz))) 
    rule sets (simplify_literals)};

 //reviewed 04/15/2004, St.S.
taclet greater_literals {find (gt(z(#iz),z(#jz)))   
    replacewith (#greater(z(#iz),z(#jz))) 
    rule sets (simplify_literals)};

 //reviewed 04/15/2004, St.S.
taclet leq_literals {find (leq(z(#iz),z(#jz)))   
    replacewith (#leq(z(#iz),z(#jz))) 
    rule sets (simplify_literals)};

 //reviewed 04/15/2004, St.S.
taclet qeq_literals {find (geq(z(#iz),z(#jz)))   
    replacewith (#geq(z(#iz),z(#jz))) 
    rule sets (simplify_literals)};

 //reviewed 04/15/2004, St.S.
taclet equal_literals {find (z(#iz)=z(#jz))  
    replacewith (#eq(z(#iz),z(#jz)))
    rule sets (simplify_literals)};

 //reviewed 04/15/2004, St.S.
taclet neg_literal { find (~m(z(#iz))) 
    replacewith (z(neg(#iz))) 
    rule sets (simplify_literals)};
*/


// -------------------------------------------------------
// ------------- integer induction taclets    --------------
// -------------------------------------------------------


  //reviewed 04/15/2004, St.S.
taclet int_induction { "Base Case": add ( ==> {#nv 0}(#phi) );
                       "Step Case": add ( ==> all #nv ; ((geq(#nv,0) & #phi)->{#nv succ(#nv)}#phi) );
                       "Use Case":  add ( all #nv; (geq(#nv,0) -> #phi) ==>) };


/* taclet int_induction_with_less {
    varcond (int #v0 new)
taclet add (==> {#i (0(q))}(#phi));
taclet add (all #i (( lt(z(0(#)), #i) & lt(#i, #v0)) -> #phi), lt(z(0(#)), #v0) ==> {#i #v0}(#phi));
taclet add (all #i ((lt(#v0, #i) & lt(#i, z(0(#)))) -> #phi), lt(#v0, z(0(#))) ==> {#i #v0}(#phi));
    add (all #i #phi ==>)
   };
*/
