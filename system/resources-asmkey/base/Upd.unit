unit Upd

export *

import * from Base;
import * from Bool;
import * from Asm;

taclet upd_def {
        find (upd(:#R; #s, #t) ==>)
	replacewith (def(:#R;) ==>)
    };

taclet upd_skip_left {
        find (upd(:skip; #t, #s) ==>)
	cond (dynamic #t, staticargs #t, static #s)
        replacewith (FALSE ==>)
        rule sets (simplify_asm)
    };

taclet upd_skip_right {
        find (==> upd(:skip; #t, #s))
	cond (dynamic #t, staticargs #t, static #s)
        replacewith (==> FALSE)
        rule sets (simplify_asm)
    };
    
taclet upd_assign_id_left {
        find (upd(:#t2 := #s2; #t1, #s1) ==>)
        cond (op #t1 = #t2,
	         dynamic #t1, staticargs #t1, static #s1)
        replacewith (#OP_EQ_ARGS(#t1, #t2) & #s1 = #s2 ==>)
	rule sets(simplify_asm)
    };
    
taclet upd_assign_id_right {
        find (==> upd(:#t2 := #s2; #t1, #s1))
        cond (op #t1 = #t2,
	         dynamic #t1, staticargs #t1, static #s1)
        replacewith (==> #OP_EQ_ARGS(#t1, #t2) & #s1 = #s2)
	rule sets(simplify_asm)
    };
    
taclet upd_assign_diff_left {
        find (upd(:#t2 := #s2; #t1, #s1) ==>)
        cond (op #t1 != #t2,
	         dynamic #t1, staticargs #t1, static #s1)
        replacewith (FALSE ==>)
	rule sets(simplify_asm)
    };
    
taclet upd_assign_diff_right {
        find (==> upd(:#t2 := #s2; #t1, #s1))
        cond (op #t1 != #t2,
	         dynamic #t1, staticargs #t1, static #s1)
        replacewith (==> FALSE)
	rule sets(simplify_asm)
    };
    
taclet upd_par_left {
        find (upd(:#R par #S; #t, #s) ==>)
	cond (dynamic #t, staticargs #t, static #s)
        replacewith (def(:#R par #S;) & (upd(:#R; #t, #s) | upd(:#S; #t, #s)) ==>)
        rule sets(split_asm)
    };
    
taclet upd_par_right {
        find (==> upd(:#R par #S; #t, #s))
	cond (dynamic #t, staticargs #t, static #s)
        replacewith (==> def(:#R par #S;) & (upd(:#R; #t, #s) | upd(:#S; #t, #s)))
        rule sets(split_asm)
    };
    
taclet upd_branch_left {
        find (upd(:if #b then #R else #S end; #t, #s) ==>)
	cond (dynamic #t, staticargs #t, static #s)
        replacewith (#b = true,  upd(:#R; #t, #s) ==>);
	replacewith (#b = false,  upd(:#S; #t, #s) ==>)
        rule sets(split_asm_if)
    };
    
taclet upd_branch_right {
        find (==> upd(:if #b then #R else #S end; #t, #s))
	cond (dynamic #t, staticargs #t, static #s)
        replacewith (#b = true ==> upd(:#R; #t, #s));
	replacewith (#b = false ==> upd(:#S; #t, #s))
        rule sets(split_asm_if)
    };

taclet upd_let_left {
        find (upd(:let #x = #s in #R end; #t1, #s1) ==>)
	cond (dynamic #t1, staticargs #t1, static #s1, #sk new depending on #s,
                 #x not free in #t1, #x not free in #s, #x not free in #s1)
        replacewith (#sk = #s, upd(:{#x #sk} #R; #t1, #s1) ==>)
        rule sets(simplify_asm)
    };

taclet upd_let_right {
        find (==> upd(:let #x = #s in #R end; #t1, #s1))
	cond (dynamic #t1, staticargs #t1, static #s1, #sk new depending on #s,
                 #x not free in #t1, #x not free in #s, #x not free in #s1)
        replacewith (#sk = #s ==> upd(:{#x #sk} #R; #t1, #s1))
        rule sets(simplify_asm)
    };
    
taclet upd_all_left {
        find (upd(:forall #x with #b do #R end; #t, #s)==>)
        cond (#x not free in #t, #x not free in #s,
	         dynamic #t, staticargs #t, static #s)
        replacewith (def(:forall #x with #b do #R end;) &
	             ex #x; (#b = true & upd(:#R; #t, #s))==>)
    };

taclet upd_all_right {
        find ( upd(:forall #x with #b do #R end; #t, #s))
        cond (#x not free in #t, #x not free in #s,
	         dynamic #t, staticargs #t, static #s)
        replacewith ( def(:forall #x with #b do #R end;) &
	              ex #x; (#b = true & upd(:#R; #t, #s)))
    };

taclet upd_seq_left {
        find (upd(:#R seq #S; #t, #s) ==>)
	cond (dynamic #t, staticargs #t, static #s)
        replacewith ((upd(:#R; #t, #s) & [[#R]] inv(:#S; #t)) |
	                 (con(:#R;) & [[#R]] upd(:#S; #t, #s)) ==>)
    };

taclet upd_seq_right {
        find (==> upd(:#R seq #S; #t, #s))
	cond (dynamic #t, staticargs #t, static #s)
        replacewith (==> (upd(:#R; #t, #s) & [[#R]] inv(:#S; #t)) |
	                 (con(:#R;) & [[#R]] upd(:#S; #t, #s)))
    };
    
taclet upd_try_left {
        find (upd(:try #R else #S end; #t, #s) ==>)
	cond (dynamic #t, staticargs #t, static #s)
	replacewith ((con(:#R;) & upd(:#R; #t, #s)) | (def(:#R;) & ! con(:#R;) & upd(:#S; #t, #s))==>)
        rule sets (split_asm_try)
    };

taclet upd_try_right {
        find (==> upd(:try #R else #S end; #t, #s))
	cond (dynamic #t, staticargs #t, static #s)
	replacewith (==> (con(:#R;) & upd(:#R; #t, #s)) | (def(:#R;) & ! con(:#R;) & upd(:#S; #t, #s)))
        rule sets (split_asm_try)
    };
    
taclet upd_name_left {
	find (upd(:#rho; #t, #s)==>)
	cond (derived #rho, dynamic #t, staticargs #t, static #s)
	replacewith (upd(:@#META_DERIVED(#rho); #t, #s)==>)
	rule sets(simplify_asm_named)
    };

taclet upd_name_right {
	find (==> upd(:#rho; #t, #s))
	cond (derived #rho, dynamic #t, staticargs #t, static #s)
	replacewith (==> upd(:@#META_DERIVED(#rho); #t, #s))
	rule sets(simplify_asm_named)
    };
