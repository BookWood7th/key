/* done */

taclets {

    joinable_def {
        find (joinable(#R, #S))
        replacewith (#ASM_JOIN(#R, #S))
        heuristics(expand_joinable)
    };

    Con_def {
        find (Con(#R))
        replacewith (def(#R) & #ASM_JOIN(#R, #R))
    };

    Con_skip_left {
        find (Con(skip) ==>) 
	replacewith (true ==>)
        heuristics(simplify_asm)
    };
    
    Con_skip_right {
        find (==> Con(skip)) 
	replacewith (==> true)
        heuristics(simplify_asm)
    };
      
    Con_assign_left {
        find (Con(#t := #s) ==>)
	replacewith (true ==>)
        heuristics(simplify_asm)
    };
   
    Con_assign_right {
        find (==> Con(#t := #s))
	replacewith (==> true)
        heuristics(simplify_asm)
    };

    Con_par_left {
        find (Con(#R par #S) ==>)
	replacewith (Con(#R) & Con(#S) & joinable(#R, #S) ==>)
	heuristics(simplify_asm)
    };
    
    Con_par_right {
        find (==> Con(#R par #S))
	replacewith (==> Con(#R) & Con(#S) & joinable(#R, #S))
	heuristics(simplify_asm)
    };

    Con_branch_left {
        find (Con(if #phi then #R else #S end) ==>)
        replacewith (#SC_ELIMINATION(#phi), Con(#R) ==>);
	replacewith (! #SC_ELIMINATION(#phi), Con(#S) ==>)
        heuristics(split_asm_if)
    };

    Con_branch_right {
        find (==> Con(if #phi then #R else #S end))
        replacewith (#SC_ELIMINATION(#phi) ==> Con(#R));
	replacewith (! #SC_ELIMINATION(#phi) ==> Con(#S))
        heuristics(split_asm_if)
    };

    Con_branch_left_elseif {
        find (Con(elseif #phi then #R else #S end) ==>)
        replacewith (#SC_ELIMINATION(#phi), Con(#R) ==>);
	replacewith (! #SC_ELIMINATION(#phi), Con(#S) ==>)
        heuristics(split_asm_if)
	displayname "Con_branch_left"
    };

    Con_branch_right_elseif {
        find (==> Con(elseif #phi then #R else #S end))
        replacewith (#SC_ELIMINATION(#phi) ==> Con(#R));
	replacewith (! #SC_ELIMINATION(#phi) ==> Con(#S))
        heuristics(split_asm_if)
	displayname "Con_branch_right"
    };

    Con_let_left {
        find (Con(let #x = #s in #R end) ==>)
	cond(#x not free in #s, #sk new depending on #s)
        replacewith (#sk = #s, Con({#x #sk} #R) ==>)
    };

    Con_let_right {
        find (==> Con(let #x = #s in #R end))
	cond(#x not free in #s, #sk new depending on #s)
        replacewith (#sk = #s ==> Con({#x #sk} #R))
    };

    Con_all_left {
        find (Con(forall #x with #phi do #R end) ==>)
        cond (#y not free in #phi, #y not free in #R)
	replacewith (all #x. (#SC_ELIMINATION(#phi) -> Con(#R) & all #y. ({#x #y} #SC_ELIMINATION(#phi) -> joinable(#R, {#x #y} #R))) ==>)
    };

    Con_all_right {
        find (==> Con(forall #x with #phi do #R end))
        cond (#y not free in #phi, #y not free in #R)
	replacewith (==> all #x. (#SC_ELIMINATION(#phi) -> Con(#R) & all #y. ({#x #y} #SC_ELIMINATION(#phi) -> joinable(#R, {#x #y} #R))))
    };
    
    Con_seq_left {
        find (Con(#R seq #S) ==>)
        replacewith (Con(#R) & [#R] Con(#S) ==>)
        //heuristics(split_asm) 
    };
    
    Con_seq_right {
        find (==> Con(#R seq #S))
        replacewith (==> Con(#R) & [#R] Con(#S))
        //heuristics(split_asm) 
    };
    
    Con_try_left {
        find  (Con(try #R else #S end) ==>)
        replacewith (Con(#R) | (def(#R) & Con(#S)) ==>)
        //heuristics(split_asm_try)
    };
    
    Con_try_right {
        find  (==> Con(try #R else #S end))
        replacewith (==> Con(#R) | (def(#R) & Con(#S)))
        //heuristics(split_asm_try)
    };
    
    Con_name_left {
        find (Con(#rho)==>)
	cond (call #rho)
	replacewith (Con(@ASM_NAMED_RULE(#rho))==>)
	heuristics(simplify_asm_named)
    };
   
    Con_name_right {
        find (==> Con(#rho))
	cond (call #rho)
	replacewith (==> Con(@ASM_NAMED_RULE(#rho)))
	heuristics(simplify_asm_named)
    };
    
}
