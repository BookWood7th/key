//taclets for the predicate inv

// warning the predicate inv has a new definition
//
// inv(R, f(x)) <-> def(R) & all y . ! upd(f(x)<-y in R)


taclets {

    inv_def {
	find (inv(#R, #t))
	cond (dynamic #t, staticargs #t, #x not free in #t, #x not free in #R)
	replacewith (def(#R) & all #x. (! upd(#R, #t, #x)))
        heuristics(simplify_asm)
    };


  inv_skip_left {
    find(inv(skip, #t) ==>)
    cond (dynamic #t, staticargs #t)
    replacewith(true ==>)
  };

  inv_skip_right {
    find(==> inv(skip, #t))
    cond (dynamic #t, staticargs #t)
    replacewith(==> true)
  };

  inv_assign_id_left {
    find(inv(#t1 := #s1, #t) ==>)
    cond(op #t = #t1,dynamic #t, staticargs #t)
    replacewith(! (#OP_EQ_ARGS(#t, #t1)) ==>)
  };

  inv_assign_id_right {
    find(==> inv(#t1 := #s1, #t))
    cond(op #t = #t1,dynamic #t, staticargs #t)
    replacewith(==> ! (#OP_EQ_ARGS(#t, #t1)))
  };

  inv_assign_diff_left {
    find(inv(#t1 := #s1, #t) ==>)
    cond(op #t != #t1,dynamic #t, staticargs #t)
    replacewith(true ==>)
  };

  inv_assign_diff_right {
    find(==> inv(#t1 := #s1, #t))
    cond(op #t != #t1,dynamic #t, staticargs #t)
    replacewith(==> true)
  };

  inv_par_left {
    find(inv(#R par #S, #t) ==>)
    cond (dynamic #t, staticargs #t)
    replacewith(def(#R par #S) & inv(#R, #t) & inv(#S, #t) ==>)
  };

  inv_par_right {
    find(==> inv(#R par #S, #t))
    cond (dynamic #t, staticargs #t)
    replacewith(==> def(#R par #S) & inv(#R, #t) & inv(#S, #t))
  };

  inv_branch_left {
    find(inv(if #phi then #R else #S end, #t) ==>)
    cond (dynamic #t, staticargs #t)
    replacewith(#SC_ELIMINATION(#phi) ,  inv(#R, #t)==>);
    replacewith(!#SC_ELIMINATION(#phi) , inv(#S, #t)==>)
  };

  inv_branch_right {
    find(==> inv(if #phi then #R else #S end, #t))
    cond (dynamic #t, staticargs #t)
    replacewith(#SC_ELIMINATION(#phi) ==>  inv(#R, #t));
    replacewith(!#SC_ELIMINATION(#phi) ==> inv(#S, #t))
  };

  inv_branch_left_elseif {
    find(inv(elseif #phi then #R else #S end, #t) ==>)
    cond (dynamic #t, staticargs #t)
    replacewith(#SC_ELIMINATION(#phi) ,  inv(#R, #t)==>);
    replacewith(!#SC_ELIMINATION(#phi) , inv(#S, #t)==>)
    displayname "inv_branch_left"
  };

  inv_branch_right_elseif {
    find(==> inv(elseif #phi then #R else #S end, #t))
    cond (dynamic #t, staticargs #t)
    replacewith(#SC_ELIMINATION(#phi) ==>  inv(#R, #t));
    replacewith(!#SC_ELIMINATION(#phi) ==> inv(#S, #t))
    displayname "inv_branch_right"
  };

  inv_let_left {
    find (inv(let #x = #s in #R end, #t)==>)
    cond (dynamic #t, staticargs #t, #x not free in #t, #x not free in #s,
             #sk new depending on #s)
    replacewith (#sk = #s , inv({#x #sk} #R, #t)==>)
    heuristics(simplify_asm)
  };

  inv_let_right {
    find (==> inv(let #x = #s in #R end, #t))
    cond (dynamic #t, staticargs #t, #x not free in #t, #x not free in #s,
             #sk new depending on #s)
    replacewith (#sk = #s ==> inv({#x #sk} #R, #t))
    heuristics(simplify_asm)
  };

  inv_all_left {
    find(inv(forall #x with #phi do #R end, #t)==>)
    cond (dynamic #t, staticargs #t, #x not free in #t)
    replacewith(def(forall #x with #phi do #R end) & all #x . (#SC_ELIMINATION(#phi) -> inv(#R, #t))==>)
  };

  inv_all_right {
    find(==> inv(forall #x with #phi do #R end, #t))
    cond (dynamic #t, staticargs #t, #x not free in #t)
    replacewith(==> def(forall #x with #phi do #R end) & all #x . (#SC_ELIMINATION(#phi) -> inv(#R, #t)))
  };

  inv_seq_left {
    find(inv(#R seq #S, #t)==>)
    cond (dynamic #t, staticargs #t)
    replacewith(inv(#R, #t) & [#R] inv(#S, #t)==>)
  };

  inv_seq_right {
    find(==> inv(#R seq #S, #t))
    cond (dynamic #t, staticargs #t)
    replacewith(==> inv(#R, #t) & [#R] inv(#S, #t))
  };

  inv_try_left {
    find(inv(try #R else #S end, #t)==>)
    cond (dynamic #t, staticargs #t)
    replacewith ((Con(#R) & inv(#R, #t)) | (def(#R) & ! Con(#R) & inv(#S, #t))==>)
  };

  inv_try_right {
    find(==> inv(try #R else #S end, #t))
    cond (dynamic #t, staticargs #t)
    replacewith (==> (Con(#R) & inv(#R, #t)) | (def(#R) & ! Con(#R) & inv(#S, #t)))
  };

  inv_name_left {
    find (inv(#rho, #t))
    cond (call #rho, dynamic #t, staticargs #t)
    replacewith (inv(@ASM_NAMED_RULE(#rho), #t))
  };

  inv_name_right {
    find (inv(#rho, #t))
    cond (call #rho, dynamic #t, staticargs #t)
    replacewith (inv(@ASM_NAMED_RULE(#rho), #t))
  };

}
