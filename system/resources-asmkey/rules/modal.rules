/* done */

taclets {

    /** Modal taclets for asm taclets */

    asm_skip_left { 
        find ([skip] #phi ==>) 
        replacewith (#phi ==>) 
        heuristics(simplify_asm) 
    };

    asm_skip_right { 
        find (==> [skip] #phi) 
        replacewith (==> #phi) 
        heuristics(simplify_asm) 
    };
    
    branch_left { 
        find ([if #psi then #R else #S end] #phi ==>) 
        replacewith (#SC_ELIMINATION(#psi), [#R] #phi ==>);
        replacewith (! #SC_ELIMINATION(#psi), [#S] #phi ==>)
        heuristics(split_asm_if)
    };
    
    branch_right { 
        find (==> [if #psi then #R else #S end] #phi)
        replacewith (#SC_ELIMINATION(#psi) ==> [#R] #phi);
        replacewith (! #SC_ELIMINATION(#psi) ==> [#S] #phi)
        heuristics(split_asm_if)
    };

    branch_left_elseif { 
        find ([elseif #psi then #R else #S end] #phi ==>) 
        replacewith (#SC_ELIMINATION(#psi), [#R] #phi ==>);
        replacewith (! #SC_ELIMINATION(#psi), [#S] #phi ==>)
        heuristics(split_asm_if)
	displayname "branch_left"
    };
    
    branch_right_elseif { 
        find (==> [elseif #psi then #R else #S end] #phi)
        replacewith (#SC_ELIMINATION(#psi) ==> [#R] #phi);
        replacewith (! #SC_ELIMINATION(#psi) ==> [#S] #phi)
        heuristics(split_asm_if)
	displayname "branch_right"
    };
    
    seq_left {
        find ([#R seq #S] #phi ==>)
        replacewith ([#R] [#S] #phi ==>)
	heuristics (simplify_asm)
    };
    
    seq_right {
        find (==> [#R seq #S] #phi)
        replacewith (==> [#R] [#S] #phi)
	heuristics (simplify_asm)
    };
    
    let_left {
        find ([let #x = #s in #R end] #phi ==>)
        cond (#sk new depending on #s)
        replacewith (#sk = #s, [{#x #sk} #R] #phi ==>)
        heuristics (simplify_asm)
    };
    
    let_right {
        find (==> [let #x = #s in #R end] #phi)
        cond (#sk new depending on #s)
        replacewith (#sk = #s ==> [{#x #sk} #R] #phi)
        heuristics (simplify_asm)
    };
    
    try_left {
        find ([try #R else #S end] #phi ==>)
        replacewith (==> def(#R));
        replacewith (Con(#R) ==> [#R] #phi);
        replacewith (! Con(#R) ==> [#S] #phi)
        heuristics (split_asm_try)
    };
    
    try_right {
        find (==> [try #R else #S end] #phi)
        replacewith (==> [#R] #phi);
        replacewith (def(#R), ! Con(#R) ==> [#S] #phi)
        heuristics (split_asm_try)
    };
    
    name_left {
	find ([#rho] #phi ==>)
	cond (call #rho)
	replacewith ([@ASM_NAMED_RULE(#rho)] #phi ==>)
	heuristics (simplify_asm_named)
    };

    name_right {
	find (==> [#rho] #phi)
	cond (call #rho)
	replacewith (==> [@ASM_NAMED_RULE(#rho)] #phi)
	heuristics (simplify_asm_named)
    };


    /** Modal taclets for formulas */
    
    mod_not_left {
        find ([#R] ! #phi ==>)
        replacewith (==> Con(#R));
        replacewith (! [#R] #phi ==>)
    };
    
    mod_not_right {
        find (==> [#R] ! #phi)
        replacewith (==> ! [#R] #phi)
        heuristics(simplify)
    };
    
    mod_and_left {
        find ([#R] (#phi1 & #phi2)==>)
        replacewith (([#R] #phi1) & ([#R] #phi2)==>)
        heuristics(simplify)
    };
    
    mod_and_right {
        find (==> [#R] (#phi1 & #phi2))
        replacewith (==> ([#R] #phi1) & ([#R] #phi2))
        heuristics(simplify)
    };
    
    mod_or_left {
        find ([#R] (#phi1 | #phi2)==>)
        replacewith (([#R] #phi1) | ([#R] #phi2)==>)
        //heuristics(simplify)
    };

    mod_or_right {
        find (==> [#R] (#phi1 | #phi2))
        replacewith (==> ([#R] #phi1) | ([#R] #phi2))
        //heuristics(simplify)
    };

    mod_impl_left {
        find ([#R] (#phi1 -> #phi2) ==>)
        replacewith (([#R] #phi1) -> ([#R] #phi2) ==>)
        //heuristics(simplify)
    };

    mod_impl_right {
        find (==> [#R] (#phi1 -> #phi2))
        replacewith (==> ([#R] #phi1) -> ([#R] #phi2))
        //heuristics(simplify)
    };

    mod_all_left {
        find ([#R] all #x.#phi ==>)
        cond (#x not free in #R)
        replacewith (all #x.[#R] #phi ==>)
        heuristics(simplify)
    };

    mod_all_right {
        find (==> [#R] all #x.#phi)
        cond (#x not free in #R)
        replacewith (==> all #x.[#R] #phi)
        heuristics(simplify)
    };
    
    mod_ex_left {
        find ([#R] ex #x.#phi ==>)
        cond (#x not free in #R)
        replacewith (ex #x.[#R] #phi ==>)
        heuristics(simplify)
    };
    
    mod_ex_right {
        find (==> [#R] ex #x.#phi)
        cond (#x not free in #R)
        replacewith (==> ex #x.[#R] #phi)
        heuristics(simplify)
    };
    
    mod_eq_right {
        find (==> [#R] #t = #s)
	cond (dynamic #t, staticargs #t, static #s)
        replacewith (==> upd(#R, #t, #s) | (#t = #s & inv (#R, #t)))
    };
    
    mod_eq_left {
        find ([#R] #t = #s ==>)
	cond (dynamic #t, staticargs #t, static #s)
        replacewith (==> Con(#R));
        replacewith (upd(#R, #t, #s) | (inv(#R, #t) & #t = #s) ==>)
        heuristics(split_asm)
    };
}
