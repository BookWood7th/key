taclets {

    ex_not_con_ql {
        find (==> [#R] #phi)
    	replacewith (==> ! Con(#R))
    };
    
    static_left {
        find ([#R] #phi ==>)
    	cond (static #phi) // static implies pure
    	replacewith (==> Con(#R));
        replacewith (#phi ==>)
    };

    static_right {
        find (==> [#R] #phi)
  	cond (static #phi) // static implies pure
  	replacewith (==> #phi)
    };

    
    // XXX: #t dynamic
//    axiom_12 {
//        find (==> def(#R))
//    	replacewith (==> upd(#t <- #s in #R))
//    };
    
    // XXX: missing
    // axiom_15a
    
    // XXX: missing
    // axiom_15b

    bigand_left {
        find (bigand(#phi) ==>)
	replacewith(#ASM_BIGOPERATOR(#phi)==>)
    };

    bigand_right {
        find (==> bigand(#phi))
	replacewith(==> #ASM_BIGOPERATOR(#phi))
    };

    // XXX: test: diamond
    mod_diamond {
	find (==> <#R> #phi)
	replacewith (==> def(#R));
	replacewith (==> Con(#R));
	replacewith (==> [#R] #phi)
        heuristics(split_asm)
    };

    // XXX: test: ex
    //inst_ex  { 
	//if (==> ex #x. #phi) 
	//find (#t) 
	//cond (static #t)
	//add (==> {#x #t} #phi) 
    //};

    // XXX: test: all
    //inst_all  { 
	//if (all #x. #phi ==>) 
	//find (#t) 
	//cond (static #t)
	//add ({#x #t} #phi ==>) 
    //};


    // XXX: Zusaetzliche Regel fuer Gleichheit
    eq_sym_close {
        if (#s = #t ==>)
        find (==> #t = #s)
        close goal
        heuristics(simplify)
    };

    /* todo with gui !!!! */
    thin_left {
        find (#phi ==>)
        replacewith (==>)
    };
    
    thin_right {
        find (==> #phi)
        replacewith (==>)
    };
    
    upd_def{
        find (upd(#R, #s, #t) ==>)
	replacewith (def(#R) ==>)
    };

    leq_def {
        find (leq(#s,#t))
	cond(#x not free in #s, #x not free in #t)
	replacewith (ex #x . (geq(#x, 0) & +(#s,#x) = #t))
    };

    lt_def {
        find (lt(#s,#t))
	cond(#x not free in #s, #x not free in #t)
	replacewith (ex #x . (gt(#x, 0) & +(#s,#x) = #t))
    };

    equi_def {
        find (equi(#R, #S))
	replacewith (Con(#R) | Con(#S) 
                     -> Con(#R) & Con(#S) 
                      & #ASM_EQUI_IMP(#R, #S)
                      & #ASM_EQUI_IMP(#S, #R))
    };

    equiS_def {
        find (equiS(#R, #S))
	replacewith (def(#R) | def(#S) 
                     -> def(#R) & def(#S) & #ASM_EQUIS(#R, #S))
    };

    constant {
        find(#t)
	cond(#sk new depending on #t)
	add (#sk = #t ==>)
    };

    step_cut {
        find(#phi)
	add(==> [#R]#phi);
	add([#R]#phi ==>)
    };

}    
