// @(#)$Id: JMLSequenceEnumerator.java-generic 1.1 Mon, 02 May 2005 14:31:03 +0200 engelc $

// Copyright (C) 1998, 1999 Iowa State University

// This file is part of JML

// JML is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 2, or (at your option)
// any later version.

// JML is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// You should have received a copy of the GNU General Public License
// along with JML; see the file COPYING.  If not, write to
// the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.


package org.jmlspecs.models;

import java.util.Enumeration;

/** An enumerator for sequences of _ElemType_English_s.
 *
 * @version $Revision: 1.1 $
 * @author Gary T. Leavens, with help from Albert Baker, Clyde Ruby,
 * and others.
 * @see JMLEnumeration
 * @see JMLType
 * @see JMLObjectSequence
 * @see JMLValueSequence
 * @see JMLEnumerationToIterator
 */
//-@ immutable
public class JML_Elem_SequenceEnumerator
    implements JMLEnumeration, _SuperType_
{

    /** The elements that have not yet been returned by nextElement.
     */
    //@ public model JML_Elem_Sequence uniteratedElems; in objectState;
    //@ public invariant uniteratedElems != null;

    /** The list representing the elements yet to be returned.
     */
    protected JMLList_Elem_Node currentNode;
    //@                               in uniteratedElems;

    /** The number of elements remaining to return.
     */
    protected /*@ spec_public @*/ int remaining;
    //@                                  in uniteratedElems;

    /*@ protected represents uniteratedElems
      @                  <- new JML_Elem_Sequence(currentNode, remaining);
      @*/

    //@ public invariant moreElements <==> remaining != 0;
    //@ public invariant remaining >= 0;
    //@ protected invariant currentNode == null <==> remaining == 0;

    //@ public invariant elementType <: \type(_ElemType_);

    /*@ public invariant
      @       !uniteratedElems.isEmpty()
      @        ==> uniteratedElems.elementType <: elementType;
      @*/

    //@ public constraint returnsNull == \old(returnsNull);

    /*@ public invariant
      @       !returnsNull
      @         ==> uniteratedElems.isEmpty() || !uniteratedElems.containsNull;
      @*/

    /** Initialize this with the given sequence.
     */
    /*@ normal_behavior
      @   requires s != null;
      @   assignable uniteratedElems;
      @   assignable  moreElements, elementType, returnsNull, owner;
      @   ensures uniteratedElems.equals(s);
      @   ensures owner == null;
      @   ensures elementType == s.elementType;
      @   ensures returnsNull == s.containsNull;
      @*/
    JML_Elem_SequenceEnumerator(/*@ non_null @*/ JML_Elem_Sequence s) {
        //@ set owner = null;
        remaining = s.int_length();
        //@ set elementType = s.elementType;
        //@ set returnsNull = s.containsNull;
        currentNode = s.theSeq;
    }

    /** Tells whether this enumerator has more uniterated elements.
     */
    /*@ also
      @  public normal_behavior
      @    ensures \result == !uniteratedElems.isEmpty();
      @    ensures \result <==> remaining > 0;
      @*/
    public /*@ pure @*/ boolean hasMoreElements() {
        return currentNode != null;
    }

    /** Return the next element in the sequence, counting up, if there is one.
     *  @exception JMLNoSuchElementException when this is empty.
     */
    /*@ also
      @  public normal_behavior
      @    requires hasMoreElements();
      @    assignable uniteratedElems, moreElements;
      @    ensures \old(uniteratedElems).itemAt(0) _elem_equality_ (\result)
      @         && uniteratedElems.equals(\old(uniteratedElems).trailer());
      @ also
      @  public exceptional_behavior
      @    requires !hasMoreElements();
      @    assignable \nothing;
      @    signals (JMLNoSuchElementException);
      @ also
      @  protected normal_behavior 
      @    requires remaining > 0;
      @    assignable uniteratedElems, moreElements;
      @    assignable_redundantly currentNode, remaining;
      @    ensures currentNode == \old(currentNode.next)
      @         && remaining == \old(remaining - 1);
      @*/
    public Object nextElement() throws JMLNoSuchElementException {
        if (currentNode != null) {
            _ElemType_ retValue = currentNode.val;
            currentNode = currentNode.next;
            remaining = remaining - 1;
            //@ assume currentNode == null <==> remaining == 0;
            //@ assume !returnsNull ==> retValue != null;
            //@ assume retValue != null ==> \typeof(retValue) <: elementType;
            return retValue;
        } else {
            throw new JMLNoSuchElementException("Tried to .nextElement() "
                                                + "with JML_Elem_Sequence "
                                                + "Enumerator `off the end'");
        }
    }

    /** Return a clone of this enumerator.
     */
    public Object clone() {
        return
            new JML_Elem_SequenceEnumerator(new JML_Elem_Sequence(currentNode,
                                                                  remaining));
    } //@ nowarn Post;

    /** Return true just when this enumerator has the same state as
     * the given argument..
     */
    public boolean equals(Object oth) {
        if  (oth == null || !(oth instanceof JML_Elem_SequenceEnumerator)) {
            return false;
        } else {
            JML_Elem_SequenceEnumerator js
                = (JML_Elem_SequenceEnumerator) oth;
            if (currentNode == null) {
                return js.currentNode == null;
            } else {
                return currentNode.equals(js.currentNode);
            }
        }
    }

    /** Return a hash code for this enumerator.
     */
    public int hashCode() {
        return currentNode == null ? 0 : currentNode.hashCode();
    }
}
