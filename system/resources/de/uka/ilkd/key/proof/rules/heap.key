\sorts {
   Field;
   Heap;
   
   \generic GOS \extends Object;
   \generic G;
   \generic H;
}

\functions {
   //These function symbols interpret an element of sort Heap as a
   //two dimensional array, where the first index is of sort Object
   //and the second index of sort Field.
   any select(Heap, Object, Field);
   Heap store(Heap, Object, Field, any);

   //Dedicated heap symbol. Just a single program variable of sort Heap!
   //This symbol is used by the symbolic execution rules:
   //[o.f = e; ...]phi -->  {heap := store(heap, o, f, e)}[...]phi
   //(if we want it to look prettier, we can have the pretty printer render 
   // the update "heap := store(heap, o, f, e)" as "o.f := e")
   \nonRigid[Location] Heap heap;
   
   //for handling Java arrays
   \unique Field arr(int);
   
   //these would be automatically created on demand later, but we already need them here
   \unique Field java.lang.Object::<created>;
   \unique Field Array::length;
}


\predicates {
   //replacement for inReachableState
   wellFormed(Heap);
}
   


\schemaVariables {
   \term Heap h;
   \term Object o;
   \term Object o2;
   \term Field f;
   \term Field f2;
   \term G x;
   \term H y;
   \variables Object ov;
   \variables Field fv;
 }

\rules {
   //Axiom for the theory of arrays: storing x in an array at index (o,f) 
   //leads to an array where index (o,f) has the value x and everything else is 
   //unchanged.
   heapUpdate {
     \find(select(store(h,o,f,x), o2, f2))
     \replacewith(\if(o = o2 & f = f2)\then(x)\else(select(h,o2,f2)))
     \heuristics(simplify)
   };

   
   //Uniqueness axiom: 
   // - two unique constant symbols of type Field never denote the same value
   // - arr(i) is always different from any unique constant symbol of type Field
   // - arr(i) and arr(j) have the same value iff i and j have the same value
   fieldEquality {
     \find(f = f2)
     \varcond(\isUnique(f), \isUnique(f2))
     \replacewith(#sameField(f,f2))
     \heuristics(simplify)
   };
   
   
   
   //--------------------------------------------------------------------------
   //rules for wellFormed(Heap)
   //--------------------------------------------------------------------------
   
   //if o != null, if o.<created>, if o.f != null and if the heap is well-formed,
   //then we know that o.f.<created> 
   only_created_object_are_referenced_non_null_NEW {	          
         \assumes ((boolean) select(h, o, java.lang.Object::<created>) = TRUE, wellFormed(h) ==> o = null, (GOS) select(h, o, f) = null) 
         \find ( select(h, o, f) )	 
	 \sameUpdateLevel
         \add ( (boolean)select(h, (GOS) select(h, o, f), java.lang.Object::<created>) = TRUE ==>)
         \heuristics(inReachableStateImplication)         	 
         \displayname "referenced object is created"	 
   };
   
   
   wellFormedStore {
      \find(==> wellFormed(store(h,o,f,x)))  
      \replacewith(==> wellFormed(h)
                       & o != null 
                       & (boolean) select(h,o,java.lang.Object::<created>) = TRUE)
      \heuristics(inReachableStateImplication)
   };
   
   arrayLengthNonNegative {
       \assumes(wellFormed(h) ==> o = null)
       \find(select(h,o,Array::length)) 
       \sameUpdateLevel       
       \add((jint)select(h,o,Array::length) >= 0 ==>)
       \heuristics(inReachableStateImplication)
   };
   
   /*
   heapTyping {
   	\assumes(wellFormed(h) ==> o = null)
   	\find(select(h,o,f))
   	\sameUpdateLevel   	
   	\varcond(\isUnique(f))
   	\add(#IsWellTyped(select(h,o,f)) ==>)
	\heuristics(inReachableStateImplication)   	
   };*/
   
   
   //--------------------------------------------------------------------------
   //rules for typing (could be in normal KeY as well)
   //--------------------------------------------------------------------------
   
   primitiveAndReferenceSortsAreDisjoint1 {
   	\find(x = y)
   	\varcond(\not\isReference(\typeof(x)), \isReference(\typeof(y)))
   	\replacewith(false)
   	\heuristics(simplify)
   };
   
   primitiveAndReferenceSortsAreDisjoint2 {
   	\find(x = y)
   	\varcond(\isReference(\typeof(x)), \not\isReference(\typeof(y)))
   	\replacewith(false)
   	\heuristics(simplify)
   };
   
   disjointPrimitiveSorts {
   	\find(x = y)
   	\varcond(\not\isReference(\typeof(x)), \not\isReference(\typeof(y)), \disjoint(\typeof(x), \typeof(y)))
   	\replacewith(false)
   	\heuristics(simplify)
   };
   
   disjointReferenceSorts {
   	\find(x = y)
   	\varcond(\isReference[non_null](\typeof(x)), \isReference[non_null](\typeof(y)), \disjoint(\typeof(x), \typeof(y)))
   	\replacewith(x = null & y = null)
   	\heuristics(simplify)
   };
   
   
   //--------------------------------------------------------------------------
   //rules for array initialisation
   //--------------------------------------------------------------------------
   
   arrayInitialisation {
   	\schemaVar \modalOperator { diamond, box, diamond_trc, box_trc, throughout_trc } #normalassign;
   	\schemaVar \program Type #t;
   	\schemaVar \program Variable #v, #a;
   	\schemaVar \program SimpleExpression #se;
   	\schemaVar \program ArrayLength #length;
   	\schemaVar \program Literal #lit;
   	\schemaVar \formula post;
   	\schemaVar \skolemTerm Heap skolemHeap;
   	\schemaVar \variables int iv;
   	
	\find (\modality{#normalassign}{.#t(#a).. for (int #v=#se;#v<this.#length; #v++) this[#v] = #lit; ...}\endmodality(post))
	\sameUpdateLevel
	\replacewith({heap := skolemHeap}\modality{#normalassign}{..  ...}\endmodality(post))
	\add(\forall ov; \forall fv; select(skolemHeap, ov, fv) = \if(ov = #a & \exists iv; fv = arr(iv))
	                                                          \then(#lit)
	                                                          \else(select(heap, ov, fv)) ==>)
	\displayname "arrayInitialisation_NEW"
	\heuristics(simplify)
  };
}
