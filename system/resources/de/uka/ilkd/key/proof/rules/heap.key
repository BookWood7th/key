\sorts {
   Field;
   Heap;
   
   \generic GOS \extends Object;
}

\functions {
   //These function symbols interpret an element of sort Heap as a
   //two dimensional array, where the first index is of sort Object
   //and the second index of sort Field.
   any select(Heap, Object, Field);
   Heap store(Heap, Object, Field, any);

   //Dedicated heap symbol. Just a single program variable of sort Heap!
   //This symbol is used by the symbolic execution rules:
   //[o.f = e; ...]phi -->  {heap := store(heap, o, f, e)}[...]phi
   //(if we want it to look prettier, we can have the pretty printer render 
   // the update "heap := store(heap, o, f, e)" as "o.f := e")
   \nonRigid[Location] Heap heap;
   
   //for handling Java arrays
   \unique Field arr(int);
   
   //these would be automatically created on demand later, but we already need them here
   \unique Field java.lang.Object::<created>;
   \unique Field length;
}


\predicates {
   //replacement for inReachableState
   wellFormed(Heap);
}
   


\schemaVariables {
   \term Heap h;
   \term Object o;
   \term Object o2;
   \term Field f;
   \term Field f2;
   \term any x;
   \variables Object ov;
   \variables Field fv;
 }

\rules {
   //Axiom for the theory of arrays: storing x in an array at index (o,f) 
   //leads to an array where index (o,f) has the value x and everything else is 
   //unchanged.
   heapUpdate {
     \find(select(store(h,o,f,x), o2, f2))
     \replacewith(\if(o = o2 & f = f2)\then(x)\else(select(h,o2,f2)))
     \heuristics(simplify)
   };

   
   //Uniqueness axiom: 
   // - two unique constant symbols of type Field never denote the same value
   // - arr(i) is always different from any unique constant symbol of type Field
   // - arr(i) and arr(j) have the same value iff i and j have the same value
   fieldEquality {
     \find(f = f2)
     \varcond(\isUnique(f), \isUnique(f2))
     \replacewith(#sameField(f,f2))
     \heuristics(simplify)
   };
   
   
   
   //--------------------------------------------------------------------------
   //rules for wellFormed(Heap)
   //--------------------------------------------------------------------------
   
   
   //expand wellFormed(Heap) to its definition (expensive...)
   /*wellFormedHeap {
      \find(wellFormed(h))  
      \varcond(\notFreeIn(ov, h), \notFreeIn(fv, h))
      \replacewith(\forall ov; (ov != null & (boolean)select(h,ov,java.lang.Object::<created>) = TRUE 
      	           -> \forall fv; (java.lang.Object::contains(select(h,ov,fv))
      	                            -> (Object) select(h,ov,fv) = null | (boolean)select(h,(Object)select(h,ov,fv),java.lang.Object::<created>) = TRUE))
      	           &
      	           \forall ov; ((int) select(h,ov,length) >= 0)
      	           )
      			
   };*/
   
   
   //if o != null, if o.<created>, if o.f != null and if the heap is well-formed,
   //then we know that o.f.<created> 
   only_created_object_are_referenced_non_null_NEW {	          
         \assumes ((boolean) select(h, o, java.lang.Object::<created>) = TRUE, wellFormed(h) ==> o = null, (GOS) select(h, o, f) = null) 
         \find ( select(h, o, f) ) \sameUpdateLevel	 
         \add ( (boolean)select(h, (GOS) select(h, o, f), java.lang.Object::<created>) = TRUE ==>)
         \heuristics(inReachableStateImplication)         	 
         \displayname "referenced object is created"	 
   };
   
   
   wellFormedStore {
      \find(==> wellFormed(store(h,o,f,x)))  
      \replacewith(==> wellFormed(h)
                       & o != null 
                       & (boolean) select(h,o,java.lang.Object::<created>) = TRUE)
      \heuristics(inReachableStateImplication)
   };
   
   arrayLengthNonNegative {
       \assumes(wellFormed(h) ==> o = null)
       \find(select(h,o,length))
       \add((jint)select(h,o,length) >= 0 ==>)
       \heuristics(inReachableStateImplication)
   };
}
