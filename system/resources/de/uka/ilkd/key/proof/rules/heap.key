\sorts {
   Field;
   Heap;
   
   \generic GOS \extends Object;
   \generic G;
   \generic H;
}

\functions {
   //These function symbols interpret an element of sort Heap as a
   //two dimensional array, where the first index is of sort Object
   //and the second index of sort Field.
   any select(Heap, Object, Field);
   Heap store(Heap, Object, Field, any);

   //Dedicated heap symbol. Just a single program variable of sort Heap!
   //This symbol is used by the symbolic execution rules:
   //[o.f = e; ...]phi -->  {heap := store(heap, o, f, e)}[...]phi
   //(if we want it to look prettier, we can have the pretty printer render 
   // the update "heap := store(heap, o, f, e)" as "o.f := e")
   \nonRigid[Location] Heap heap;
   
   //for handling Java arrays
   \unique Field arr(int);
   
   //these would be automatically created on demand later, but we already need them here
   \unique Field java.lang.Object::<created>;
   \unique Field Array::length;
}


\predicates {
   //replacement for inReachableState
   wellFormed(Heap);
}
   


\schemaVariables {
   \term Heap h;
   \term Object o;
   \term Object o2;
   \term Field f;
   \term Field f2;
   \term G x;
   \term H y;
 }

\rules {
   //Axiom for the theory of arrays: storing x in an array at index (o,f) 
   //leads to an array where index (o,f) has the value x and everything else is 
   //unchanged.
   heapUpdate {
     \find(select(store(h,o,f,x), o2, f2))
     \replacewith(\if(o = o2 & f = f2)\then(x)\else(select(h,o2,f2)))
     \heuristics(simplify)
   };

   
   //Uniqueness axiom: 
   // - two unique constant symbols of type Field never denote the same value
   // - arr(i) is always different from any unique constant symbol of type Field
   // - arr(i) and arr(j) have the same value iff i and j have the same value
   fieldEquality {
     \find(f = f2)
     \varcond(\isUnique(f), \isUnique(f2))
     \replacewith(#sameField(f,f2))
     \heuristics(simplify)
   };
   
   
   
   //--------------------------------------------------------------------------
   //rules for wellFormed(Heap)
   //--------------------------------------------------------------------------
   
   //if o != null, if o.<created>, if o.f != null and if the heap is well-formed,
   //then we know that o.f.<created> 
   only_created_object_are_referenced_non_null_NEW {	          
         \assumes ((boolean) select(h, o, java.lang.Object::<created>) = TRUE, wellFormed(h) ==> o = null, (GOS) select(h, o, f) = null) 
         \find ( select(h, o, f) )	 
	 \sameUpdateLevel
         \add ( (boolean)select(h, (GOS) select(h, o, f), java.lang.Object::<created>) = TRUE ==>)
         \heuristics(inReachableStateImplication)         	 
   };
   
   createdAndNextToCreateAreConsistent {
      \schemaVar \program ImplicitNextToCreate #nc;
      \schemaVar \term int i;
     
      \assumes(wellFormed(h) ==>)
      \find(GOS::<get>(i))
      \sameUpdateLevel          
      \add((boolean) select(h, GOS::<get>(i), java.lang.Object::<created>) = TRUE
                        <-> i < #nextToCreate((GOS)null) ==>)
      \heuristics(inReachableStateImplication)     
   };
   
   
   arrayLengthNonNegative {
       \assumes(wellFormed(h) ==> o = null)
       \find(select(h,o,Array::length)) 
       \sameUpdateLevel       
       \add((jint)select(h,o,Array::length) >= 0 ==>)
       \heuristics(inReachableStateImplication)
   };
   
   wellFormedReferenceStoreRight {
      \find(==> wellFormed(store(h,o,f,x)))  
      \varcond(\isReference(\fieldTargetType(o,f)))
      "Original heap well-formed":
        \replacewith(==> wellFormed(h));
      "Store preserves well-formedness":
        \replacewith(==> (boolean) select(h,o,java.lang.Object::<created>) = FALSE,
                     x = null,
                     (boolean) select(h, x, java.lang.Object::<created>) = TRUE)
      \heuristics(simplify)
   };
   
   wellFormedPrimitiveStoreRight {
      \find(==> wellFormed(store(h,o,f,x)))  
      \varcond(\not\isReference(\fieldTargetType(o,f)))
      "Original heap well-formed":
        \replacewith(==> wellFormed(h));
      "Store preserves well-formedness":
        \replacewith(==> (boolean) select(h,o,java.lang.Object::<created>) = FALSE, 
                         f != java.lang.Object::<created>) 
      \heuristics(simplify)
   };
   
   //other well-formedness rules should be lemmas following from this axiom
   /*wellFormedDefinition {
      \schemaVar \variables Object ov;
      \schemaVar \variables Field fv;
      \find(==> wellFormed(h))
      \replacewith(\forall ov; \forall fv; 
      			(ov = null 
      			 | (boolean) select(h, ov, java.lang.Object::<created>) = FALSE
      			 | select(h, ov, fv)
   }*/
   
   
   //--------------------------------------------------------------------------
   //rules for typing (could be in normal KeY as well)
   //--------------------------------------------------------------------------
   
   sortsDisjointModuloNull {
   	\find(x = y)
   	\varcond(\strict\sub(Null, G), \strict\sub(Null, H), \disjointModuloNull(G, H))
   	\replacewith(x = null & y = null)
   	\heuristics(simplify)
   };
   
   sortsDisjoint1 {
   	\find(x = y)
   	\varcond(\not\sub(Null, G), \disjointModuloNull(G, H))
   	\replacewith(false)
   	\heuristics(simplify)
   };
   
   sortsDisjoint2 {
   	\find(x = y)
   	\varcond(\not\sub(Null, H), \disjointModuloNull(G, H))
   	\replacewith(false)
   	\heuristics(simplify)
   };

   
   //--------------------------------------------------------------------------
   //rules for array initialisation
   //--------------------------------------------------------------------------
   /*
   arrayInitialisation_NEW {
   	\schemaVar \modalOperator { diamond, box, diamond_trc, box_trc, throughout_trc } #normalassign;
   	\schemaVar \program Type #t;
   	\schemaVar \program Variable #v, #a;
   	\schemaVar \program SimpleExpression #se;
   	\schemaVar \program ArrayLength #length;
   	\schemaVar \program Literal #lit;
   	\schemaVar \formula post;
   	\schemaVar \skolemTerm Heap skolemHeap;
   	\schemaVar \variables Object ov;
   	\schemaVar \variables Field fv;   	
   	\schemaVar \variables int iv;
   	
	\find (\modality{#normalassign}{.#t(#a).. for (int #v=#se;#v<this.#length; #v++) this[#v] = #lit; ...}\endmodality(post))
	\sameUpdateLevel
	\replacewith({heap := skolemHeap}\modality{#normalassign}{..  ...}\endmodality(post))
	\add(\forall ov; \forall fv; select(skolemHeap, ov, fv) = \if(ov = #a & \exists iv; fv = arr(iv))
	                                                          \then(#lit)
	                                                          \else(select(heap, ov, fv)),
	     wellFormed(skolemHeap) ==>)
	\heuristics(simplify)
  };*/
  
  arrayInitialisation_ADDRULE {
   	\schemaVar \modalOperator { diamond, box, diamond_trc, box_trc, throughout_trc } #normalassign;
   	\schemaVar \program Type #t;
   	\schemaVar \program Variable #v, #a;
   	\schemaVar \program SimpleExpression #se;   	
   	\schemaVar \program ArrayLength #length;
   	\schemaVar \program Literal #lit;
   	\schemaVar \formula post;
   	\schemaVar \skolemTerm Heap arrayInitHeap;
   	\schemaVar \skolemTerm G array;
   	
	\find (\modality{#normalassign}{.#t(#a).. for (int #v=#se;#v<this.#length; #v++) this[#v] = #lit; ...}\endmodality(post))
	\varcond( \hasSort(#t, G),
		  \hasSort(array, G),
	          \same(\typeof(array), \typeof(#a)))
	\replacewith(array = #a -> {heap := arrayInitHeap}\modality{#normalassign}{..  ...}\endmodality(post))
	\add(wellFormed(arrayInitHeap) ==>)
	\addrules ( arrayInitialisationHeap {
	   		\schemaVar \variables int iv; 
			\find(select(arrayInitHeap, o, f))
			\varcond(\notFreeIn(iv, f, o))
			\replacewith(\if(o = array & \exists iv; f = arr(iv))
	                             \then(#lit)
	                             \else(select(heap, o, f)))
			\heuristics(simplify)
	            })
	\heuristics(simplify)
  };
  
}
