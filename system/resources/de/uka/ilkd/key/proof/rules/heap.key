\include locSets;

\sorts {
    Field;
    Heap;
   
    \generic GOS \extends Object;
    \generic G;
    \generic H;
}



\functions {
    //These function symbols interpret an element of sort Heap as a
    //two dimensional array, where the first index is of sort Object
    //and the second index of sort Field.
    any select(Heap, Object, Field);
    Heap store(Heap, Object, Field, any);

    //Dedicated heap symbol. Just a single program variable of sort Heap!
    //This symbol is used by the symbolic execution rules:
    //[o.f = e; ...]phi -->  {heap := store(heap, o, f, e)}[...]phi
    //(if we want it to look prettier, we can have the pretty printer render 
    // the update "heap := store(heap, o, f, e)" as "o.f := e")
    \nonRigid[Location] Heap heap;
   
    //for handling Java arrays
    \unique Field arr(int);
      
    //these would be automatically created on demand later, but we already need them here
    \unique Field java.lang.Object::<created>;
    \unique Field Array::length;
    
    
    Heap changeHeapAtLocs(Heap, LocSet, Heap);
}



\predicates {
    //replacement for inReachableState
    wellFormed(Heap);
}
   


\rules {
    //Axiom for the theory of arrays: storing x in an array at index (o,f) 
    //leads to an array where index (o,f) has the value x and everything else is 
    //unchanged.
    heapUpdate {
	\schemaVar \term Heap h;
	\schemaVar \term Object o, o2;
	\schemaVar \term Field f, f2;
	\schemaVar \term G x;
   
	\find(select(store(h, o, f, x), o2, f2))
	
	\replacewith(\if(o = o2 & f = f2)
                     \then(x)
                     \else(select(h, o2, f2)))
      	\heuristics(simplify)
    };
   
   
    //essentially the same as above (needed for automation)
    heapUpdate2 {
	\schemaVar \term Heap h, h2;
	\schemaVar \term Object o, o2;
	\schemaVar \term Field f, f2;
	\schemaVar \term G x;
   
   	\assumes(h2 = store(h, o, f, x) ==>)
	\find(select(h2, o2, f2))
	\sameUpdateLevel
	 
	\replacewith(\if(o = o2 & f = f2)
                     \then(x)
                     \else(select(h, o2, f2)))
	\heuristics(simplify)
    };
   
   
    //and a third version
    heapUpdate3 {
	\schemaVar \term Heap h, h2;
	\schemaVar \term Object o, o2;
	\schemaVar \term Field f, f2;
	\schemaVar \term G x;
   
   	\assumes(store(h, o, f, x) = h2 ==>)
	\find(select(h2, o2, f2))
	\sameUpdateLevel 
	
	\replacewith(\if(o = o2 & f = f2)
                     \then(x)
                     \else(select(h, o2, f2)))
	\heuristics(simplify)
    };

   
    //Uniqueness axiom: 
    // - two unique function symbols of type Field never denote the same value
    // - arr(i) and arr(j) have the same value iff i and j have the same value
    fieldEquality {
	\schemaVar \term Field f, f2;
   
	\find(f = f2)
	\varcond(\isUnique(f), \isUnique(f2))
	         
	\replacewith(#sameField(f,f2))
	\heuristics(concrete)
    };
    
    
    
       
    //--------------------------------------------------------------------------
    //rules for changeHeapAtLocs
    //--------------------------------------------------------------------------
   
    selectFromChangeHeapAtLocs {
        \schemaVar \term Heap h, h2;
        \schemaVar \term LocSet s;
	\schemaVar \term Object o;
	\schemaVar \term Field f; 
        \find(select(changeHeapAtLocs(h, s, h2), o, f))
        \replacewith(\if(elementOf(o, f, s))
                     \then(select(h2, o, f))
                     \else(select(h, o, f)))
        \heuristics(simplify)
    };
    
    selectFromChangeHeapAtLocs2 {
        \schemaVar \term Heap h, h2, h3;
        \schemaVar \term LocSet s;
	\schemaVar \term Object o;
	\schemaVar \term Field f;
	 
   	\assumes(h3 = changeHeapAtLocs(h, s, h2) ==>)
	\find(select(h3, o, f))
	\sameUpdateLevel 
	
        \replacewith(\if(elementOf(o, f, s))
                     \then(select(h2, o, f))
                     \else(select(h, o, f)))
        \heuristics(simplify)
    };
    
    selectFromChangeHeapAtLocs3 {
        \schemaVar \term Heap h, h2, h3;
        \schemaVar \term LocSet s;
	\schemaVar \term Object o;
	\schemaVar \term Field f;
	
   	\assumes(changeHeapAtLocs(h, s, h2) = h3 ==>)
	\find(select(h3, o, f))
	\sameUpdateLevel 
	
        \replacewith(\if(elementOf(o, f, s))
                     \then(select(h2, o, f))
                     \else(select(h, o, f)))
        \heuristics(simplify)
    };
    
    changeHeapAtEmpty {
        \schemaVar \term Heap h, h2;
        \find(changeHeapAtLocs(h, empty, h2))
        \replacewith(h)
        \heuristics(concrete)
    };

    changeHeapAtEverything {
        \schemaVar \term Heap h, h2;
        \find(changeHeapAtLocs(h, everything, h2))
        \replacewith(h2)
        \heuristics(concrete)
    };
   
   
   
    //--------------------------------------------------------------------------
    //rules for wellFormed(Heap)
    //--------------------------------------------------------------------------
   
    //if o != null, if o.<created>, if o.f != null and if the heap is well-formed,
    //then we know that o.f.<created> 
    only_created_object_are_referenced_non_null_NEW {
	\schemaVar \term Heap h;
	\schemaVar \term Object o;
	\schemaVar \term Field f;
    	          
	\assumes((boolean) select(h, o, java.lang.Object::<created>) = TRUE, wellFormed(h) 
	         ==> o = null, (GOS) select(h, o, f) = null) 
	\find(select(h, o, f))	 
	\sameUpdateLevel
	
	\add((boolean)select(h, (GOS) select(h, o, f), java.lang.Object::<created>) = TRUE ==>)
	\heuristics(inReachableStateImplication)         	 
    };
   
   
    createdAndNextToCreateAreConsistent {
	\schemaVar \term Heap h;
	\schemaVar \term int i;	
     
	\assumes(wellFormed(h) ==>)
	\find(GOS::<get>(i))
	\sameUpdateLevel
	          
	\add((boolean) select(h, GOS::<get>(i), java.lang.Object::<created>) = TRUE
                        <-> i < (int){heap:=h}#nextToCreate((GOS)null) ==>)
	\heuristics(inReachableStateImplication)     
    };
   
   
    arrayLengthNonNegative {
	\schemaVar \term Heap h;
	\schemaVar \term Object o;
   
	\assumes(wellFormed(h) ==> o = null)
	\find(select(h,o,Array::length)) 
	\sameUpdateLevel       
	\add((jint) select(h,o,Array::length) >= 0 ==>)
	\heuristics(inReachableStateImplication)
    };
   
   
    wellFormedReferenceStoreRight {
	\schemaVar \term Heap h;
	\schemaVar \term Object o;
	\schemaVar \term Field f;
	\schemaVar \term G x;
    
	\find(==> wellFormed(store(h, o, f, x)))  
	\varcond(\isReference(\fieldTargetType(o, f)))
	
	"Original heap well-formed":
          \replacewith(==> wellFormed(h));
	"Store preserves well-formedness":
          \replacewith(==> (boolean) select(h, o, java.lang.Object::<created>) = FALSE,
                           x = null,
                           (boolean) select(h, x, java.lang.Object::<created>) = TRUE)
                       
	\heuristics(simplify)
    };
    
    
    wellFormedPrimitiveStoreRight {
        \schemaVar \term Heap h;
        \schemaVar \term Object o;
        \schemaVar \term Field f;
        \schemaVar \term G x;
    
	\find(==> wellFormed(store(h, o, f, x)))  
	\varcond(\not\isReference(\fieldTargetType(o, f)))
	
	"Original heap well-formed":
          \replacewith(==> wellFormed(h));
	"Store preserves well-formedness":
          \replacewith(==> (boolean) select(h,o,java.lang.Object::<created>) = FALSE, 
                           f != java.lang.Object::<created>) 
	\heuristics(simplify)
    };
   
      
   
    //--------------------------------------------------------------------------
    //rules for typing (could be in normal KeY as well)
    //--------------------------------------------------------------------------
   
    sortsDisjointModuloNull {
        \schemaVar \term G x;
        \schemaVar \term H y;
    
	\find(x = y)
	\varcond(\strict\sub(Null, G), \strict\sub(Null, H), \disjointModuloNull(G, H))
	
	\replacewith(x = null & y = null)
	\heuristics(simplify)
   };
   
   
    sortsDisjoint1 {
        \schemaVar \term G x;
        \schemaVar \term H y;
    
	\find(x = y)
   	\varcond(\not\sub(Null, G), \disjointModuloNull(G, H))
   	
   	\replacewith(false)
   	\heuristics(simplify)
    };
   
   
    sortsDisjoint2 {
        \schemaVar \term G x;
        \schemaVar \term H y;

	\find(x = y)
	\varcond(\not\sub(Null, H), \disjointModuloNull(G, H))
	
	\replacewith(false)
	\heuristics(simplify)
    };

   
   //--------------------------------------------------------------------------
   //rules for array initialisation
   //--------------------------------------------------------------------------
  
  
    arrayInitialisation_NEW {
	\schemaVar \modalOperator { diamond, box, diamond_trc, box_trc, throughout_trc } #normalassign;
   	\schemaVar \program Type #t;
   	\schemaVar \program Variable #v, #a;
   	\schemaVar \program SimpleExpression #se;   	
   	\schemaVar \program ArrayLength #length;
   	\schemaVar \program Literal #lit;
   	\schemaVar \formula post;
   	\schemaVar \skolemTerm Heap arrayInitHeap;   	
       	\schemaVar \skolemTerm Heap beforeArrayInitHeap;   
	\schemaVar \skolemTerm G array;   	
       		
    
  	\find (\modality{#normalassign}{.#t(#a).. for (int #v=#se;#v<this.#length; #v++) this[#v] = #lit; ...}\endmodality(post))
	\varcond( \hasSort(#t, G),
		  \hasSort(array, G),
	          \same(\typeof(array), \typeof(#a)))
  	
	\replacewith(array = #a & heap = beforeArrayInitHeap 
	             -> {heap := changeHeapAtLocs(heap, setMinus(allFields(#a), singleton(#a, Array::length)), arrayInitHeap)}
	                \modality{#normalassign}{..  ...}\endmodality(post))
	\add(wellFormed(changeHeapAtLocs(beforeArrayInitHeap, allFields(array), arrayInitHeap)) ==>)
	
	\addrules ( selectFromArrayInitHeap {
			\schemaVar \term Object o;
			\schemaVar \term Field f;
	   		\schemaVar \term int i;
	   		 
			\find(select(arrayInitHeap, o, arr(i)))
			\replacewith(#lit)
			\heuristics(simplify)
	            },
	            
	            selectFromArrayInitHeap2 {
	            	\schemaVar \term Heap h;
			\schemaVar \term Object o;
			\schemaVar \term Field f;
	   		\schemaVar \term int i;
	   		
	   		\assumes(h = arrayInitHeap ==>)
			\find(select(h, o, arr(i)))
			\sameUpdateLevel			
			
			\replacewith(#lit)
	                             
			\heuristics(simplify)
	            },
	            
	            selectFromArrayInitHeap3 {
	            	\schemaVar \term Heap h;
			\schemaVar \term Object o;
			\schemaVar \term Field f;
	   		\schemaVar \term int i;
	   		
	   		\assumes(arrayInitHeap = h ==>)
			\find(select(h, o, arr(i)))
			\sameUpdateLevel			
			
			\replacewith(#lit)
	                             
			\heuristics(simplify)
	            }
	          )
	            
	\heuristics(simplify)
    };
}
