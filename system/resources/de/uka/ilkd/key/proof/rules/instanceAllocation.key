\include ruleSetsDeclarations;

\sorts {
  \generic G;
  \generic G1 \extends G;
  \generic H;
  \generic J;
  \generic K;
  \generic INT \extends int;
}

\schemaVariables {
  \modalOperator { diamond, box, throughout,
                   diamond_trc, box_trc, throughout_trc,
                   diamond_tra, box_tra, throughout_tra,
			       diamond_susp, box_susp, throughout_susp } #allmodal ;
  
  \program <allocate> #allocate;
  \program <allocateArea> #allocateArea;
 
  \program SpecialConstructorReference #scr;
  \program ImplicitClassInitialized #classInitialized ;
  \program ImplicitNextToCreate #nc;
  \program ImplicitSize #size1, #size2;
  \program ImplicitExactSize #esize;
  \program ImplicitCreated #c;
  \program ImplicitEnclosingThis #et;
  \program InstanceCreation #n;
  \program ArrayCreation #na;
  \program ArrayInitializer #arrayinitializer;
 
  \program SimpleExpression #len;
  \program ArrayLength #length ;
  \program ScopeName #scope;
 
  \program makeTransientArray #maketransientarray;

  \program Expression #e, #e0, #e1, #e2, #e3;  
  \program StaticVariable #staticField;
  \program Variable #v0, #v1, #v2, #v3, #a, #a1, #a2;
  \program LeftHandSide #lhs;
  \program push #push;
  \program delete #delete;
  \program Type #t, #t1, #t2;
  \term int idx0, idx1, allocNr, symbLength, #s1, #l1, #s2, #l2;
  \program ExecutionContext #ex;

  \term numbers #size, #l;
   
  \variables int iv;
  \variables boolean bv;
  \variables G ov;
  \term G ot, obj2;
  \term H const, obj1;
  \term J obj;
  \formula post, b;

  \term int ws1, ws2;
  
  \term boolean bool;
  \skolemTerm G sk ;
  
  \term G arr;
  \term H #term;
  // attention some strategies rely on the name of the SV if you change it, please adopt
  // the strategies as well
  \term int negLit;
  \term int nonNegLit;
}

\functions{
  int maxSpace(any);
}

 
\rules(programRules:Java, initialisation:disableStaticInitialisation){

   static_fields_are_null_or_reference_created_objects {
   	\assumes (inReachableState ==>)
   	\find (==> #staticField = null)
   	\varcond(\isReference[non_null](\typeof(#staticField)))
   	\add(#created(#staticField) = TRUE, immortal(#attribute:stack(#memoryArea(#staticField))) ==>)
        \heuristics(inReachableStateImplication)
   	\displayname "static field welldefined"
   };

}

\rules(programRules:Java, perc:on) {

   allocateInstance {       
        \find (\modality{#allmodal}{.#t1(#e0, #e1, #e2).. #t(#lhs)::#t.#allocate(); ...}\endmodality(post)) 	
	\varcond(\hasSort(#t1, G), \new(#v0, \typeof(#t1)))
        /*
           Attention: critical for correctness: 
                  * allocation should be done simultaneously
                  * increment _needs_ arithmetical add operator (no mod semantics)
        */                   
        \replacewith ({#lhs := G::<get>(#nextToCreate(#v0)) || 
                       #nextToCreate(#v0) := add(#nextToCreate(#v0), 1) ||
                       #created(G::<get>(#nextToCreate(#v0))) := TRUE ||
		       #memoryArea(G::<get>(#nextToCreate(#v0))):=#e1 ||
		       #reentrantScope(G::<get>(#nextToCreate(#v0))):=null}
	                      #objectSize(#v0, \if(#attribute:consumed(#e1)<=#attribute:size(#e2))
			\then(\modality{#allmodal}{..  ...}\endmodality(post))
			\else(\modality{#allmodal}{.. throw javax.realtime.RealtimeSystem.oome(); ...}\endmodality(post))
			, #e1))
	\heuristics(simplify_object_creation)
	\oldname "instance_allocation_contract"
   };

}

\rules(programRules:Java, rtsj:on) {

   deleteScope{
	\find(\modality{#allmodal}{..javax.realtime.MemoryArea()::#v0.#delete(#v1);...}\endmodality(post))
        \varcond(\new(#v3, jint), \hasSort(#v0, G) )
	\replacewith(
		(
			outerScope(#attribute:stack(#v1), #stackAtIndex(#v3)) &
			outerScope(#attribute:stack(#v0), #stackAtIndex(#v3)) &
			#v3 >= #nextToCreateStack &
			\forall ov;((#created(ov)=TRUE & !ov=#v1 & !ov=#v0 &
				     (outerScope(#attribute:stack(#v1), #attribute:stack(ov)) | 
				      outerScope(#attribute:stack(#v0), #attribute:stack(ov)))) -> 
				    outerScope(#stackAtIndex(#v3), #attribute:stack(ov)))
		)
		->
		{
			#attribute:stack(#v1):=#stackAtIndex(#v3) ||
			#nextToCreateStack := #v3+1 ||
		 	\for iv; \if (iv>=#nextToCreateStack & iv <= #v3) #created(#stackAtIndex(iv)) := TRUE ||
			#memoryArea(#stackAtIndex(#v3)):=#memoryArea(#v1) 
		//	\for olv; \if (#memoryArea(olv)=#v0) #memoryArea(olv) := #v1
		}
		#updateScope(#v0, #v1, \modality{#allmodal}{..  ...}\endmodality(post))
		)
	\heuristics(simplify_object_creation)
	};

}

\rules(programRules:Java, rtsj:on, perc:off ) {
   allocateInstance {       
        \find (\modality{#allmodal}{.#t1(#e).. #t(#lhs)::#t.#allocate(); ...}\endmodality(post)) 	
	\varcond(\hasSort(#t1, G), \new(#v0, \typeof(#t1)))
        /*
           Attention: critical for correctness: 
                  * allocation should be done simultaneously
                  * increment _needs_ arithmetical add operator (no mod semantics)
        */                   
        \replacewith ({#lhs := G::<get>(#nextToCreate(#v0)) || 
                       #nextToCreate(#v0) := add(#nextToCreate(#v0), 1) ||
                       #created(G::<get>(#nextToCreate(#v0))) := TRUE ||
		       #memoryArea(G::<get>(#nextToCreate(#v0))):=#e }
	                      #objectSize(#v0, \if(#attribute:consumed(#e)<=#attribute:size(#e))
			\then(\modality{#allmodal}{..  ...}\endmodality(post))
			\else(\modality{#allmodal}{.. throw javax.realtime.RealtimeSystem.oome(); ...}\endmodality(post))
			, #e))
	\heuristics(simplify_object_creation)
	\oldname "instance_allocation_contract"
   };

   memoryStackPush{
	\find(\modality{#allmodal}{..javax.realtime.MemoryStack(#v0)::#v1.#push(#v2);...}\endmodality(post))
        \varcond(\new(#a, javax.realtime.ScopedMemory[]), \hasSort(#v1, G),  \new(#v3, jint) )
        \replacewith ( (outerScope(#v1,G::<get>(#nextToCreate(#v1)+#v3)) & #v3>=0) -> 
		{
		 \for iv; \if (iv>=#nextToCreate(#v1) & iv <= #nextToCreate(#v1)+#v3) #created(G::<get>(iv)) := TRUE ||
		 #v0 := G::<get>(#nextToCreate(#v1)+#v3) ||
		 #nextToCreate(#v1) := #nextToCreate(#v1)+1+#v3
		}
		{
		 #memoryArea(#v0):=#memoryArea(#v1)
	//	 #attribute:_stack(#v0) := javax.realtime.ScopedMemory[]::<get>(#nextToCreate(#a)) ||
	//	 #nextToCreate(#a):=#nextToCreate(#a)+1
		}
	//	{
	//	  \for iv; \if (geq(iv,0) & lt(iv,#lengthReference(#attribute:_stack(#v1)))) #attribute:_stack(#v0)[iv] := #attribute:_stack(#v1) ||
	//	  #attribute:_stack(#v0)[#lengthReference(#attribute:_stack(#v1))]:=#v2
	//	}
		\modality{#allmodal}{..  ...}\endmodality(post)

	)
	\heuristics(simplify_object_creation)
   };

   outerScopeQuery{
	\find(\modality{#allmodal}{..javax.realtime.MemoryArea(#v0)::javax.realtime.MemoryArea.outerScopeM(#v1,#v2);...}\endmodality(post))
        \replacewith (\if(outerScope(#attribute:stack(#v1), #attribute:stack(#v2)))
			\then({#v0:=TRUE}\modality{#allmodal}{..  ...}\endmodality(post))
			\else({#v0:=FALSE}\modality{#allmodal}{..  ...}\endmodality(post))
	)
	\heuristics(simplify_object_creation)
   };
}


\rules(programRules:Java, rtsj:off, perc:off) {
   allocateInstance {       
        \find (\modality{#allmodal}{.#t1(#e).. #t(#lhs)::#t.#allocate(); ...}\endmodality(post)) 	
        \varcond(\hasSort(#t1, G), \new(#v0, \typeof(#t1)))
        /*
           Attention: critical for correctness: 
                  * allocation should be done simultaneously
                  * increment _needs_ arithmetical add operator (no mod semantics)
        */                   
        \replacewith ({#lhs := G::<get>(#nextToCreate(#v0)) || 
                       #nextToCreate(#v0) := add(#nextToCreate(#v0), 1) ||
                       #created(G::<get>(#nextToCreate(#v0))) := TRUE ||
		       #memoryArea(G::<get>(#nextToCreate(#v0))):=#e }
	                      #objectSize(#lhs,\modality{#allmodal}{..  ...}\endmodality(post), #e)
		     )
	\heuristics(simplify_object_creation)
	\oldname "instance_allocation_contract"
   };
}

\rules(programRules:Java, perc:off) {

//----------------------------------------------------------------------------
// ---------                heap space consumption              --------------
//----------------------------------------------------------------------------

   // For PERC Pico we only work with symbolic object sizes, not concrete ones.

   array_literal_dimension{
	\find(arraySize(Z(#size), Z(#l)))
        \replacewith(#calculateArraySize(Z(#size), Z(#l)))
        \heuristics (simplify_literals)	
   };

   array_worst_best_case_memory_consumption{
	\find(arraySize(Z(#size), symbLength)) \sameUpdateLevel
        \add(
	arraySize(Z(#size), symbLength) <= #wcArraySize(Z(#size), symbLength) &
	arraySize(Z(#size), symbLength) >= #bcArraySize(Z(#size), symbLength) &
	arraySize(Z(#size), symbLength) >= 16
	==>)
	\heuristics(inReachableStateRTSJ)
   };


//-----------------------------------------------------------------------------
}


\rules(programRules:Java, perc:on) {

   array_comparison{
	\find(==> arraySize(#s1, #l1)<=arraySize(#s2, #l2))
        \add(==> #s1<=#s2 & #l1<=#l2)
        \heuristics (simplify_literals)	
   };

   array_size_greater_zero{
	\find(arraySize(Z(#size), symbLength)) \sameUpdateLevel
        \add(arraySize(Z(#size), symbLength) >= 0 ==> )
	\heuristics(inReachableStateRTSJ)
   };

}


\rules(programRules:Java, rtsj:on, perc:off ) {

   stack_injective{
	\assumes(inReachableState , obj.#c = TRUE, obj2.#c = TRUE ==> obj.#a=null)
	\find(obj.#a = obj2.#a) \sameUpdateLevel 
	\varcond(\scopeStack(#a))
        \replacewith(obj = obj2)
	\heuristics(inReachableStateRTSJ)
   };	

}

\rules(programRules:Java) {

//----------------------------------------------------------------------------
//-----------                 object creation                      -----------
//----------------------------------------------------------------------------

   allocateArea {       
        \find (\modality{#allmodal}{.. #t()::#t.#allocateArea(#v0); ...}\endmodality(post)) 	
        /*
           Attention: critical for correctness: 
                  * allocation should be done simultaneously
                  * increment _needs_ arithmetical add operator (no mod semantics)
        */                   
        \replacewith ({#heapSpace := #heapSpace + #v0}
	                    \modality{#allmodal}{..  ...}\endmodality(post)
		     )
	\heuristics(simplify_object_creation)
	\oldname "instance_allocation_contract"
   };

   instanceCreationAssignment { \find (\modality{#allmodal}{.. #lhs = #n;  ...}\endmodality(post)) 
        \varcond(\new(#v0, \typeof(#n)))
        \replacewith (\modality{#allmodal}{.. #typeof(#v0) #v0 = #create-object(#n); 
		          #constructor-call(#v0, #n); 
                          #post-work(#v0);
			  #lhs = #v0;
		      ...}\endmodality(post)) 
	\heuristics(simplify_object_creation)
	\displayname "instanceCreation"
	\oldname "object_creation_assignment"
   };

   instanceCreation { \find (\modality{#allmodal}{.. #n ...}\endmodality(post)) 
        \varcond(\new(#v0, \typeof(#n)))
        \replacewith (\modality{#allmodal}{.. #typeof(#v0) #v0 = #create-object(#n); 
		          #constructor-call(#v0, #n); 
                          #post-work(#v0); ...}\endmodality(post)) 
	\heuristics(simplify_object_creation)
	\displayname "instanceCreation"
	\oldname "object_creation"
   };

   special_constructor_call { 
        \find (\modality{#allmodal}{.. #scr ...}\endmodality(post)) 
        \replacewith (\modality{#allmodal}{.. #special-constructor-call(#scr); ...}\endmodality(post)) 
	\heuristics(simplify_object_creation)
   };
   

//----------------------------------------------------------------------------
// ---------                heap space consumption              --------------
//----------------------------------------------------------------------------

   working_space_greater_equal_zero{
	\find(ws1)
	\varcond(\testWorkingSpaceOp(ws1))
	\add(geq(ws1,0) ==>)  
   };		

   working_space_same_method{
	\find(==> leq(ws1,ws2))
	\varcond(\equalWorkingSpaceOp(ws1, ws2))
	\add(==> #uniqueAnonUpdate(((inReachableState & #getPreForWS(ws1,ws2)) -> #getPreForWS(ws2,ws2))))
   };

  working_space_same_method_non_rigid{
        \find(ws1)
	\varcond(\testWorkingSpaceNonRigidOp(ws1))
	"Pre": \add(==> #preValidInStateOfWS(ws1, ws2));
	"Working Space Relation": \add(leq(ws1, ws2) ==>)
  };

   object_size_greater_zero_static{
	\find(#size1)
	\add(#size1>0 ==>)
	\heuristics(inReachableStateRTSJ)
   };

   object_size_greater_zero_exact{
	\find(#esize)
	\add(#esize>0 ==>)
	\heuristics(inReachableStateRTSJ)
   };

   // t2<:t1 ==> \max_space(t2)<=\max_space(t1)
   size_behav_subtype_static1{
	\assumes(#size1<=#term ==>)
	\find(#size2) \sameUpdateLevel
	\varcond(\same(\containerType(#size1), G),
		 \same(\containerType(#size2), G1) )
	\add(#size1>=#size2 ==>)
	\heuristics(inReachableStateRTSJ)
   };

   // t2<:t1 ==> \max_space(t2)<=\max_space(t1)
   size_behav_subtype_static2{
	\assumes(#size2>=#term  ==>)
	\find(#size1) \sameUpdateLevel
	\varcond(\same(\containerType(#size1), G),
		 \same(\containerType(#size2), G1) )
	\add(#size1>=#size2 ==>)
	\heuristics(inReachableStateRTSJ)
   };

   exact_size_behav_subtype_static1{
	\assumes(#size1<=#term ==>)
	\find(#esize) \sameUpdateLevel
	\varcond(\same(\containerType(#size1), G),
		 \same(\containerType(#esize), G1) )
	\add(#size1>=#esize ==>)
	\heuristics(inReachableStateRTSJ)
   };

   exact_size_behav_subtype_static2{
	\assumes(#esize>=#term  ==>)
	\find(#size1) \sameUpdateLevel
	\varcond(\same(\containerType(#size1), G),
		 \same(\containerType(#esize), G1) )
	\add(#size1>=#esize ==>)
	\heuristics(inReachableStateRTSJ)
   };

   // o instanceof t ==> \max_space(o) <= \max_space(t)
   size_behav_subtype_instance1{
	\assumes(maxSpace(obj)>=#term  ==>)
	\find(#size1) \sameUpdateLevel
	\varcond(\sub(J, \containerType(#size1)) )
	\add(maxSpace(obj)<=#size1 ==>)
	\heuristics(inReachableStateRTSJ)
   };

   // o instanceof t ==> \max_space(o) <= \max_space(t)
   size_behav_subtype_instance2{
	\assumes(#size1>=#term ==>)
	\find(maxSpace(obj)) \sameUpdateLevel
	\varcond(\sub(J, \containerType(#size1)) )
	\add(maxSpace(obj)<=#size1 ==>)
	\heuristics(inReachableStateRTSJ)
   };



//----------------------------------------------------------------------------
// ---------                    memory scopes                   --------------
//----------------------------------------------------------------------------
   
// TODO: remove redundant rules

   only_outer_scope_object_is_referenced_non_null {
         \assumes (inReachableState, obj.#c = TRUE ==> obj.#a = null)	 
         \find ( obj.#a ) \sameUpdateLevel
         \varcond(\isReference(\typeof(#a)), \not\parentScope(#a), \not\memoryArea(#a)) 
	 \add (outerScope(#attribute:stack(#memoryArea(obj.#a)), #attribute:stack(#memoryArea(obj))) ==>)
         \displayname "referenced object is in outer scope"	 
   };

   parent_outer_scope {
         \assumes (inReachableState, obj.#c = TRUE ==> #v0 = null)
         \find ( obj.#a=#v0 ==> ) 
         \varcond(\parentScope(#a))
	 \add (outerScope(#attribute:stack(#v0), #attribute:stack(obj)) ==> )
	 \heuristics(inReachableStateRTSJConcrete)
   };	

   only_outer_scope_object_is_referenced_non_null_concrete {
         \assumes (inReachableState, obj.#c = TRUE ==> obj.#a = null)	 
         \find (==> outerScope(obj.#a.#a1.#a2, obj.#a1.#a2))
         \varcond(\isReference(\typeof(#a)), \not\parentScope(#a), \not\memoryArea(#a))
	 \replacewith (==> true)
	 \heuristics(concrete)
         \displayname "referenced object is in outer scope"	 
   };

   only_outer_scope_object_is_referenced_non_null_3 {
         \assumes (inReachableState, obj.#c = TRUE ==> obj.#a = null)	 
         \find (==> outerScope(obj.#a.#a1.#a2, obj2))
         \varcond(\isReference(\typeof(#a)), \not\parentScope(#a), \not\memoryArea(#a))
	 \add (==> outerScope(obj.#a1.#a2, obj2))
	 \heuristics(inReachableStateRTSJConcrete)
         \displayname "referenced object is in outer scope"	 
   };

   outer_scope_non_null {
//	 \assumes (inReachableState ==>)
         \find (outerScope(obj, obj2) ==>)
	 \add (==> obj=null, obj2=null)
	 \heuristics(inReachableStateRTSJConcrete)
   };

   memory_areas_are_not_allocated_in_inner_scope1{
         \assumes (inReachableState, obj.#c = TRUE  ==>)	 
         \find (outerScope(obj.#a2, obj.#a.#a2)) \sameUpdateLevel
	 \varcond(\memoryArea(obj), \memoryArea(#a))
	 \replacewith (false)
	 \heuristics(concrete)
         \displayname "memory areas are allocated in outer scope"
   };

   stack_immortal{
         \assumes (inReachableState, obj.#c = TRUE ==>)	 
         \find (outerScope(obj.#a.#a2, obj)) \sameUpdateLevel
	 \varcond(\memoryArea(#a))
	 \replacewith (true)
	 \heuristics(concrete)
         \displayname "memory areas are allocated in outer scope"
   };

/*   only_outer_scope_object_is_referenced_non_null_4 {
         \assumes (inReachableState, obj2.#c = TRUE, obj.#c = TRUE ==> obj2.#a = null)	 
         \find (outerScope(obj, obj2.#a.#a1.#a2) ==>)
         \varcond(\isReference(\typeof(#a)), \not\parentScope(#a), \not\memoryArea(#a))
	 \add (outerScope(obj, obj2.#a1.#a2) ==>)
	 \heuristics(inReachableStateRTSJ)
         \displayname "referenced object is in outer scope"	 
   };

   every_object_has_memory_area {
	 \assumes (inReachableState ==>)
         \find (obj.#c = TRUE ==>)	 
         \add ((!(#memoryArea(obj))=null) & !(#attribute:stack(#memoryArea(obj))=null) ==>)
         \displayname "referenced object is in outer scope"	 
   };*/

   every_object_has_memory_area {
	 \assumes (inReachableState ==>)
         \find (obj.#c = TRUE ==>)	 
         \add (==> #memoryArea(obj)=null)
         \displayname "referenced object is in outer scope"	 
   };

   only_outer_scope_object_is_referenced_by_arrays_non_null {	 
         \assumes (inReachableState, arr.#c = TRUE ==> arr[idx0]@(G) = null)	 
         \find ( arr[idx0]@(G) ) \sameUpdateLevel
         \varcond(\isReferenceArray(arr))	 
	 \add (outerScope(#attribute:stack(#memoryArea(arr[idx0]@(G))), #attribute:stack(#memoryArea((arr)))) ==>)
         \heuristics(inReachableStateRTSJ)
         \displayname "referenced object is in outer scope"  
   };

   only_outer_scope_object_is_referenced_by_arrays_non_null_2 {	 
         \assumes (inReachableState, arr.#c = TRUE ==> arr[idx0]@(G) = null)	 
         \find (==> outerScope(arr[idx0]@(G).#a.#a2, arr.#a.#a2))
         \varcond(\isReferenceArray(arr))	 
	 \replacewith (==> true)
         \heuristics(concrete)
         \displayname "referenced object is in outer scope"  
   };

   only_outer_scope_object_is_referenced_by_arrays_non_null_3 {	 
         \assumes (inReachableState, arr.#c = TRUE ==> arr[idx0]@(G) = null)	 
         \find (==> outerScope(arr[idx0]@(G).#a.#a2, obj))
         \varcond(\isReferenceArray(arr))	 
	 \add (==> outerScope(arr.#a.#a2, obj))
         \heuristics(inReachableStateRTSJConcrete)
         \displayname "referenced object is in outer scope"  
   };

//redundant
/*   only_outer_scope_object_is_referenced_by_arrays_non_null_4 {	 
         \assumes (inReachableState, arr.#c = TRUE ==> arr[idx0]@(G) = null)	 
         \find (outerScope(obj, arr[idx0]@(G).#a.#a2) ==>)
         \varcond(\isReferenceArray(arr))	 
	 \add (outerScope(obj, arr.#a.#a2) ==>)
         \heuristics(inReachableStateRTSJ)
         \displayname "referenced object is in outer scope"  
   };*/

   outer_scope_antisymmetric {
	 \assumes(outerScope(obj2, obj) ==>)
         \find (outerScope(obj, obj2) ==>)
         \add (obj=obj2 ==>)
         \heuristics(simplify)
   };

   outer_scope_reflexive {
         \assumes (==> obj = null)
         \find (outerScope(obj, obj))
	 \replacewith (true)
	 \heuristics(concrete)
         \displayname "outer scope reflexive" 
   };

   outer_scope_reflexive_repository_object {
         \find (outerScope(G::<get>(allocNr), G::<get>(allocNr)))
	 \replacewith (true)
	 \heuristics(concrete)
         \displayname "outer scope reflexive" 
   };

   outer_scope_transitive {
	 \assumes(outerScope(obj2, obj1) ==>)
         \find (outerScope(obj1, obj) ==>)
	 \add (outerScope(obj2, obj) ==>)
	 \heuristics(inReachableStateRTSJConcrete)
   };

   immortal_is_outermost_scope {
	 \assumes(immortal(obj2) ==>)
         \find (outerScope(obj1, obj2) ==>)
	 \add (immortal(obj1) ==>)
	 \heuristics(inReachableStateRTSJConcrete)
         \displayname "immortal is outermost scope"  
   };

   immortal_is_outermost_scope2 {
	 \assumes(immortal(obj2) ==>)
         \find (outerScope(obj2, obj1))\sameUpdateLevel
	 \replacewith (true)
	 \heuristics(concrete)
         \displayname "immortal is outermost scope"  
   };

   immortal_is_outermost_scope3 {
         \assumes (inReachableState, obj.#c = TRUE ==> obj.#a = null)	 
         \find (==> immortal(obj.#a.#a1.#a2))
         \varcond(\isReference(\typeof(#a)))
	 \add (==> immortal(obj.#a1.#a2))
	 \heuristics(inReachableStateRTSJConcrete)
         \displayname "immortal is outermost scope"	 
   };

   immortal_is_outermost_scope4 {
         \assumes (inReachableState, arr.#c = TRUE ==> arr[idx0]@(G) = null)	 
         \find (==> immortal(arr[idx0]@(G).#a.#a2))
         \varcond(\isReferenceArray(arr))	 
	 \add (==> immortal(arr.#a.#a2))
         \heuristics(inReachableStateRTSJConcrete)
         \displayname "immortal is outermost scope"	 
   };

   immortal_unique {
	 \assumes(immortal(obj2) ==>)
         \find (immortal(obj1) ==>)
	 \add (obj1=obj2 ==>)
	 \heuristics(inReachableStateRTSJConcrete)
   };

   

//----------------------------------------------------------------------------
//-----------                 array creation                      -----------
//----------------------------------------------------------------------------

   

   arrayCreation { 
        \find (\modality{#allmodal}{.. #lhs = #na; ...}\endmodality(post)) 	
        \varcond(\new(#v0, \typeof(#na)))	
        \replacewith (#arraySize(\modality{#allmodal}{.. 	
		#typeof(#na) #v0; 
		#init-array-creation(#v0, #na);
                #lhs = #v0; ...}\endmodality(post)))
	    \heuristics(simplify_prog)
        \displayname "arrayCreation"
	\oldname "array_creation"
   };

   arrayCreationWithInitializers { 
        \find (\modality{#allmodal}{.. #lhs = #arrayinitializer; ...}\endmodality(post)) 	
        \varcond(\new(#v0, \typeof(#lhs)))	
        \replacewith (\modality{#allmodal}{.. 	
		#typeof(#lhs) #v0; 
		#init-array-creation(#v0, #arrayinitializer);
                #lhs = #v0; ...}\endmodality(post)) 
	   \heuristics(simplify_prog)
        \displayname "arrayCreation"
	\oldname "array_creation_with_initializers"
   };

  arrayCreationTransient {
        \find (\modality{#allmodal}{.. #lhs = #maketransientarray; ...}\endmodality(post))
        \varcond(\new(#v0, \typeof(#maketransientarray)))
        \replacewith (\modality{#allmodal}{..
                #typeof(#maketransientarray) #v0;
                #init-array-creation-transient(#v0, #maketransientarray);
                #lhs = #v0; ...}\endmodality(post))
         \heuristics(simplify_prog)
	\oldname "array_creation_transient"
   };

// --------- createdness of objects -------------- //

   only_created_object_are_referenced {	          
         \assumes (obj.#c = TRUE, inReachableState ==>)	 
         \find ( obj.#a ) \sameUpdateLevel
         \varcond(\isReference(\typeof(#a)))	 
         \add (#created(obj.#a) = TRUE | obj.#a = null ==>)	 
         \displayname "referenced object is created"	 
   };
   
   only_created_object_are_referenced_non_null {
         \assumes (obj.#c = TRUE, inReachableState ==> obj.#a = null)	 
         \find ( obj.#a ) \sameUpdateLevel
         \varcond(\isReference(\typeof(#a)))	 
         \add (#created(obj.#a) = TRUE ==>)	 
         \heuristics(inReachableStateImplication)
         \displayname "referenced object is created"	 
   };

   only_created_object_are_referenced_right {
         \assumes (inReachableState ==>)	 
         \find (==> obj.#a.#c = TRUE)
         \add (#created(obj) = FALSE | obj=null | obj.#a = null ==>)	 
         \heuristics(inReachableStateImplication)
         \displayname "referenced object is created"	 
   };

   only_created_object_are_referenced_by_arrays_right {
         \assumes (inReachableState ==>)
         \find (==> arr[idx0]@(G).#c = TRUE)
         \add (#created(arr) = FALSE | arr=null | arr[idx0]@(G) = null ==>)	 
         \heuristics(inReachableStateImplication)
         \displayname "indexed object is created"	 
   };

   enclosing_this_is_created{
         \assumes (obj.#c = TRUE, inReachableState ==>)	 
         \find ( obj.#et ) \sameUpdateLevel
         \add (#created(obj.#et) = TRUE  ==> obj.#et=null)
         \heuristics(inReachableStateImplication)
         \displayname "enclosing instance is created"
   };
   
   // extremely common situation due to skolem constants introduced during proofs
   only_created_object_are_referenced_non_null2 {
         \assumes (obj.#c = TRUE, inReachableState ==> const = null)
         \find ( obj.#a = const ==> )
         \varcond(\isReference(\typeof(#a)))	 
         \add (#created(const) = TRUE ==>)	 
         \heuristics(inReachableStateImplication)
         \displayname "referenced object is created"	 
   };
   
   only_created_object_are_referenced_non_null3 {
         \assumes (obj.#c = TRUE, inReachableState ==>)
         \find ( obj.#a = K::<get>(allocNr) ==> )
         \varcond(\isReference(\typeof(#a)), \isReference[non_null](K))
         \add (#created(K::<get>(allocNr)) = TRUE ==>)	 
         \heuristics(inReachableStateImplication)
         \displayname "referenced object is created"	 
   };
   

   only_created_object_are_referenced_by_arrays {	 
         \assumes (arr.#c = TRUE, inReachableState ==>)	 
         \find ( arr[idx0]@(G) ) \sameUpdateLevel
         \varcond(\isReferenceArray(arr))	 
         \add (#created(arr[idx0]@(G)) = TRUE | arr[idx0]@(G) = null ==>)	 
         \displayname "indexed object is created"  
   };
   
   only_created_object_are_referenced_by_arrays_non_null {	 
         \assumes (arr.#c = TRUE, inReachableState ==> arr[idx0]@(G) = null)	 
         \find ( arr[idx0]@(G) ) \sameUpdateLevel
         \varcond(\isReferenceArray(arr))	 
         \add (#created(arr[idx0]@(G)) = TRUE ==>)
         \heuristics(inReachableStateImplication)
         \displayname "indexed object is created"  
   };
   
   // extremely common situation due to skolem constants introduced during proofs
   only_created_object_are_referenced_by_arrays_non_null2 {
         \assumes (arr.#c = TRUE, inReachableState ==> const = null)
         \find ( arr[idx0]@(G) = const ==> )
         \varcond(\isReferenceArray(arr))	 
         \add (#created(const) = TRUE ==>)
         \heuristics(inReachableStateImplication)
         \displayname "indexed object is created"  
   };

   only_created_object_are_referenced_by_arrays_non_null3 {
         \assumes (arr.#c = TRUE, inReachableState ==>)
         \find ( arr[idx0]@(G) = K::<get>(allocNr) ==> )
         \varcond(\isReferenceArray(arr), \isReference[non_null](K))
         \add (#created(K::<get>(allocNr)) = TRUE ==>)
         \heuristics(inReachableStateImplication)
         \displayname "indexed object is created"  
   };
   
   only_created_object_are_referenced_by_arrays_2 {	 
         \assumes (arr.#c = TRUE, inReachableState ==>)	 
         \find (==> arr[idx0]@(G).#c = TRUE ) 
         \varcond(\isReferenceArray(arr))	 
         \replacewith (==> !arr[idx0]@(G) = null)
         \heuristics (simplify) 
         \displayname "indexed object is created"  
   };   
      
      
   static_fields_of_initialized_classes_are_null_or_reference_created_objects {
   	\assumes (inReachableState, #classInitialized = TRUE ==>)
   	\find (#staticField) \sameUpdateLevel 
   	\varcond(\isReference[non_null](\typeof(#staticField)), 
   	         \same(\containerType(#classInitialized), \containerType(#staticField)))
   	\add(#staticField = null | #created(#staticField) = TRUE ==>)
   	\displayname "static field welldefined"
   };
   
   static_fields_of_initialized_classes_reference_created_objects {
   	\assumes (inReachableState, #classInitialized = TRUE ==> #staticField = null)
   	\find (#staticField) \sameUpdateLevel 
   	\varcond(\isReference[non_null](\typeof(#staticField)), 
   	         \same(\containerType(#classInitialized), \containerType(#staticField)))
   	\add(#created(#staticField) = TRUE ==>)
        \heuristics(inReachableStateImplication)
   	\displayname "static field welldefined"
   };
   
   // extremely common situation due to skolem constants introduced during proofs
   static_fields_of_initialized_classes_reference_created_objects2 {
   	\assumes (inReachableState, #classInitialized = TRUE ==> const = null)
   	\find (#staticField = const ==>)
   	\varcond(\isReference[non_null](\typeof(#staticField)), 
   	         \same(\containerType(#classInitialized), \containerType(#staticField)))
   	\add(#created(const) = TRUE ==>)
        \heuristics(inReachableStateImplication)
   	\displayname "static field welldefined"
   };
   
// ---------------   JVM invariants  ------------------------ //
   created_inv_index_in_bounds {
	 \assumes ( H::exactInstance(obj) = TRUE, inReachableState ==> )	          
         \find ( obj.#c = TRUE ==>)
         \varcond(\isReference[non_null](\typeof(obj)), \notFreeIn(iv, obj))	 
         \add (\exists iv; (iv >= 0 & iv < #nextToCreate((H)obj) & obj = H::<get>(iv)) ==>)	 
         \displayname "insert invariant (repository bounds)"	 
   };
   
   created_to_known_index_in_bounds {	 
         \assumes (inReachableState ==>) 
         \find ( H::<get>(idx0).#c = TRUE ) \sameUpdateLevel
	 // <get> is not created for Null, but I keep the non_null modifier
	 // for the moment
         \varcond(\isReference[non_null](H))	 
         \replacewith ( idx0>=0 & idx0 < #nextToCreate(H::<get>(idx0)) )
         \heuristics (simplify)	 
         \displayname "created as known index in bounds"
   };
      
   created_add_known_index_in_bounds {
	 \assumes ( H::<get>(idx0).#c = TRUE, inReachableState ==> )	          
         \find ( obj = H::<get>(idx0) ==> ) 
 	 // <get> is not created for Null, but I keep the non_null modifier
	 // for the moment
	 \varcond( \isReference[non_null](H) )	 
         \add (idx0 >= 0 & idx0 < #nextToCreate((H)obj) ==>)	 
         \displayname "created add known index in bounds"	 
   };
   
   created_add_known_index_in_bounds_sym {
	 \assumes ( obj.#c = TRUE, inReachableState ==> )	          
         \find ( H::<get>(idx0) = obj ==> ) 
 	 // <get> is not created for Null, but I keep the non_null modifier
	 // for the moment
	 \varcond(\isReference[non_null](\typeof(obj)) )	 
         \add (idx0 >= 0 & idx0 < #nextToCreate((H)obj) ==>)	 
         \displayname "created add known index in bounds"	 
   };
   
   created_add_known_index_in_bounds_2 {
	 \assumes ( obj = H::<get>(idx0), inReachableState ==> )	          
         \find ( H::<get>(idx0).#c = TRUE ==> ) 
	 // <get> is not created for Null, but I keep the non_null modifier
	 // for the moment
	 \varcond( \isReference[non_null](H) )	 
         \add (idx0 >= 0 & idx0 < #nextToCreate((H)obj) ==>)	 
         \displayname "created add known index in bounds"	 
   };


   objects_with_index_geq_next_to_create_are_not_created {
	 \assumes ( obj = H::<get>(idx0), idx0 >= #nc, inReachableState ==> )	          
         \find ( H::<get>(idx0).#c = TRUE ==> ) 
 	 // <get> is not created for Null, but I keep the non_null modifier
	 // for the moment
	 \varcond( \isReference[non_null](H), \same(\containerType(#nc), H) )	 
         \replacewith(false ==>)	 
         \heuristics (simplify)
         \displayname "contradiction (object index is too great)"	 
   };   
   
   //--  rules designed to be used by strategies  --//

   //  START  //
   objects_with_negative_index_are_not_created {
	 \assumes ( obj = H::<get>(idx0), idx0 <= negLit, inReachableState ==> )	          
         \find ( H::<get>(idx0).#c = TRUE ==> ) 
      	 // <get> is not created for Null, but I keep the non_null modifier
	 // for the moment
         \varcond( \isReference[non_null](H) )	 
         \replacewith(\if (negLit < 0) \then ( false ) \else (H::<get>(idx0).#c = TRUE) ==>)	 
         \heuristics (system_invariant)
         \displayname "contradiction, if object index is negative"	 
   };
   

   objects_with_index_greater_next_to_create_are_not_createdsystem_invariant_for_created_2a_automated_use_3 {
	 \assumes ( obj = H::<get>(idx0), idx0 >= nonNegLit + #nc, inReachableState ==> )	          
         \find ( H::<get>(idx0).#c = TRUE ==> )
      	 // <get> is not created for Null, but I keep the non_null modifier
	 // for the moment 
         \varcond( \isReference[non_null](H), \same(\containerType(#nc), H))	 
         \replacewith(\if (#nc + nonNegLit >= 0) \then (false) \else (H::<get>(idx0).#c = TRUE)==>)	 
         \heuristics (system_invariant)
         \displayname "contradiction, if object index is too great"	 
   };
   //  END  //
   
   
   system_invariant_for_created_2a_sym {
	 \assumes ( H::<get>(idx0) = obj, inReachableState ==> )	          
         \find ( obj.#c = TRUE ==> ) 
	 // <get> is not created for Null, but I keep the non_null modifier
	 // for the moment
	 \varcond( \isReference[non_null](\typeof(obj)) )	 
         \add (idx0 >= 0 & idx0 < #nextToCreate((H)obj) ==>)	 
         \displayname "system invariant for created"	 
   };
   
   
   system_invariant_for_created_3 {
         \assumes ( inReachableState ==> H::<get>(idx0).#c = TRUE)	          
         \find ( obj = H::<get>(idx0) ==> ) 
 	 // <get> is not created for Null, but I keep the non_null modifier
	 // for the moment
         \varcond( \isReference[non_null](H) )	 
         \add (idx0 < 0 | idx0 >= #nextToCreate((H)obj) ==>)	 
         \displayname "system invariant for created"	 
   };
   
   
   system_invariant_for_created_3_sym {
	 \assumes ( inReachableState ==> obj.#c = TRUE)	          
         \find ( H::<get>(idx0) = obj ==> ) 
 	 // <get> is not created for Null, but I keep the non_null modifier
	 // for the moment
         \varcond( \isReference[non_null](H) )	 
         \add (idx0 >= #nextToCreate((H)obj) ==>)	 
         \displayname "system invariant for created"	 
   };
         
   repository_object_non_null {
        \find (G::<get>(allocNr) = null) \sameUpdateLevel
	 // <get> is not created for Null, but I keep the non_null modifier
	 // for the moment
	\varcond(\isReference[non_null](G))
        \replacewith (false) 
        \heuristics(type_hierarchy_def)
        \displayname "repository object is not null"
   };

   nextToCreate_non_negative {
        \assumes(inReachableState ==>) 
        \find ( #nc ) \sameUpdateLevel 
        \add (#nc >= 0 ==>) 
        \heuristics(inReachableStateImplication)
   };

   array_length_non_negative { 
   	\assumes(inReachableState, arr.#c = TRUE ==> arr = null)
        \find (arr.#length>=0)  \sameUpdateLevel         
        \replacewith (true)
	\displayname "array length is non-negative"
   };

   array_length_non_negative_2 { 
   	\assumes(inReachableState, arr.#c = TRUE ==> arr = null)
        \find (arr.#length<0)   \sameUpdateLevel       
        \replacewith(false) 
	\displayname "array length is non-negative"
   };

   array_length_non_negative_3 { 
   	\assumes(inReachableState, arr.#c = TRUE ==> arr = null)
        \find(arr.#length) \sameUpdateLevel        
        \add (arr.#length >=0 ==>)
	\heuristics(inReachableStateImplication)
	\displayname "array length is non-negative"
   };

   //-- this rule is for automatic use --// 
   nextToCreate_non_negative_2 {
        \assumes(inReachableState ==>) 
        \find ( #nc <= negLit ==>)
        \replacewith(\if (negLit < 0) \then (false) \else (#nc <= negLit) ==>) 
        \heuristics (system_invariant)
   };

   identical_object_equal_index { 
        \find (G::<get>(idx0) = G::<get>(idx1)) 
        \varcond(\isReference[non_null](G))
        \replacewith (idx0 = idx1) 
        \heuristics(type_hierarchy_def)
	\displayname "identical objects equal index"
   };

   disjoint_repositories { 
	\find (G::<get>(idx0) = H::<get>(idx1))
	\varcond(\not\same(G, H))
        \replacewith (false)	
        \heuristics(type_hierarchy_def)
	\displayname "disjoint object repositories"
   };

   // instance for primitive types
   boolean_is_no_int {
   	\find(bool = idx0) 
   	\replacewith(false)
        \heuristics(type_hierarchy_def)
   };
   
    int_is_no_boolean {
   	\find(idx0 = bool) 
   	\replacewith(false)
        \heuristics(type_hierarchy_def)
   };
   
   all_integer_sorts_are_equals {
        \find(INT::instance(idx0))
        \replacewith(TRUE)
        \heuristics(type_hierarchy_def)
   };
   
   
   //====================================//
   //                                    //
   //    Definition of exactInstance     //
   //                                    //
   //====================================//
        
   exact_instance_definition_reference { 
         \find (G::exactInstance(obj) = TRUE)
         \varcond(\not\isAbstractOrInterface(G),
                  \isReference[non_null](G),
                  \isReference[non_null](\typeof(obj)), 
                  \notFreeIn(iv, obj))	 
         \replacewith (\exists iv; (obj = G::<get>(iv)))
         \heuristics (simplify)	 
         \displayname "insert definition"	 
   };   
   
  exact_instance_definition_integerDomain {
         \find(integerDomain::exactInstance(idx0) = TRUE)
         \varcond(\notFreeIn(iv, idx0))
         \replacewith (\exists iv; (idx0 = iv))
         \heuristics (simplify)
         \displayname "insert definition"
   };

   exact_instance_definition_int {
         \find(int::exactInstance(idx0))
         \replacewith (FALSE)
         \heuristics (simplify)
         \displayname "insert definition"
   };

   exact_instance_definition_jbyte {	 
         \find(jbyte::exactInstance(idx0))
         \replacewith (FALSE)
         \heuristics (simplify)	 
         \displayname "insert definition" 
   };   
   exact_instance_definition_jshort {	 
         \find(jshort::exactInstance(idx0))
         \replacewith (FALSE)
         \heuristics (simplify)	 
         \displayname "insert definition" 
   };   
   exact_instance_definition_jint {	 
         \find(jint::exactInstance(idx0))
         \replacewith (FALSE)
         \heuristics (simplify)	 
         \displayname "insert definition" 
   };   
   exact_instance_definition_jlong {	 
         \find(jlong::exactInstance(idx0))
         \replacewith (FALSE)
         \heuristics (simplify)	 
         \displayname "insert definition" 
   };   
   exact_instance_definition_jchar {	 
         \find(jchar::exactInstance(idx0))
         \replacewith (FALSE)
         \heuristics (simplify)	 
         \displayname "insert definition" 
   };   
   
   exact_instance_definition_boolean {	 
         \find ( boolean::exactInstance(bool) = TRUE)
         \varcond(\notFreeIn(bv, bool))	 
         \replacewith (\exists bv; (bool = bv))
         \heuristics (simplify)	 
         \displayname "insert definition"	 
   };   
   
    exact_instance_definition_null {	 
         \find ( Null::exactInstance(obj) = TRUE)
         \varcond(\notFreeIn(bv, bool))	 
         \replacewith (obj = null)
         \heuristics (simplify)	 
         \displayname "insert definition"	 
   };   
   
   exact_instance_definition_known {	 
         \find (G::exactInstance(G::<get>(idx0)))
         \varcond(\isReference[non_null](G))	      
         \replacewith (TRUE)
         \heuristics (type_hierarchy_def)
         \displayname "known exact type"	 
   };   
   
   exact_instance_definition_known_eq {	 
    	 \assumes(G::<get>(idx0) = obj ==>)
         \find (G::exactInstance(obj)) \sameUpdateLevel
         \varcond(\isReference[non_null](G))	      
         \replacewith (TRUE)
         \heuristics (type_hierarchy_def)	 
         \displayname "known exact type"	 
   };   
   
   exact_instance_definition_known_false {	 
         \find (H::exactInstance(G::<get>(idx0)))
         \varcond(\not\same(G, H))      
         \replacewith (FALSE)
         \heuristics (type_hierarchy_def)	 
         \displayname "known exact type"	 
   };   
   
    exact_instance_definition_known_eq_false {	 
    	 \assumes(G::<get>(idx0) = obj ==>)
         \find (H::exactInstance(obj)) \sameUpdateLevel
         \varcond(\not\same(G, H))	      
         \replacewith (FALSE)
         \heuristics (type_hierarchy_def)	 
         \displayname "known exact type"	 
   };   
   
   exact_instance_for_interfaces_or_abstract_classes {	     	
         \find (G::exactInstance(obj)) 
         \varcond(\isAbstractOrInterface(G))	      
         \replacewith (FALSE)
         \heuristics (type_hierarchy_def)	 
         \displayname "interfaces or abstract classes have no exact instances"	 
   };   
   
}

\rules(programRules:Java,javacard:jcOn) {

   array_length_short_javacard { 
   	\assumes(inReachableState, arr.#c = TRUE ==> arr = null)
        \find(arr.#length) \sameUpdateLevel        
        \add (inShort(arr.#length) ==>)
	\heuristics(inReachableStateImplication)
	\displayname "array length in Java Card is a short"
   };
   
}
