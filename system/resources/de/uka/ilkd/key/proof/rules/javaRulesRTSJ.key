\include ruleSetsDeclarations;
\include rtsjFuncPreds;

\sorts{
  \generic G;
  \generic H;
  \generic J \extends G;
}

\schemaVariables {
 \modalOperator { diamond, box, throughout,
                             diamond_trc, box_trc, throughout_trc,
                             diamond_tra, box_tra, throughout_tra,
			     diamond_susp, box_susp, throughout_susp } #allmodal;
 \modalOperator { diamond, box, diamond_trc, box_trc, throughout_trc } #normalassign;
 \modalOperator { diamond_tra, box_tra, throughout_tra, diamond_susp, box_susp, throughout_susp } #traonly;
 \modalOperator { diamond, box, throughout, diamond_trc, box_trc, throughout_trc } #allbuttra;
 
 \program ImplicitTransactionCounter #transactionCounterSV;

 \formula post, inv, ws;
 \program Type #t;
 
 \term G q ;
 \skolemTerm G queryValue, sk ;

 \program ArrayLength #length ;
 

 \program SimpleExpression #se, #se0, #se1 ;
 
 \program LeftHandSide #lhs, #lhs0, #lhs1, #lhs2 ;
 \program LeftHandSide #attribute ;
 \program StaticVariable #sv, #sv0, #sv1 ;

 \program Variable #v, #v0, #v1, #v2, #v3, #v4, #mem, #boolv, #a, #a0, #a1, #oldHS;
 \program Variable #loc ;


 \program Statement #s, #s0, #s1 ;
 \program Expression #e, #e0, #e1;
 
 \program[list] Expression #elist ;
 \program[list] SimpleExpression #selist ;
 
 \program NonModelMethodBody #mb;
 \program MethodName #mn;
 \program PureMethodBody #pmb;

 \program ExecutionContext #ex, #ex1; 

 \location[list] #modifies;
 \formula anon1, anon2, anon3;
 
 \program NonStringLiteral #lit;
 \program StringLiteral #slit;

 \variables int iv, iv2, iv3;
 \term int idx;
 \term int wsOneIt, heapSpace; 

 // generic sorts
 \term G array, variant ;
 \term H obj ;

 \variables G x ;
 \formula inReachableStateSV;
 
 
}

// ==== inReachableState Definition ======

\rules(programRules:Java, rtsj:on) {
  inReachableStatePO { \find (==> inReachableStateSV) 
                   \varcond(\isInReachableState(inReachableStateSV)) // this varcond is a hack
                   \replacewith (==> inReachableState & 
                          #createInReachableStateRTSJPO(inReachableStateSV) ) 
                   \addrules ( insert_hidden { \add (==> inReachableStateSV) } )
  };  
  
  inReachableStateExpand { \find (inReachableStateSV ==>) 
  		    \varcond(\isInReachableState(inReachableStateSV)) // this varcond is a hack
  		    \replacewith( inReachableState -> 
                              #createInReachableStateRTSJPO(inReachableStateSV) ==> ) 
                    \addrules (insert_hidden { \add (inReachableStateSV ==>) })
                    \heuristics ( inReachableStateExpandAntec )
  };  
  
  inReachableStateRewrite { \assumes (inReachableState ==>)
                    \find (inReachableStateSV) \sameUpdateLevel
  		    \varcond(\isInReachableState(inReachableStateSV)) // this varcond is a hack
  		    \replacewith( inReachableStateSV |
                                  #createInReachableStateRTSJPO(inReachableStateSV))
                    \heuristics ( inReachableStateExpandRewrite )
  };  

}

// === assignment rules

\rules(programRules:Java, rtsj:on) {

  assignment_instance_field_of_this_primitive  { \find (\modality{#normalassign}{.. #v = #se; ...}\endmodality(post)) 
		\varcond(\not\isReference(\typeof(#v)), \not\static(#v))
                \replacewith ({#v:= #se}\modality{#normalassign}{.. ...}\endmodality(post)) 
	        \heuristics(simplify_prog, simplify_prog_subset)
                \displayname "assignment"
		\oldname "assignment_normalassign"};

  // constant case cannot occur as no static initilisation handling happens
  assignment_write_static_attribute_with_variable_prefix {
	\find (\modality{#normalassign}{.. @(#v.#sv) = #se; ...}\endmodality(post))
	\varcond(\new(#v3, \typeof(#se)))
	"Normal Case": \replacewith({#sv := #se} \modality{#normalassign}{.. ...}\endmodality(post))
	\add({#v3:=#se}immortal(#attribute:stack(#memoryArea(#v3))) | #se=null ==>);
	"Illegal Assignment Error": \replacewith(\modality{#normalassign}{..throw new javax.realtime.IllegalAssignmentError(); ...}\endmodality(post))
	\add(==> {#v3:=#se}immortal(#attribute:stack(#memoryArea(#v3))) | #se=null)
        \heuristics(simplify_prog, simplify_prog_subset)
        \displayname "active_attribute_access"
  };

  assignment_write_static_attribute_reference {
	\find (\modality{#normalassign}{.. @(#sv) = #se; ...}\endmodality(post))\sameUpdateLevel
	 \varcond(\isReference(\typeof(#sv)), \new(#v3, \typeof(#se)))
	"Normal Case (#se=null | #se in immortal memory)": 
	\replacewith({#sv := #se} \modality{#normalassign}{.. ...}\endmodality(post))
	\add ({#v3:=#se}immortal(#attribute:stack(#memoryArea(#v3))) | #se=null ==>);	
	"Illegal Assignment Error":
	\replacewith(\modality{#normalassign}{.. throw new javax.realtime.IllegalAssignmentError(); ...}\endmodality(post))
	\add (==> {#v3:=#se}immortal(#attribute:stack(#memoryArea(#v3))) | #se=null)
        \heuristics(simplify_prog, simplify_prog_subset)
        \displayname "assignment"
  };



}

\rules(programRules:Java, nullPointerPolicy:nullCheck, rtsj:on) {

  assignment_to_reference_array_component { 
                 \find (\modality{#normalassign}{.. #v[#se]=#se0; ...}\endmodality(post)) \sameUpdateLevel
		 \varcond(\isReferenceArray(#v), \notFreeIn(iv2, #se0))
		 "Normal Execution (#v != null)":
			\replacewith({#v[#se]:=#se0} \modality{#normalassign}{.. ...}\endmodality(post))
			\add (!(#v=null) & lt(#se, #lengthReference(#v)) & geq(#se,0) & arrayStoreValid(#v, #se0) &
			      {#v[#se]:=#se0}outerScope(#attribute:stack(#memoryArea(#v[#se])), #attribute:stack(#memoryArea(#v))) ==>);
		 "Null Reference (#v = null)":
			\replacewith(\modality{#normalassign}{.. throw new java.lang.NullPointerException(); ...}\endmodality(post))
			\add (#v=null ==>);
		 "Index Out of Bounds (#v != null, but #se Out of Bounds!)":
			\replacewith(\modality{#normalassign}{.. throw new java.lang.ArrayIndexOutOfBoundsException(); ...}\endmodality(post))
			\add (!(#v=null) & (leq(#lengthReference(#v), #se) | lt(#se,0)) ==>);
                 "Array Store Exception (incompatible dynamic element type of #v and #se0)":
                        \replacewith(\modality{#normalassign}{.. throw new java.lang.ArrayStoreException(); ...}\endmodality(post))
                        \add (!(#v=null) & lt(#se, #lengthReference(#v)) & geq(#se,0) & !arrayStoreValid(#v, #se0) ==>);
		 "Illegal Assignment Error (#v not allocated in the same or an inner scope relative to #se0)":
			\replacewith(\modality{#normalassign}{.. throw new javax.realtime.IllegalAssignmentError(); ...}\endmodality(post))
                        \add (!(#v=null) & lt(#se, #lengthReference(#v)) & geq(#se,0) & arrayStoreValid(#v, #se0) & !(#se0=null) &
			      !{#v[#se]:=#se0}outerScope(#attribute:stack(#memoryArea(#v[#se])), #attribute:stack(#memoryArea(#v)))
				==>)
	         \heuristics(simplify_prog, simplify_prog_subset)
		 \displayname "assignment"
};

assignment_array4{\find (\modality{#normalassign}{.#t(<currentMemoryArea>=#se0, this=#e).. #v = #v0[#se]; ...}\endmodality(post)) \sameUpdateLevel
		 \varcond(\not\isLocalVariable(#v), \isReferenceArray(#v0))
		"Normal Execution (#v0 != null)":
		   \replacewith({#v:=#v0[#se]}\modality{#normalassign}{.. ...}\endmodality(post))
		   \add (outerScope(#attribute:stack(#memoryArea(#v0[#se])), #attribute:stack(#memoryArea(#e))) | #v0[#se]=null ==> 
			 (#v0=null) | leq(#lengthReference(#v0), #se) | lt(#se,0)); 
		"Null Reference (#v0 = null)":
		   \replacewith(\modality{#normalassign}{.. throw new java.lang.NullPointerException(); ...}\endmodality(post))
	           \add (#v0=null ==>);	

		"Index Out of Bounds (#v0 != null, but #se Out of Bounds!)":
	  	   \replacewith(\modality{#normalassign}{..
			throw new java.lang.ArrayIndexOutOfBoundsException();
		    ...}\endmodality(post))
		   \add (!(#v0=null) & (leq(#lengthReference(#v0), #se) | lt(#se,0)) ==>);
		"Illegal Assignment Error (right-hand side not in outer scope)":
		   \replacewith(\modality{#normalassign}{.. throw new javax.realtime.IllegalAssignmentError(); ...}\endmodality(post))
		   \add (==> outerScope(#attribute:stack(#memoryArea(#v0[#se])), #attribute:stack(#memoryArea(#e))) | #v0[#se]=null |
				(#v0=null) | leq(#lengthReference(#v0), #se) | lt(#se,0))
//				#memoryArea(#v0[#se]) = #attribute:stack(#attribute:stack(#se0))[0]	
    	         \heuristics(simplify_prog, simplify_prog_subset)
		 \displayname "assignment"};

assignment_write_attribute_reference { 
		\find (\modality{#normalassign}{..#v.#a=#se;...}\endmodality(post)) \sameUpdateLevel
	        \varcond(\not \static(#a), \not\parentScope(#a), \isReference(\typeof(#se)), \new(#v3, \typeof(#a)))
		"Normal Execution (#v != null)":
		      \replacewith({#v.#a := #se}\modality{#normalassign}{.. ...}\endmodality(post))
		      \add ({#v3:=#se}outerScope(#attribute:stack(#memoryArea(#v3)), #attribute:stack(#memoryArea(#v))) | #se=null ==>(#v=null));
		"Null Reference (#v = null)":
		      \replacewith(\modality{#normalassign}{..throw new java.lang.NullPointerException();...}\endmodality(post))
		      \add (#v=null ==>);	 
		"Illegal Assignment Error (right-hand side not in outer scope)":
		   \replacewith(\modality{#normalassign}{.. throw new javax.realtime.IllegalAssignmentError(); ...}\endmodality(post))
		   \add (==> {#v3:=#se}outerScope(#attribute:stack(#memoryArea(#v3)), #attribute:stack(#memoryArea(#v))) | 
			 #v=null | #se=null)
		   \heuristics(simplify_prog, simplify_prog_subset)
		   \displayname "assignment"};

assignment_write_attribute_parent_reference { 
		\find (\modality{#normalassign}{..#v.#a=#se;...}\endmodality(post)) \sameUpdateLevel
	        \varcond(\not \static(#a), \parentScope(#a), \isReference(\typeof(#se)), \new(#v3, \typeof(#a)))
		"Normal Execution (#v != null)":
		      \replacewith({#v.#a := #se}\modality{#normalassign}{.. ...}\endmodality(post))
		      \add ({#v3:=#se}outerScope(#attribute:stack(#memoryArea(#v3)), #attribute:stack(#memoryArea(#v))) | #se=null ==>(#v=null));
		"Null Reference (#v = null)":
		      \replacewith(\modality{#normalassign}{..throw new java.lang.NullPointerException();...}\endmodality(post))
		      \add (#v=null ==>)	 
		   \heuristics(simplify_prog, simplify_prog_subset)
		   \displayname "assignment"};

/*assignment_write_attribute_reference { 
		\find (\modality{#normalassign}{..#v.#a=#se;...}\endmodality(post)) \sameUpdateLevel
	        \varcond(\not \static(#a), \isReference(\typeof(#se)), \new(#v3, \typeof(#a)))
		"Normal Execution (#v != null)":
		      \replacewith({#v.#a := #se}\modality{#normalassign}{.. ...}\endmodality(post))
		      \add ({#v3:=#se}outerScope(#attribute:stack(#memoryArea(#v3)), #attribute:stack(#memoryArea(#v))) | #se=null 
				==>(#v=null));
		"Null Reference (#v = null)":
		      \replacewith(\modality{#normalassign}{..throw new java.lang.NullPointerException();...}\endmodality(post))
		      \add (#v=null ==>);	 
		"Illegal Assignment Error (right-hand side not in outer scope)":
		   \replacewith(\modality{#normalassign}{.. throw new javax.realtime.IllegalAssignmentError(); ...}\endmodality(post))
		   \add (==> {#v3:=#se}outerScope(#attribute:stack(#memoryArea(#v3)), #attribute:stack(#memoryArea(#v))) | 
			 #v=null | #se=null )
		   \heuristics(simplify_prog, simplify_prog_subset)
		   \displayname "assignment"};*/



}




\rules(programRules:Java, rtsj:on) {

  assignment_instance_field_of_this_reference_rtsj  { \find (\modality{#normalassign}{.#t(<currentMemoryArea>=#e1, this=#e).. #v = #se; ...}\endmodality(post)) \sameUpdateLevel
		\varcond(\isReference(\typeof(#v)), \not\static(#v), \not\parentScope(#v), \not\isLocalVariable(#v), \new(#v3, \typeof(#v)))
                "Normal Case": \replacewith ({#v := #se}\modality{#normalassign}{.. ...}\endmodality(post))
		\add({#v3:=#se}outerScope(#attribute:stack(#memoryArea(#v3)), #attribute:stack(#memoryArea(#e))) | #se=null ==>);
		"Illegal Assignment Error":
		\replacewith (\modality{#normalassign}{.. throw new javax.realtime.IllegalAssignmentError(); ...}\endmodality(post))
		\add(==> {#v3:=#se}outerScope(#attribute:stack(#memoryArea(#v3)), #attribute:stack(#memoryArea(#e))) | #se=null )
	        \heuristics(simplify_prog, simplify_prog_subset)
                \displayname "assignment"
		\oldname "assignment_normalassign"};

  assignment_instance_field_parent_of_this_reference_rtsj  { \find (\modality{#normalassign}{.#t(<currentMemoryArea>=#e1, this=#e).. #v = #se; ...}\endmodality(post)) \sameUpdateLevel
		\varcond(\isReference(\typeof(#v)), \not\static(#v), \parentScope(#v), \not\isLocalVariable(#v), \new(#v3, \typeof(#v)))
                \replacewith ({#v := #se}\modality{#normalassign}{.. ...}\endmodality(post))
		\add({#v3:=#se}outerScope(#attribute:stack(#memoryArea(#v3)), #attribute:stack(#memoryArea(#e))) | #se=null ==>)
	        \heuristics(simplify_prog, simplify_prog_subset)
                \displayname "assignment"
		\oldname "assignment_normalassign"};

}

\rules(programRules:Java, rtsj:on, memory:on) {

  while_inv_diamond_dec_ws1_demo { \find (==> \<{.#t(<currentMemoryArea>=#mem)..  while(#e) #s ...}\>post)
         \varcond(\new(#v1, boolean), \new(#v2, jint), \new(#v3, jint), \new(#v4, jint),
                  \new(#oldHS, jint),
                  \new(anon1,\dependingOnMod(#modifies)),
          	  \new(anon2,\dependingOnMod(#modifies)),
                  \new(anon1, \dependingOn(post)),
                  \new(anon1, \dependingOn(inv)),
                  \new(anon1, \dependingOn(variant)),
                  \new(anon2, \dependingOn(post)),
                  \new(anon2, \dependingOn(inv)),
                  \new(anon2, \dependingOn(variant)))
     "Invariant Initially Valid":
         \replacewith (==> inv & variant >= 0 );
     "Body Preserves Invariant and Decreases Variant":
         \replacewith (==> #atPreEqs(anon1) -> {#v2:=variant || #v3:=wsOneIt || #oldHS:=#attribute:consumed(#mem)
						}#introNewAnonUpdate (#modifies, inv & variant >= 0  ->
               {#v4:=variant} {#attribute:consumed(#mem):=#oldHS+((#v2-#v4)*#v3)}{#oldHS:=#attribute:consumed(#mem)}(
			\[{ method-frame(#t(<currentMemoryArea>=#mem)):{#typeof(#e) #v1 = #e;} }\]#v1=TRUE ->
				#whileInvRule(\<{.. while (#e) #s ...}\>post,
                               inv & #attribute:consumed(#mem)-#oldHS<=#v3 & variant < #v4 & variant >= 0 )),anon1));
     "Use Case":
         \replacewith (==> {#v2:=variant*wsOneIt || #oldHS:=#attribute:consumed(#mem) }#introNewAnonUpdate(#modifies, inv ->
                            (\[{ method-frame(#t(<currentMemoryArea>=#mem)):{#typeof(#e) #v1 = #e;} }\]
                         (#v1=FALSE -> {#attribute:consumed(#mem):=#oldHS+#v2}\<{..   ...}\>post)),anon2))

    \heuristics (loop_invariant, loop_invariant_proposal, mem_loop)
    \displayname "while_invariant_with_variant_dec_and_working_space"
    }; 

  while_inv_diamond_dec_ws2_demo { \find (==> \<{.#t(<currentMemoryArea>=#mem, this=#e0)..  while(#e) #s ...}\>post)
         \varcond(\new(#v1, boolean), \new(#v2, jint), \new(#v3, jint), \new(#v4, jint),
                  \new(#oldHS, jint),
                  \new(anon1,\dependingOnMod(#modifies)),
          	  \new(anon2,\dependingOnMod(#modifies)),
                  \new(anon1, \dependingOn(post)),
                  \new(anon1, \dependingOn(inv)),
                  \new(anon1, \dependingOn(variant)),
                  \new(anon2, \dependingOn(post)),
                  \new(anon2, \dependingOn(inv)),
                  \new(anon2, \dependingOn(variant)))
     "Invariant Initially Valid":
         \replacewith (==> inv & variant >= 0 );
     "Body Preserves Invariant and Decreases Variant":
         \replacewith (==> #atPreEqs(anon1) -> {#v2:=variant || #v3:=wsOneIt || #oldHS:=#attribute:consumed(#mem)
						}#introNewAnonUpdate (#modifies, inv & variant >= 0 & variant <= #v2  ->
               {#v4:=variant} {#attribute:consumed(#mem):=#oldHS+((#v2-#v4)*#v3)}{#oldHS:=#attribute:consumed(#mem)}(
			\[{ method-frame(#t(<currentMemoryArea>=#mem, this=#e0)):{#typeof(#e) #v1 = #e;} }\]#v1=TRUE ->
			#whileInvRule(\<{.. while (#e) #s ...}\>post,
                               inv & #attribute:consumed(#mem)-#oldHS<=#v3 & variant < #v4 & variant >= 0)),anon1));
     "Use Case":
         \replacewith (==> {#v2:=variant*wsOneIt|| #oldHS:=#attribute:consumed(#mem) }#introNewAnonUpdate(#modifies, inv ->
                            (\[{ method-frame(#t(<currentMemoryArea>=#mem, this=#e0)):{#typeof(#e) #v1 = #e;} }\]
                         (#v1=FALSE -> {#attribute:consumed(#mem):=#oldHS+#v2}\<{..   ...}\>post)),anon2))

    \heuristics (loop_invariant, loop_invariant_proposal, mem_loop)
    \displayname "while_invariant_with_variant_dec_and_working_space"
    }; 

/*  while_inv_diamond_dec_ws1 { \find (==> \<{.#t(<currentMemoryArea>=#mem)..  while(#e) #s ...}\>post)
         \varcond(\new(#v1, boolean), \new(#v2, jint), \new(#v3, jint), \new(#v4, jint),
                  \new(#oldHS, jint),
                  \new(anon1,\dependingOnMod(#modifies)),
          	  \new(anon2,\dependingOnMod(#modifies)),
                  \new(anon1, \dependingOn(post)),
                  \new(anon1, \dependingOn(inv)),
                  \new(anon1, \dependingOn(variant)),
                  \new(anon2, \dependingOn(post)),
                  \new(anon2, \dependingOn(inv)),
                  \new(anon2, \dependingOn(variant)))
     "Invariant Initially Valid":
         \replacewith (==> inv & variant >= 0 );
     "Body Preserves Invariant and Decreases Variant":
         \replacewith (==> #atPreEqs(anon1) -> {#v2:=variant || #v3:=wsOneIt || #oldHS:=#attribute:consumed(#mem)
						}#introNewAnonUpdate (#modifies, inv & variant >= 0 &
		#locDepFunc(anon1, \[{.. while (#e) #s ...}\]post)  ->
               {#v4:=variant} {#attribute:consumed(#mem):=#oldHS+((#v2-#v4)*#v3)}{#oldHS:=#attribute:consumed(#mem)}(
			\[{ method-frame(#t(<currentMemoryArea>=#mem)):{#typeof(#e) #v1 = #e;} }\]#v1=TRUE ->
				#whileInvRule(\<{.. while (#e) #s ...}\>post,
                               inv & #attribute:consumed(#mem)-#oldHS<=#v3 & variant < #v4 & variant >= 0 & 
				#locDepFunc(anon1, \[{.. while (#e) #s ...}\]post))),anon1));
     "Use Case":
         \replacewith (==> {#v2:=variant*wsOneIt || #oldHS:=#attribute:consumed(#mem) }#introNewAnonUpdate(#modifies, 
			{#attribute:consumed(#mem):=#oldHS+#v2}(inv ->
                            \[{ method-frame(#t(<currentMemoryArea>=#mem)):{#typeof(#e) #v1 = #e;} }\]
                         (#v1=FALSE -> \<{..   ...}\>post)),anon2))
    \heuristics (loop_invariant, loop_invariant_proposal, mem_loop)
    \displayname "while_invariant_with_variant_dec_and_working_space"
    }; 

  while_inv_diamond_dec_ws2 { \find (==> \<{.#t(<currentMemoryArea>=#mem, this=#e0)..  while(#e) #s ...}\>post)
         \varcond(\new(#v1, boolean), \new(#v2, jint), \new(#v3, jint), \new(#v4, jint),
                  \new(#oldHS, jint),
                  \new(anon1,\dependingOnMod(#modifies)),
          	  \new(anon2,\dependingOnMod(#modifies)),
                  \new(anon1, \dependingOn(post)),
                  \new(anon1, \dependingOn(inv)),
                  \new(anon1, \dependingOn(variant)),
                  \new(anon2, \dependingOn(post)),
                  \new(anon2, \dependingOn(inv)),
                  \new(anon2, \dependingOn(variant)))
     "Invariant Initially Valid":
         \replacewith (==> inv & variant >= 0 );
     "Body Preserves Invariant and Decreases Variant":
         \replacewith (==> #atPreEqs(anon1) -> {#v2:=variant || #v3:=wsOneIt || #oldHS:=#attribute:consumed(#mem)
						}#introNewAnonUpdate (#modifies, inv & variant >= 0 & 
		#locDepFunc(anon1, \[{.. while (#e) #s ...}\]post) ->
               {#v4:=variant} {#attribute:consumed(#mem):=#oldHS+((#v2-#v4)*#v3)}{#oldHS:=#attribute:consumed(#mem)}(
			\[{ method-frame(#t(<currentMemoryArea>=#mem, this=#e0)):{#typeof(#e) #v1 = #e;} }\]#v1=TRUE ->
			#whileInvRule(\<{.. while (#e) #s ...}\>post,
                               inv & #attribute:consumed(#mem)-#oldHS<=#v3 & variant < #v4 & variant >= 0 & 
				#locDepFunc(anon1, \[{.. while (#e) #s ...}\]post))),anon1));
     "Use Case":
         \replacewith (==> {#v2:=variant*wsOneIt|| #oldHS:=#attribute:consumed(#mem) }#introNewAnonUpdate(#modifies, 
			{#attribute:consumed(#mem):=#oldHS+#v2}( inv ->
                            \[{ method-frame(#t(<currentMemoryArea>=#mem, this=#e0)):{#typeof(#e) #v1 = #e;} }\]
                         (#v1=FALSE -> \<{..   ...}\>post)),anon2))
    \heuristics (loop_invariant, loop_invariant_proposal, mem_loop)
    \displayname "while_invariant_with_variant_dec_and_working_space"
    };*/ 
}

// below identical to normal rules, but we need to consider in additon the extended execution contexts when matching 

\rules(programRules:Java, rtsj:on) {

  assignment_write_array_this_access_normalassign_rtsj{
		\find (\modality{#normalassign}{.#t(<currentMemoryArea>=#mem, this=#v).. this[#se]=#se0; ...}\endmodality(post))
		"Normal Execution":
			\replacewith(( lt(#se,#lengthReference(#v)) & lt(-1,#se)) ->   
			{#v[#se]:=#se0}\modality{#normalassign}{.. ...}\endmodality(post))
	         \heuristics(simplify_prog, simplify_prog_subset)
		 \displayname "assignment"
  };

  arrayInitialisation_rtsj {
	\find (\modality{#normalassign}{.#t(<currentMemoryArea>=#mem, this=#a).. for (int #v=#se; #v<this.#length; #v++) this[#v] = #lit; ...}\endmodality(post))
	\replacewith({\for iv; \if (geq(iv,#se) & lt(iv,#a.#length)) #a[iv] := #lit}\modality{#normalassign}{..  ...}\endmodality(post))
	\displayname "arrayInitialisation"
	\heuristics(simplify)
	\oldname "init_array_for_loop_"
  };

  arrayInitialisationTRA_rtsj {
        \find (\modality{#traonly}{.#t(<currentMemoryArea>=#mem, this=#a).. for (int #v=#se; #v<this.#length; #v++) this[#v] = #lit; ...}\endmodality(post))
	\replacewith({\for iv; \if (geq(iv,#se) & lt(iv,#a.#length)) #a[iv]^(#transactionCounter) := #lit}\modality{#traonly}{..  ...}\endmodality(post))
	\heuristics(simplify)	
        \displayname "arrayInitialisation"
	\oldname "init_array_for_loop_tra"
  };

  arrayInitialisationTout_rtsj {
        \find (\throughout{.#t(<currentMemoryArea>=#mem, this=#a).. for (int #v=#se; #v<this.#length; #v++) this[#v] = #lit; ...}\endmodality(post))
	\varcond(\notFreeIn(iv2, post))
	\replacewith(
	   \forall iv2; ((iv2 >= #se & iv2 <= #a.#length) -> 
             {\for iv; \if (iv >= #se & iv < iv2) #a[iv] := #lit}post) &
	        {\for iv; \if (geq(iv,#v) & lt(iv,#a.#length)) #a[iv] := #lit}
                   (post -> \throughout{..  ...}\endmodality(post)))
	\heuristics(simplify)	
	\displayname "init_array_for_loop"
  };


}

		 
		 
\rules(programRules:Java, rtsj:on, throughout:toutOn) {		 
		 
		 // skip index check as the case below can only happen in an implicit method
  assignToutSaveThisArray_rtsj {
 		\find ( \throughout{.#t(<currentMemoryArea>=#mem, this=#v).. this[#se]=#se0; ...}\endmodality(post) )
                 \replacewith(( lt(#se,#lengthReference(#v)) & lt(-1,#se)) -> 
                               post & (post -> {#v[#se]:=#se0}\throughout{.. ...}\endmodality(post)))
 	        \heuristics(simplify_prog, simplify_prog_subset)
 		\displayname "assignment"
		\oldname "assignment_write_array_this_access_throughout"};
}


\rules(programRules:Java, rtsj:on, transactions:transactionsOn,transactionAbort:abortOn,javacard:jcOn) {
 assignTRA_rtsj  { \find (\modality{#traonly}{.. #loc = #se; ...}\endmodality(post)) 
              \replacewith ({#shadowed(#loc):= #shadowed(#se)}\modality{#traonly}{.. ...}\endmodality(post)) 
	      \heuristics(simplify_prog, simplify_prog_subset)
              \displayname "assignment"
	      \oldname "assignment_traonly"
 };
}		 