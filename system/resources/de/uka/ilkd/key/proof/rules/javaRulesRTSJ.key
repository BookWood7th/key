\include ruleSetsDeclarations;
\include rtsjFuncPreds;

\sorts{
  \generic G;
  \generic H;
  \generic J \extends G;
}

\schemaVariables {
 \modalOperator { diamond, box, throughout,
                             diamond_trc, box_trc, throughout_trc,
                             diamond_tra, box_tra, throughout_tra,
			     diamond_susp, box_susp, throughout_susp } #allmodal;
 \modalOperator { diamond, box, diamond_trc, box_trc, throughout_trc } #normalassign;
 \modalOperator { diamond_tra, box_tra, throughout_tra, diamond_susp, box_susp, throughout_susp } #traonly;
 \modalOperator { diamond, box, throughout, diamond_trc, box_trc, throughout_trc } #allbuttra;
 
 \program ImplicitTransactionCounter #transactionCounterSV;

 \formula post, inv, ws;
 \program Type #t, #t2 ;
 
 \term G q ;
 \skolemTerm G queryValue, sk ;

 \program ArrayLength #length ;
 

 \program SimpleExpression #se, #se0, #se1 ;
 
 \program LeftHandSide #lhs, #lhs0, #lhs1, #lhs2 ;
 \program LeftHandSide #attribute ;
 \program StaticVariable #sv, #sv0, #sv1 ;

 \program Variable #v, #v0, #v1, #v2, #v3, #v4, #v5, #v6, #mem, #boolv, #a, #a0, #a1, #oldHS, #oldHSCons, #oldHSReent;

 \program Statement #s, #s0, #s1 ;
 \program Expression #e, #e0, #e1, #e2, #e3 ;
 
 \program[list] Expression #elist ;
 \program[list] SimpleExpression #selist ;
 
 \program NonModelMethodBody #mb;
 \program MethodName #mn;
 \program ScopeName #scope;
 \program PureMethodBody #pmb;

 \program ExecutionContext #ex, #ex1; 

 \location[list] #modifies;
 \formula anon1, anon2, anon3;
 
 \program NonStringLiteral #lit;
 \program StringLiteral #slit;

 \variables int iv, iv2, iv3;
 \term int idx;
 \term int wsOneIt, wsOneItCons, wsOneItReent, heapSpace; 

 // generic sorts
 \term G array, variant ;
 \term H obj ;

 \variables G x ;
 
}

\rules(programRules:Java, rtsj:on) {

  assignment_instance_field_of_this_primitive  { \find (\modality{#normalassign}{.. #v = #se; ...}\endmodality(post)) 
		\varcond(\not\isReference(\typeof(#v)), \not\static(#v))
                \replacewith ({#v:= #se}\modality{#normalassign}{.. ...}\endmodality(post)) 
	        \heuristics(simplify_prog, simplify_prog_subset)
                \displayname "assignment"
		\oldname "assignment_normalassign"};

  // constant case cannot occur as no static initilisation handling happens
  assignment_write_static_attribute_with_variable_prefix {
	\find (\modality{#normalassign}{.. @(#v.#sv) = #se; ...}\endmodality(post))
	\varcond(\new(#v3, \typeof(#se)))
	"Normal Case": \replacewith({#sv := #se} \modality{#normalassign}{.. ...}\endmodality(post))
	\add({#v3:=#se}immortal(#attribute:stack(#memoryArea(#v3))) | #se=null ==>);
	"Illegal Assignment Error": \replacewith(\modality{#normalassign}{..throw new javax.realtime.IllegalAssignmentError(); ...}\endmodality(post))
	\add(==> {#v3:=#se}immortal(#attribute:stack(#memoryArea(#v3))) | #se=null)
        \heuristics(simplify_prog, simplify_prog_subset)
        \displayname "active_attribute_access"
  };

  assignment_write_static_attribute_reference {
	\find (\modality{#normalassign}{.. @(#sv) = #se; ...}\endmodality(post))\sameUpdateLevel
	 \varcond(\isReference(\typeof(#sv)), \new(#v3, \typeof(#se)))
	"Normal Case (#se=null | #se in immortal memory)": 
	\replacewith({#sv := #se} \modality{#normalassign}{.. ...}\endmodality(post))
	\add ({#v3:=#se}immortal(#attribute:stack(#memoryArea(#v3))) | #se=null ==>);	
	"Illegal Assignment Error":
	\replacewith(\modality{#normalassign}{.. throw new javax.realtime.IllegalAssignmentError(); ...}\endmodality(post))
	\add (==> {#v3:=#se}immortal(#attribute:stack(#memoryArea(#v3))) | #se=null)
        \heuristics(simplify_prog, simplify_prog_subset)
        \displayname "assignment"
  };



}

\rules(programRules:Java, nullPointerPolicy:nullCheck, rtsj:on) {

  assignment_to_reference_array_component { 
                 \find (\modality{#normalassign}{.. #v[#se]=#se0; ...}\endmodality(post)) \sameUpdateLevel
		 \varcond(\isReferenceArray(#v), \notFreeIn(iv2, #se0))
		 "Normal Execution (#v != null)":
			\replacewith({#v[#se]:=#se0} \modality{#normalassign}{.. ...}\endmodality(post))
			\add (!(#v=null) & lt(#se, #lengthReference(#v)) & geq(#se,0) & arrayStoreValid(#v, #se0) &
			      {#v[#se]:=#se0}outerScope(#attribute:stack(#memoryArea(#v[#se])), #attribute:stack(#memoryArea(#v))) ==>);
		 "Null Reference (#v = null)":
			\replacewith(\modality{#normalassign}{.. throw new java.lang.NullPointerException(); ...}\endmodality(post))
			\add (#v=null ==>);
		 "Index Out of Bounds (#v != null, but #se Out of Bounds!)":
			\replacewith(\modality{#normalassign}{.. throw new java.lang.ArrayIndexOutOfBoundsException(); ...}\endmodality(post))
			\add (!(#v=null) & (leq(#lengthReference(#v), #se) | lt(#se,0)) ==>);
                 "Array Store Exception (incompatible dynamic element type of #v and #se0)":
                        \replacewith(\modality{#normalassign}{.. throw new java.lang.ArrayStoreException(); ...}\endmodality(post))
                        \add (!(#v=null) & lt(#se, #lengthReference(#v)) & geq(#se,0) & !arrayStoreValid(#v, #se0) ==>);
		 "Illegal Assignment Error (#v not allocated in the same or an inner scope relative to #se0)":
			\replacewith(\modality{#normalassign}{.. throw new javax.realtime.IllegalAssignmentError(); ...}\endmodality(post))
                        \add (!(#v=null) & lt(#se, #lengthReference(#v)) & geq(#se,0) & arrayStoreValid(#v, #se0) & !(#se0=null) &
			      !{#v[#se]:=#se0}outerScope(#attribute:stack(#memoryArea(#v[#se])), #attribute:stack(#memoryArea(#v)))
				==>)
	         \heuristics(simplify_prog, simplify_prog_subset)
		 \displayname "assignment"
};

assignment_array4{\find (\modality{#normalassign}{.#t(#se0,#e).. #v = #v0[#se]; ...}\endmodality(post)) \sameUpdateLevel
		 \varcond(\not\isLocalVariable(#v), \isReferenceArray(#v0))
		"Normal Execution (#v0 != null)":
		   \replacewith({#v:=#v0[#se]}\modality{#normalassign}{.. ...}\endmodality(post))
		   \add (outerScope(#attribute:stack(#memoryArea(#v0[#se])), #attribute:stack(#memoryArea(#e))) | #v0[#se]=null ==> 
			 (#v0=null) | leq(#lengthReference(#v0), #se) | lt(#se,0)); 
		"Null Reference (#v0 = null)":
		   \replacewith(\modality{#normalassign}{.#t(#se0,#e)..
			throw new java.lang.NullPointerException();
			    ...}\endmodality(post))
	           \add (#v0=null ==>);	

		"Index Out of Bounds (#v0 != null, but #se Out of Bounds!)":
	  	   \replacewith(\modality{#normalassign}{.#t(#se0,#e)..
			throw new java.lang.ArrayIndexOutOfBoundsException();
		    ...}\endmodality(post))
		   \add (!(#v0=null) & (leq(#lengthReference(#v0), #se) | lt(#se,0)) ==>);
		"Illegal Assignment Error (right-hand side not in outer scope)":
		   \replacewith(\modality{#normalassign}{.#t(#se0,#e).. throw new javax.realtime.IllegalAssignmentError(); ...}\endmodality(post))
		   \add (==> outerScope(#attribute:stack(#memoryArea(#v0[#se])), #attribute:stack(#memoryArea(#e))) | #v0[#se]=null |
				(#v0=null) | leq(#lengthReference(#v0), #se) | lt(#se,0))
//				#memoryArea(#v0[#se]) = #attribute:stack(#attribute:stack(#se0))[0]	
    	         \heuristics(simplify_prog, simplify_prog_subset)
		 \displayname "assignment"};

assignment_write_attribute_reference { 
		\find (\modality{#normalassign}{..#v.#a=#se;...}\endmodality(post)) \sameUpdateLevel
	        \varcond(\not \static(#a), \not\parentScope(#a), \isReference(\typeof(#se)), \new(#v3, \typeof(#a)))
		"Normal Execution (#v != null)":
		      \replacewith({#v.#a := #se}\modality{#normalassign}{.. ...}\endmodality(post))
		      \add ({#v3:=#se}outerScope(#attribute:stack(#memoryArea(#v3)), #attribute:stack(#memoryArea(#v))) | #se=null ==>(#v=null));
		"Null Reference (#v = null)":
		      \replacewith(\modality{#normalassign}{..throw new java.lang.NullPointerException();...}\endmodality(post))
		      \add (#v=null ==>);	 
		"Illegal Assignment Error (right-hand side not in outer scope)":
		   \replacewith(\modality{#normalassign}{.. throw new javax.realtime.IllegalAssignmentError(); ...}\endmodality(post))
		   \add (==> {#v3:=#se}outerScope(#attribute:stack(#memoryArea(#v3)), #attribute:stack(#memoryArea(#v))) | 
			 #v=null | #se=null)
		   \heuristics(simplify_prog, simplify_prog_subset)
		   \displayname "assignment"};

assignment_write_attribute_parent_reference { 
		\find (\modality{#normalassign}{..#v.#a=#se;...}\endmodality(post)) \sameUpdateLevel
	        \varcond(\not \static(#a), \parentScope(#a), \isReference(\typeof(#se)), \new(#v3, \typeof(#a)))
		"Normal Execution (#v != null)":
		      \replacewith({#v.#a := #se}\modality{#normalassign}{.. ...}\endmodality(post))
		      \add ({#v3:=#se}outerScope(#attribute:stack(#memoryArea(#v3)), #attribute:stack(#memoryArea(#v))) | #se=null ==>(#v=null));
		"Null Reference (#v = null)":
		      \replacewith(\modality{#normalassign}{..throw new java.lang.NullPointerException();...}\endmodality(post))
		      \add (#v=null ==>)	 
		   \heuristics(simplify_prog, simplify_prog_subset)
		   \displayname "assignment"};

/*assignment_write_attribute_reference { 
		\find (\modality{#normalassign}{..#v.#a=#se;...}\endmodality(post)) \sameUpdateLevel
	        \varcond(\not \static(#a), \isReference(\typeof(#se)), \new(#v3, \typeof(#a)))
		"Normal Execution (#v != null)":
		      \replacewith({#v.#a := #se}\modality{#normalassign}{.. ...}\endmodality(post))
		      \add ({#v3:=#se}outerScope(#attribute:stack(#memoryArea(#v3)), #attribute:stack(#memoryArea(#v))) | #se=null 
				==>(#v=null));
		"Null Reference (#v = null)":
		      \replacewith(\modality{#normalassign}{..throw new java.lang.NullPointerException();...}\endmodality(post))
		      \add (#v=null ==>);	 
		"Illegal Assignment Error (right-hand side not in outer scope)":
		   \replacewith(\modality{#normalassign}{.. throw new javax.realtime.IllegalAssignmentError(); ...}\endmodality(post))
		   \add (==> {#v3:=#se}outerScope(#attribute:stack(#memoryArea(#v3)), #attribute:stack(#memoryArea(#v))) | 
			 #v=null | #se=null )
		   \heuristics(simplify_prog, simplify_prog_subset)
		   \displayname "assignment"};*/



}



\rules(programRules:Java, nullPointerPolicy:nullCheck, rtsj:on, perc:on) {

assignment_array4_perc{\find (\modality{#normalassign}{.#t(#se0,#e2,#e3,#e).. #v = #v0[#se]; ...}\endmodality(post)) \sameUpdateLevel
		 \varcond(\not\isLocalVariable(#v), \isReferenceArray(#v0))
		"Normal Execution (#v0 != null)":
		   \replacewith({#v:=#v0[#se]}\modality{#normalassign}{.. ...}\endmodality(post))
		   \add (outerScope(#attribute:stack(#memoryArea(#v0[#se])), #attribute:stack(#memoryArea(#e))) | #v0[#se]=null ==> 
			 (#v0=null) | leq(#lengthReference(#v0), #se) | lt(#se,0)); 
		"Null Reference (#v0 = null)":
		   \replacewith(\modality{#normalassign}{.#t(#se0,#e2,#e3,#e)..
			throw new java.lang.NullPointerException();
			    ...}\endmodality(post))
	           \add (#v0=null ==>);	

		"Index Out of Bounds (#v0 != null, but #se Out of Bounds!)":
	  	   \replacewith(\modality{#normalassign}{.#t(#se0,#e2,#e3,#e)..
			throw new java.lang.ArrayIndexOutOfBoundsException();
		    ...}\endmodality(post))
		   \add (!(#v0=null) & (leq(#lengthReference(#v0), #se) | lt(#se,0)) ==>);
		"Illegal Assignment Error (right-hand side not in outer scope)":
		   \replacewith(\modality{#normalassign}{.#t(#se0,#e2,#e3,#e).. throw new javax.realtime.IllegalAssignmentError(); ...}\endmodality(post))
		   \add (==> outerScope(#attribute:stack(#memoryArea(#v0[#se])), #attribute:stack(#memoryArea(#e))) | #v0[#se]=null |
				(#v0=null) | leq(#lengthReference(#v0), #se) | lt(#se,0))
    	         \heuristics(simplify_prog, simplify_prog_subset)
		 \displayname "assignment"};
}

\rules(programRules:Java, rtsj:on, perc:on) {

  assignment_instance_field_of_this_reference_perc  { \find (\modality{#normalassign}{.#t(#e1,#e2,#e3,#e).. #v = #se; ...}\endmodality(post)) \sameUpdateLevel
		\varcond(\isReference(\typeof(#v)), \not\static(#v), \not\parentScope(#v), \not\isLocalVariable(#v), \new(#v3, \typeof(#v)))
                "Normal Case": \replacewith ({#v := #se}\modality{#normalassign}{.. ...}\endmodality(post))
		\add({#v3:=#se}outerScope(#attribute:stack(#memoryArea(#v3)), #attribute:stack(#memoryArea(#e))) | #se=null ==>);
		"Illegal Assignment Error":
		\replacewith (\modality{#normalassign}{.. throw new javax.realtime.IllegalAssignmentError(); ...}\endmodality(post))
		\add(==> {#v3:=#se}outerScope(#attribute:stack(#memoryArea(#v3)), #attribute:stack(#memoryArea(#e))) | #se=null )
	        \heuristics(simplify_prog, simplify_prog_subset)
                \displayname "assignment"
		\oldname "assignment_normalassign"};

  assignment_instance_field_parent_of_this_reference_perc  { \find (\modality{#normalassign}{.#t(#e1,#e2,#e3,#e).. #v = #se; ...}\endmodality(post)) \sameUpdateLevel
		\varcond(\isReference(\typeof(#v)), \not\static(#v), \parentScope(#v), \not\isLocalVariable(#v), \new(#v3, \typeof(#v)))
                \replacewith ({#v := #se}\modality{#normalassign}{.. ...}\endmodality(post))
		\add({#v3:=#se}outerScope(#attribute:stack(#memoryArea(#v3)), #attribute:stack(#memoryArea(#e))) | #se=null ==>)
	        \heuristics(simplify_prog, simplify_prog_subset)
                \displayname "assignment"
		\oldname "assignment_normalassign"};

}

\rules(programRules:Java, rtsj:on, perc:off) {

  assignment_instance_field_of_this_reference_rtsj  { \find (\modality{#normalassign}{.#t(#e1,#e).. #v = #se; ...}\endmodality(post)) \sameUpdateLevel
		\varcond(\isReference(\typeof(#v)), \not\static(#v), \not\parentScope(#v), \not\isLocalVariable(#v), \new(#v3, \typeof(#v)))
                "Normal Case": \replacewith ({#v := #se}\modality{#normalassign}{.. ...}\endmodality(post))
		\add({#v3:=#se}outerScope(#attribute:stack(#memoryArea(#v3)), #attribute:stack(#memoryArea(#e))) | #se=null ==>);
		"Illegal Assignment Error":
		\replacewith (\modality{#normalassign}{.. throw new javax.realtime.IllegalAssignmentError(); ...}\endmodality(post))
		\add(==> {#v3:=#se}outerScope(#attribute:stack(#memoryArea(#v3)), #attribute:stack(#memoryArea(#e))) | #se=null )
	        \heuristics(simplify_prog, simplify_prog_subset)
                \displayname "assignment"
		\oldname "assignment_normalassign"};

  assignment_instance_field_parent_of_this_reference_rtsj  { \find (\modality{#normalassign}{.#t(#e1,#e).. #v = #se; ...}\endmodality(post)) \sameUpdateLevel
		\varcond(\isReference(\typeof(#v)), \not\static(#v), \parentScope(#v), \not\isLocalVariable(#v), \new(#v3, \typeof(#v)))
                \replacewith ({#v := #se}\modality{#normalassign}{.. ...}\endmodality(post))
		\add({#v3:=#se}outerScope(#attribute:stack(#memoryArea(#v3)), #attribute:stack(#memoryArea(#e))) | #se=null ==>)
	        \heuristics(simplify_prog, simplify_prog_subset)
                \displayname "assignment"
		\oldname "assignment_normalassign"};

}

\rules(programRules:Java, rtsj:off, perc:on) {

  while_inv_diamond_dec_ws1_demo { \find (==> \<{.#t(#mem, #e1, #e2)..  while(#e) #s ...}\>post)
         \varcond(\new(#v1, boolean), \new(#v2, jint), \new(#v3, jint), \new(#v4, jint), \new(#v5, jint),
                  \new(#oldHS, jint), \new(#oldHSCons, jint),
                  \new(anon1,\dependingOnMod(#modifies)),
          	  \new(anon2,\dependingOnMod(#modifies)),
                  \new(anon1, \dependingOn(post)),
                  \new(anon1, \dependingOn(inv)),
                  \new(anon1, \dependingOn(variant)),
                  \new(anon2, \dependingOn(post)),
                  \new(anon2, \dependingOn(inv)),
                  \new(anon2, \dependingOn(variant)))
     "Invariant Initially Valid":
         \replacewith (==> inv & variant >= 0 );
     "Body Preserves Invariant and Decreases Variant":
         \replacewith (==> #atPreEqs(anon1) -> #wsAtPre(ws, #consumedAtPre(ws, {#v2:=variant || #v3:=wsOneIt || #oldHS:=#attribute:consumed(#mem) || 
						#v5:=wsOneItCons || #oldHSCons:=#attribute:consumed(#e2)
						}#introNewAnonUpdate (#modifies, inv & variant >= 0 & variant <= #v2  ->
               {#v4:=variant} #consumedLoopUpdate(ws, (#v2-#v4), {#attribute:consumed(#mem):=#oldHS+((#v2-#v4)*#v3) || #attribute:consumed(#e2):=#oldHSCons+((#v2-#v4)*#v5)}
			#consumedAtPre(ws, {#oldHS:=#attribute:consumed(#mem) || #oldHSCons:=#attribute:consumed(#e2)}(
			\[{ method-frame(#t(#mem,#e1,#e2)):{#typeof(#e) #v1 = #e;} }\]#v1=TRUE ->
				#whileInvRule(\<{.. while (#e) #s ...}\>post,
                               inv & #attribute:consumed(#mem)-#oldHS<=#v3 & #attribute:consumed(#e2)-#oldHSCons<=#v5 & #consumedInv(ws) &
				variant < #v4 & variant >= 0 )))),anon1))));
     "Use Case":
         \replacewith (==> #wsAtPre(ws, #consumedAtPre(ws, {#v2:=variant*wsOneIt || #v4:=variant ||
			    #v3:=variant*wsOneItCons ||
			    #oldHS:=#attribute:consumed(#mem) || 
       			    #oldHSCons:=#attribute:consumed(#e2) }#introNewAnonUpdate(#modifies, inv ->
                            (\[{ method-frame(#t(#mem, #e1, #e2)):{#typeof(#e) #v1 = #e;} }\]
                         #consumedLoopUpdate(ws, #v4, (#v1=FALSE -> {#attribute:consumed(#mem):=#oldHS+#v2 || #attribute:consumed(#e2):=#oldHSCons+#v3 }\<{..   ...}\>post))),anon2))))

    \heuristics (loop_invariant, loop_invariant_proposal, mem_loop)
    \displayname "while_invariant_with_variant_dec_and_working_space"
    }; 

  while_inv_diamond_dec_ws2_demo { \find (==> \<{.#t(#mem, #e1, #e2, #e0)..  while(#e) #s ...}\>post)
         \varcond(\new(#v1, boolean), \new(#v2, jint), \new(#v3, jint), \new(#v4, jint), \new(#v5, jint), \new(#v6, jint),
                  \new(#oldHS, jint), \new(#oldHSCons, jint), \new(#oldHSReent, jint),
                  \new(anon1,\dependingOnMod(#modifies)),
          	  \new(anon2,\dependingOnMod(#modifies)),
                  \new(anon1, \dependingOn(post)),
                  \new(anon1, \dependingOn(inv)),
                  \new(anon1, \dependingOn(variant)),
                  \new(anon2, \dependingOn(post)),
                  \new(anon2, \dependingOn(inv)),
                  \new(anon2, \dependingOn(variant)))
     "Invariant Initially Valid":
         \replacewith (==> inv & variant >= 0 );
     "Body Preserves Invariant and Decreases Variant":
         \replacewith (==> #atPreEqs(anon1) -> #wsAtPre(ws, #consumedAtPre(ws, {#v2:=variant || #v3:=wsOneIt || #oldHS:=#attribute:consumed(#mem) ||
						#v5:=wsOneItCons || #oldHSCons:=#attribute:consumed(#e2) ||
						#v6:=wsOneItReent || #oldHSReent:=#attribute:consumed(#reentrantScope(#e0))
						}#introNewAnonUpdate (#modifies, inv & variant >= 0 & variant <= #v2  ->
               {#v4:=variant} #consumedLoopUpdate(ws, (#v2-#v4), {#attribute:consumed(#mem):=#oldHS+((#v2-#v4)*#v3) || 
			       #attribute:consumed(#e2):=#oldHSCons+((#v2-#v4)*#v5) ||
			       #attribute:consumed(#reentrantScope(#e0)):=#oldHSReent+((#v2-#v4)*#v6)}
			#consumedAtPre(ws, {#oldHS:=#attribute:consumed(#mem) || #oldHSCons:=#attribute:consumed(#e2) || #oldHSReent:=#attribute:consumed(#reentrantScope(#e0))}(
			\[{ method-frame(#t(#mem, #e1, #e2, #e0)):{#typeof(#e) #v1 = #e;} }\]#v1=TRUE ->
			#whileInvRule(\<{.. while (#e) #s ...}\>post,
                               inv & #attribute:consumed(#mem)-#oldHS<=#v3 & #attribute:consumed(#e2)-#oldHSCons<=#v5 & #consumedInv(ws) &
				#attribute:consumed(#reentrantScope(#e0))-#oldHSReent<=#v6 &
				variant < #v4 & variant >= 0)))),anon1))));
     "Use Case":
         \replacewith (==> #wsAtPre(ws, #consumedAtPre(ws, {#v2:=variant*wsOneIt  || 
			    #v3:=variant*wsOneItCons ||
			    #v4:=variant*wsOneItReent ||
			    #v5:=variant ||
			    #oldHS:=#attribute:consumed(#mem) || 
       			    #oldHSCons:=#attribute:consumed(#e2) ||
			    #oldHSReent:=#attribute:consumed(#reentrantScope(#e0))
 			}#introNewAnonUpdate(#modifies, inv ->
                            (\[{ method-frame(#t(#mem, #e1, #e2, #e0)):{#typeof(#e) #v1 = #e;} }\]
                         #consumedLoopUpdate(ws, #v5, (#v1=FALSE -> {#attribute:consumed(#mem):=#oldHS+#v2 || #attribute:consumed(#e2):=#oldHSCons+#v3 ||
				#attribute:consumed(#reentrantScope(#e0)):=#oldHSReent+#v4}\<{..   ...}\>post))),anon2))))

    \heuristics (loop_invariant, loop_invariant_proposal, mem_loop)
    \displayname "while_invariant_with_variant_dec_and_working_space"
    }; 

}

\rules(programRules:Java, perc:off, memory:on) {

  while_inv_diamond_dec_ws1_demo { \find (==> \<{.#t(#mem)..  while(#e) #s ...}\>post)
         \varcond(\new(#v1, boolean), \new(#v2, jint), \new(#v3, jint), \new(#v4, jint),
                  \new(#oldHS, jint),
                  \new(anon1,\dependingOnMod(#modifies)),
          	  \new(anon2,\dependingOnMod(#modifies)),
                  \new(anon1, \dependingOn(post)),
                  \new(anon1, \dependingOn(inv)),
                  \new(anon1, \dependingOn(variant)),
                  \new(anon2, \dependingOn(post)),
                  \new(anon2, \dependingOn(inv)),
                  \new(anon2, \dependingOn(variant)))
     "Invariant Initially Valid":
         \replacewith (==> inv & variant >= 0 );
     "Body Preserves Invariant and Decreases Variant":
         \replacewith (==> #atPreEqs(anon1) -> {#v2:=variant || #v3:=wsOneIt || #oldHS:=#attribute:consumed(#mem)
						}#introNewAnonUpdate (#modifies, inv & variant >= 0  ->
               {#v4:=variant} {#attribute:consumed(#mem):=#oldHS+((#v2-#v4)*#v3)}{#oldHS:=#attribute:consumed(#mem)}(
			\[{ method-frame(#t(#mem)):{#typeof(#e) #v1 = #e;} }\]#v1=TRUE ->
				#whileInvRule(\<{.. while (#e) #s ...}\>post,
                               inv & #attribute:consumed(#mem)-#oldHS<=#v3 & variant < #v4 & variant >= 0 )),anon1));
     "Use Case":
         \replacewith (==> {#v2:=variant*wsOneIt || #oldHS:=#attribute:consumed(#mem) }#introNewAnonUpdate(#modifies, inv ->
                            (\[{ method-frame(#t(#mem)):{#typeof(#e) #v1 = #e;} }\]
                         (#v1=FALSE -> {#attribute:consumed(#mem):=#oldHS+#v2}\<{..   ...}\>post)),anon2))

    \heuristics (loop_invariant, loop_invariant_proposal, mem_loop)
    \displayname "while_invariant_with_variant_dec_and_working_space"
    }; 

  while_inv_diamond_dec_ws2_demo { \find (==> \<{.#t(#mem, #e0)..  while(#e) #s ...}\>post)
         \varcond(\new(#v1, boolean), \new(#v2, jint), \new(#v3, jint), \new(#v4, jint),
                  \new(#oldHS, jint),
                  \new(anon1,\dependingOnMod(#modifies)),
          	  \new(anon2,\dependingOnMod(#modifies)),
                  \new(anon1, \dependingOn(post)),
                  \new(anon1, \dependingOn(inv)),
                  \new(anon1, \dependingOn(variant)),
                  \new(anon2, \dependingOn(post)),
                  \new(anon2, \dependingOn(inv)),
                  \new(anon2, \dependingOn(variant)))
     "Invariant Initially Valid":
         \replacewith (==> inv & variant >= 0 );
     "Body Preserves Invariant and Decreases Variant":
         \replacewith (==> #atPreEqs(anon1) -> {#v2:=variant || #v3:=wsOneIt || #oldHS:=#attribute:consumed(#mem)
						}#introNewAnonUpdate (#modifies, inv & variant >= 0 & variant <= #v2  ->
               {#v4:=variant} {#attribute:consumed(#mem):=#oldHS+((#v2-#v4)*#v3)}{#oldHS:=#attribute:consumed(#mem)}(
			\[{ method-frame(#t(#mem, #e0)):{#typeof(#e) #v1 = #e;} }\]#v1=TRUE ->
			#whileInvRule(\<{.. while (#e) #s ...}\>post,
                               inv & #attribute:consumed(#mem)-#oldHS<=#v3 & variant < #v4 & variant >= 0)),anon1));
     "Use Case":
         \replacewith (==> {#v2:=variant*wsOneIt|| #oldHS:=#attribute:consumed(#mem) }#introNewAnonUpdate(#modifies, inv ->
                            (\[{ method-frame(#t(#mem, #e0)):{#typeof(#e) #v1 = #e;} }\]
                         (#v1=FALSE -> {#attribute:consumed(#mem):=#oldHS+#v2}\<{..   ...}\>post)),anon2))

    \heuristics (loop_invariant, loop_invariant_proposal, mem_loop)
    \displayname "while_invariant_with_variant_dec_and_working_space"
    }; 

/*  while_inv_diamond_dec_ws1 { \find (==> \<{.#t(#mem)..  while(#e) #s ...}\>post)
         \varcond(\new(#v1, boolean), \new(#v2, jint), \new(#v3, jint), \new(#v4, jint),
                  \new(#oldHS, jint),
                  \new(anon1,\dependingOnMod(#modifies)),
          	  \new(anon2,\dependingOnMod(#modifies)),
                  \new(anon1, \dependingOn(post)),
                  \new(anon1, \dependingOn(inv)),
                  \new(anon1, \dependingOn(variant)),
                  \new(anon2, \dependingOn(post)),
                  \new(anon2, \dependingOn(inv)),
                  \new(anon2, \dependingOn(variant)))
     "Invariant Initially Valid":
         \replacewith (==> inv & variant >= 0 );
     "Body Preserves Invariant and Decreases Variant":
         \replacewith (==> #atPreEqs(anon1) -> {#v2:=variant || #v3:=wsOneIt || #oldHS:=#attribute:consumed(#mem)
						}#introNewAnonUpdate (#modifies, inv & variant >= 0 &
		#locDepFunc(anon1, \[{.. while (#e) #s ...}\]post)  ->
               {#v4:=variant} {#attribute:consumed(#mem):=#oldHS+((#v2-#v4)*#v3)}{#oldHS:=#attribute:consumed(#mem)}(
			\[{ method-frame(#t(#mem)):{#typeof(#e) #v1 = #e;} }\]#v1=TRUE ->
				#whileInvRule(\<{.. while (#e) #s ...}\>post,
                               inv & #attribute:consumed(#mem)-#oldHS<=#v3 & variant < #v4 & variant >= 0 & 
				#locDepFunc(anon1, \[{.. while (#e) #s ...}\]post))),anon1));
     "Use Case":
         \replacewith (==> {#v2:=variant*wsOneIt || #oldHS:=#attribute:consumed(#mem) }#introNewAnonUpdate(#modifies, 
			{#attribute:consumed(#mem):=#oldHS+#v2}(inv ->
                            \[{ method-frame(#t(#mem)):{#typeof(#e) #v1 = #e;} }\]
                         (#v1=FALSE -> \<{..   ...}\>post)),anon2))
    \heuristics (loop_invariant, loop_invariant_proposal, mem_loop)
    \displayname "while_invariant_with_variant_dec_and_working_space"
    }; 

  while_inv_diamond_dec_ws2 { \find (==> \<{.#t(#mem,#e2,#e3, #e0)..  while(#e) #s ...}\>post)
         \varcond(\new(#v1, boolean), \new(#v2, jint), \new(#v3, jint), \new(#v4, jint),
                  \new(#oldHS, jint),
                  \new(anon1,\dependingOnMod(#modifies)),
          	  \new(anon2,\dependingOnMod(#modifies)),
                  \new(anon1, \dependingOn(post)),
                  \new(anon1, \dependingOn(inv)),
                  \new(anon1, \dependingOn(variant)),
                  \new(anon2, \dependingOn(post)),
                  \new(anon2, \dependingOn(inv)),
                  \new(anon2, \dependingOn(variant)))
     "Invariant Initially Valid":
         \replacewith (==> inv & variant >= 0 );
     "Body Preserves Invariant and Decreases Variant":
         \replacewith (==> #atPreEqs(anon1) -> {#v2:=variant || #v3:=wsOneIt || #oldHS:=#attribute:consumed(#mem)
						}#introNewAnonUpdate (#modifies, inv & variant >= 0 & 
		#locDepFunc(anon1, \[{.. while (#e) #s ...}\]post) ->
               {#v4:=variant} {#attribute:consumed(#mem):=#oldHS+((#v2-#v4)*#v3)}{#oldHS:=#attribute:consumed(#mem)}(
			\[{ method-frame(#t(#mem, #e0)):{#typeof(#e) #v1 = #e;} }\]#v1=TRUE ->
			#whileInvRule(\<{.. while (#e) #s ...}\>post,
                               inv & #attribute:consumed(#mem)-#oldHS<=#v3 & variant < #v4 & variant >= 0 & 
				#locDepFunc(anon1, \[{.. while (#e) #s ...}\]post))),anon1));
     "Use Case":
         \replacewith (==> {#v2:=variant*wsOneIt|| #oldHS:=#attribute:consumed(#mem) }#introNewAnonUpdate(#modifies, 
			{#attribute:consumed(#mem):=#oldHS+#v2}( inv ->
                            \[{ method-frame(#t(#mem, #e0)):{#typeof(#e) #v1 = #e;} }\]
                         (#v1=FALSE -> \<{..   ...}\>post)),anon2))
    \heuristics (loop_invariant, loop_invariant_proposal, mem_loop)
    \displayname "while_invariant_with_variant_dec_and_working_space"
    };*/ 
}

\rules(programRules:Java,perc:on) {

  methodBodyExpand1 { 	
    \find (\modality{#allmodal}{.#t(#e0,#e1,#e2,#e).. #mb ...}\endmodality(post))
        \varcond(\hasSort(#e0, G), \new(sk, \dependingOn(post)),
		 \new(#v0, \typeof(#e0)), \new(#v1, \typeof(#e0)), \new(#v2, jint) )
        \replacewith (
		\<{#typeof(#e0) #v0; #typeof(#e0) #v1;}\>
		{
		 \if(#constructedScopeSpec(\<{#mb}\>true)>0 & !#externallyConstructedScope(\<{#mb}\>true)) #v2 := #constructedScopeSpec(\<{#mb}\>true) + #exactSizeScope ||
		 \if(#constructedScopeSpec(\<{#mb}\>true)=0 | #externallyConstructedScope(\<{#mb}\>true)) #v2 := 0
		}
		{
	         \if(#atLocalScope(\<{#mb}\>true) & 
		     #callerAllocResContext(\modality{#allmodal}{.#t(#e0,#e1,#e2,#e).. #mb ...}\endmodality(post))) #attribute:consumed(#e0) := #attribute:consumed(#e0) + #v2
		}
		{
                 \if(#atReentrantScope(\<{#mb}\>true)) #attribute:consumed(#reentrantScope(#e)) := #attribute:consumed(#reentrantScope(#e)) + #v2
		}
		{
		 \if(!#externallyConstructedScope(\<{#mb}\>true)) #v1 := G::<get>(#nextToCreate(#e0)) || 
	         \if(!#externallyConstructedScope(\<{#mb}\>true)) #nextToCreate(#e0) := add(#nextToCreate(#e0), 1) ||
                 \if(!#externallyConstructedScope(\<{#mb}\>true)) #created(G::<get>(#nextToCreate(#e0))) := TRUE ||
		 \if(!#externallyConstructedScope(\<{#mb}\>true)) #attribute:stack(G::<get>(#nextToCreate(#e0)+1)) := #stackForConstructedScope(\<{#mb}\>true,#e0,#e,#e1)
		}
		{
		 \for iv; \if (iv>=#nextToCreateStack & iv <= #nextToCreateStack+sk & !#noLocalScope(\<{#mb}\>true)) #created(#stackAtIndex(iv)) := TRUE ||
		 \if(#noLocalScope(\<{#mb}\>true)) #v0 := #e0 ||
		 \if(!#noLocalScope(\<{#mb}\>true)) #v0 := G::<get>(#nextToCreate(#e0)) || 
                 \if(!#noLocalScope(\<{#mb}\>true)) #nextToCreate(#e0) := add(#nextToCreate(#e0), 1) ||
                 \if(!#noLocalScope(\<{#mb}\>true)) #created(G::<get>(#nextToCreate(#e0))) := TRUE ||
		 \if(!#noLocalScope(\<{#mb}\>true)) #attribute:stack(G::<get>(#nextToCreate(#e0))) := #stackAtIndex(#nextToCreateStack+sk) ||
		 \if(!#noLocalScope(\<{#mb}\>true)) #nextToCreateStack := #nextToCreateStack+1+sk
		}
		{
		  \if(!#noLocalScope(\<{#mb}\>true)) #attribute:consumed(#v0):=0 ||
		  \if(!#noLocalScope(\<{#mb}\>true)) #attribute:size(#v0):=#localScopeSpec(\<{#mb}\>true) ||
		  \if(!#externallyConstructedScope(\<{#mb}\>true)) #attribute:consumed(#v1):=0 ||
		  \if(!#externallyConstructedScope(\<{#mb}\>true)) #attribute:size(#v1):=#constructedScopeSpec(\<{#mb}\>true)
		}
   	\if(#constructedScopeSpec(\<{#mb}\>true)>0 ->
		(( (#atLocalScope(\<{#mb}\>true) & 
             	      #callerAllocResContext(\modality{#allmodal}{.#t(#e0,#e1,#e2,#e).. #mb ...}\endmodality(post)))
	    -> #attribute:consumed(#e0)<=#attribute:size(#e0)) &
	(#atReentrantScope(\<{#mb}\>true) -> #attribute:consumed(#reentrantScope(#e)) <= #attribute:size(#reentrantScope(#e))))
	)\then(
    		#introAtPreDefs(\modality{#allmodal}{.#t(#e0,#e1,#e2,#e).. #expand-method-body-perc(#mb,#v0,#v1); ...}\endmodality(post)))
	\else(\modality{#allmodal}{.. throw javax.realtime.RealtimeSystem.oome(); ...}\endmodality(post))

)
    \add(\if(!#noLocalScope(\<{#mb}\>true))\then(outerScope(#attribute:stack(#e0),#stackAtIndex(#nextToCreateStack+sk)) & sk>=0)\else(true) ==>)
    \heuristics(method_expand) 
    \oldname "method_body_expand"
  };

  methodBodyExpand2 { 	
    \find (\modality{#allmodal}{.#t(#e0,#e1,#e2).. #mb ...}\endmodality(post))
        \varcond(\hasSort(#e0, G),  \new(sk, \dependingOn(post)), \new(#v0, \typeof(#e0)), \new(#v1, \typeof(#e0)), \new(#v2, jint) )
        \replacewith (
		\<{#typeof(#e0) #v0; #typeof(#e0) #v1;}\>
		{
		 \if(#constructedScopeSpec(\<{#mb}\>true)>0 & !#externallyConstructedScope(\<{#mb}\>true)) #v2 := #constructedScopeSpec(\<{#mb}\>true) + #exactSizeScope ||
		 \if(#constructedScopeSpec(\<{#mb}\>true)=0 | #externallyConstructedScope(\<{#mb}\>true)) #v2 := 0
		}
		{
	         \if(#atLocalScope(\<{#mb}\>true) & 
		     #callerAllocResContext(\modality{#allmodal}{.#t(#e0,#e1,#e2).. #mb ...}\endmodality(post))) #attribute:consumed(#e0) := #attribute:consumed(#e0) + #v2
		}
		{
		 \if(!#externallyConstructedScope(\<{#mb}\>true)) #v1 := G::<get>(#nextToCreate(#e0)) || 
	         \if(!#externallyConstructedScope(\<{#mb}\>true)) #nextToCreate(#e0) := add(#nextToCreate(#e0), 1) ||
                 \if(!#externallyConstructedScope(\<{#mb}\>true)) #created(G::<get>(#nextToCreate(#e0))) := TRUE ||
		 \if(!#externallyConstructedScope(\<{#mb}\>true)) #attribute:stack(G::<get>(#nextToCreate(#e0)+1)) := #stackForConstructedScope(\<{#mb}\>true,#e0,null,#e1)
		}
		{
		 \for iv; \if (iv>=#nextToCreateStack & iv <= #nextToCreateStack+sk & !#noLocalScope(\<{#mb}\>true)) #created(#stackAtIndex(iv)) := TRUE ||
		 \if(#noLocalScope(\<{#mb}\>true)) #v0 := #e0 ||
		 \if(!#noLocalScope(\<{#mb}\>true)) #v0 := G::<get>(#nextToCreate(#e0)) || 
                 \if(!#noLocalScope(\<{#mb}\>true)) #nextToCreate(#e0) := add(#nextToCreate(#e0), 1) ||
                 \if(!#noLocalScope(\<{#mb}\>true)) #created(G::<get>(#nextToCreate(#e0))) := TRUE ||
		 \if(!#noLocalScope(\<{#mb}\>true)) #attribute:stack(G::<get>(#nextToCreate(#e0))) := #stackAtIndex(#nextToCreateStack+sk) ||
		 \if(!#noLocalScope(\<{#mb}\>true)) #nextToCreateStack := #nextToCreateStack+1+sk
		}
		{	
		  \if(!#noLocalScope(\<{#mb}\>true))#attribute:consumed(#v0):=0 ||
		  \if(!#noLocalScope(\<{#mb}\>true)) #attribute:size(#v0):=#localScopeSpec(\<{#mb}\>true) ||
		  \if(!#externallyConstructedScope(\<{#mb}\>true)) #attribute:consumed(#v1):=0 ||
		  \if(!#externallyConstructedScope(\<{#mb}\>true)) #attribute:size(#v1):=#constructedScopeSpec(\<{#mb}\>true)
		}
        \if(#constructedScopeSpec(\<{#mb}\>true)>0 ->
		( (#atLocalScope(\<{#mb}\>true) & 
             	      #callerAllocResContext(\modality{#allmodal}{.#t(#e0,#e1,#e2).. #mb ...}\endmodality(post)))
	    -> #attribute:consumed(#e0)<=#attribute:size(#e0))
	)\then(#introAtPreDefs(\modality{#allmodal}{.#t(#e0,#e1,#e2).. #expand-method-body-perc(#mb,#v0,#v1); ...}\endmodality(post)))
	\else(\modality{#allmodal}{.. throw javax.realtime.RealtimeSystem.oome(); ...}\endmodality(post)))
    \add(\if(!#noLocalScope(\<{#mb}\>true))\then(outerScope(#attribute:stack(#e0),#stackAtIndex(#nextToCreateStack+sk)) & sk>=0)\else(true) ==>)
    \heuristics(method_expand) 
    \oldname "method_body_expand"
  };

}

\rules(programRules:Java, nullPointerPolicy:noNullCheck, perc:on){

  methodCall { 
    \find (\modality{#allmodal}{.. #se.#mn(#selist)@#scope; ...}\endmodality(post)) 
    \varcond(\not\staticMethodReference(#se, #mn, #selist))
    "Normal Execution":
      \replacewith (\modality{#allmodal}{.. #method-call(#se.#mn(#selist)@#scope); ...}\endmodality(post))
    \heuristics(simplify_autoname)
    };

  methodCallWithAssignment { 
    \find (\modality{#allmodal}{.. #lhs = #se.#mn(#selist)@#scope; ...}\endmodality((post))) 
    \varcond(\new(#v0, \typeof(#lhs)), \not \staticMethodReference(#se, #mn, #selist))
    "Normal Execution":
      \replacewith (\modality{#allmodal}{.. #typeof(#lhs) #v0;
	  	                 #method-call(#v0, #se.#mn(#selist)@#scope);
		                 #lhs = #v0; 
                              ...}\endmodality(post))
    \heuristics(simplify_autoname)
    \displayname "methodCall"
    \oldname "method_call_with_assignment"
  };


}

\rules(programRules:Java, perc:on) {
  arrayInitialisationPerc {
	\find (\modality{#normalassign}{.#t(#e,#e2,#e3,#a).. for (int #v=#se; #v<this.#length; #v++) this[#v] = #lit; ...}\endmodality(post))
	\replacewith({\for iv; \if (geq(iv,#se) & lt(iv,#a.#length)) #a[iv] := #lit}\modality{#normalassign}{..  ...}\endmodality(post))
	\displayname "arrayInitialisation"
	\heuristics(simplify)
	\oldname "init_array_for_loop_"
  };

  arrayInitialisationTRAPerc {
        \find (\modality{#traonly}{.#t(#e0,#e2,#e3,#a).. for (int #v=#se; #v<this.#length; #v++) this[#v] = #lit; ...}\endmodality(post))
	\replacewith({\for iv; \if (geq(iv,#se) & lt(iv,#a.#length)) #a[iv]^(#transactionCounter) := #lit}\modality{#traonly}{..  ...}\endmodality(post))
	\heuristics(simplify)	
        \displayname "arrayInitialisation"
	\oldname "init_array_for_loop_tra"
  };

  arrayInitialisationToutPerc {
        \find (\throughout{.#t(#e0,#e2,#e3,#a).. for (int #v=#se; #v<this.#length; #v++) this[#v] = #lit; ...}\endmodality(post))
	\varcond(\notFreeIn(iv2, post))
	\replacewith(
	   \forall iv2; ((iv2 >= #se & iv2 <= #a.#length) -> 
             {\for iv; \if (iv >= #se & iv < iv2) #a[iv] := #lit}post) &
	        {\for iv; \if (geq(iv,#v) & lt(iv,#a.#length)) #a[iv] := #lit}
                   (post -> \throughout{..  ...}\endmodality(post)))
	\heuristics(simplify)	
	\displayname "init_array_for_loop"
  };
}

\rules(programRules:Java, perc:on) {

// skip index check as the case below can only happen in an implicit method
  assignment_write_array_this_access_normalassign_perc{
		\find (\modality{#normalassign}{.#t(#e,#e2,#e3, #v).. this[#se]=#se0; ...}\endmodality(post))
		"Normal Execution":
			\replacewith(( lt(#se,#lengthReference(#v)) & lt(-1,#se)) ->   
			{#v[#se]:=#se0}\modality{#normalassign}{.. ...}\endmodality(post))
	         \heuristics(simplify_prog, simplify_prog_subset)
		 \displayname "assignment"};



  // may trigger static initialisation, but the super class has either
  // initialized or during initialisation, but not erroneous. So nothing
  // happens and we do not need to treat static initialisation here
  methodCallSuperPerc { 
    \find (\modality{#allmodal}{.#ex.. super.#mn(#elist)@#scope; ...}\endmodality(post)) 
    \replacewith (\modality{#allmodal}{.. #method-call(#ex, super.#mn(#elist)@#scope); 
                            ...}\endmodality(post)) 
    \heuristics(simplify_autoname)
    \oldname "method_call_super"
  };

  // may trigger static initialisation, but the super class has either
  // initialized or during initialisation, but not erroneous. So nothing
  // happens and we do not need to treat static initialisation here
  methodCallWithAssignmentSuperPerc {
    \find (\modality{#allmodal}{.#ex.. #lhs=super.#mn(#elist)@#scope; ...}\endmodality(post))
    \varcond(\new(#v0, \typeof(#lhs)))
    \replacewith (\modality{#allmodal}{.. #typeof(#lhs) #v0;
                               #method-call(#ex, #v0, super.#mn(#elist)@#scope);
                               #lhs = #v0;
                            ...}\endmodality(post)) 
    \displayname "methodCallSuper"
    \heuristics(simplify_autoname)
    \oldname "method_call_with_assignment_super"
  };
}

\rules(programRules:Java, initialisation:disableStaticInitialisation, perc:on) {
  staticMethodCall { 
    \find (\modality{#allmodal}{.. #se.#mn(#elist)@#scope; ...}\endmodality(post)) 
    \varcond(\staticMethodReference(#se, #mn, #elist))
    "Normal Execution":
    \replacewith (\modality{#allmodal}{.. 			    
		 #method-call(#v0, #se.#mn(#elist)@#scope);
		...}\endmodality(post))
    \heuristics(simplify_autoname)
    \displayname "methodCall"
    \oldname "static_method_call"
  };

  staticMethodCallWithAssignment { 
    \find (\modality{#allmodal}{.. #lhs = #se.#mn(#elist)@#scope; ...}\endmodality(post)) 
    \varcond(\new(#v0, \typeof(#lhs)), \staticMethodReference(#se, #mn, #elist))
    "Normal Execution":
      \replacewith (\modality{#allmodal}{.. 
			    #typeof(#lhs) #v0;
	  	            #method-call(#v0, #se.#mn(#elist)@#scope);
		            #lhs = #v0; 
                  ...}\endmodality(post))
    \heuristics(simplify_autoname)
    \displayname "methodCall"
    \oldname "static_method_call_with_assignment"
  };

  staticMethodCallStaticViaTypereference { 
    \find (\modality{#allmodal}{.. #t.#mn(#elist)@#scope; ...}\endmodality(post)) 
    \replacewith (\modality{#allmodal}{..  #method-call(#t.#mn(#elist)@#scope); ...}\endmodality(post)) 
    \heuristics(simplify_autoname)
    \displayname "methodCall"
    \oldname "static_method_call_static_via_typereference"
  };


  staticMethodCallStaticWithAssignmentViaTypereference {
    \find (\modality{#allmodal}{.. #lhs = #t.#mn(#elist)@#scope; ...}\endmodality(post))
    \varcond(\new(#v0, \typeof(#lhs)))
    \replacewith (\modality{#allmodal}{..  #typeof(#lhs) #v0;
			        #method-call(#v0, #t.#mn(#elist)@#scope);
			        #lhs = #v0; ...}\endmodality(post)) 
    \heuristics(simplify_autoname)
    \displayname "methodCall"
    \oldname "static_method_call_static_with_assignment_via_typereference"
  };

  methodCallWithAssignmentWithinClass {
    \find (\modality{#allmodal}{.#ex.. #lhs=#mn(#elist)@#scope; ...}\endmodality(post)) 
    \varcond(\new(#v0, \typeof(#lhs)))
    \replacewith (\modality{#allmodal}{.. #typeof(#lhs) #v0;
                               #method-call(#ex, #v0, #mn(#elist)@#scope);
                               #lhs = #v0;
                            ...}\endmodality(post)) 
    \heuristics(simplify_autoname)
    \displayname "methodCall"
    \oldname "method_call_with_assignment_within_class"
  };

  methodCallWithinClass { 
    \find (\modality{#allmodal}{.. #mn(#elist)@#scope; ...}\endmodality(post)) 
    \replacewith (\modality{#allmodal}{.. 
	#method-call(#mn(#elist)@#scope); ...}\endmodality(post)) 
    \heuristics(simplify_autoname)
    \displayname "methodCall"
    \oldname "method_call_within_class"
  };   
}

\rules(programRules:Java, nullPointerPolicy:nullCheck, perc:on){

  methodCall { 
    \find (\modality{#allbuttra}{.. #se.#mn(#selist)@#scope; ...}\endmodality(post)) \sameUpdateLevel
    \varcond(\not \staticMethodReference(#se, #mn, #selist))
    "Normal Execution (#se != null )":
      \replacewith (\modality{#allbuttra}{.. #method-call(#se.#mn(#selist)@#scope); ...}\endmodality(post)) 
      \add (==> #se = null);
    "Null Reference (#se = null)":
      \replacewith (\modality{#allbuttra}{.. throw new java.lang.NullPointerException();
   	  	                  ...}\endmodality(post)) \add (#se = null==>)
    \heuristics(simplify_autoname)
    \oldname "method_call"
    };

  methodCallWithAssignment { 
    \find (\modality{#allbuttra}{.. #lhs = #se.#mn(#selist)@#scope; ...}\endmodality((post))) \sameUpdateLevel
    \varcond(\new(#v0, \typeof(#lhs)), \not \staticMethodReference(#se, #mn, #selist))
    "Normal Execution (#se != null)":
      \replacewith (\modality{#allbuttra}{.. #typeof(#lhs) #v0;
	  	                            #method-call(#v0, #se.#mn(#selist)@#scope);
		                            #lhs = #v0; 
                                            ...}\endmodality(post))
      \add (==>#se = null);
    "Null Reference (#se = null)":
      \replacewith (\modality{#allbuttra}{.. throw new java.lang.NullPointerException();
                                  ...}\endmodality(post))
      \add (#se = null  ==> )
    \heuristics(simplify_autoname)
    \displayname "methodCall"
    \oldname "method_call_with_assignment"
  };

}


