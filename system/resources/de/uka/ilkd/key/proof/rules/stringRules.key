\functions {
	   \nonRigid[Location] CharList content(java.lang.String);
}

\schemaVariables {
	\modalOperator { diamond, box, diamond_trc, box_trc, throughout_trc } #normalassign;
        \program Variable #v;
	\program StringLiteral #slit;
	\program SimpleStringExpression #sstr1, #sstr2;
	\formula post;
}

\rules {

  /***********************************
   * Axiomatization of the functions *
   ***********************************/
  /*
   * int length(CharList)
   */
  cl_lengthEmpty {
    \find (length(empty))
    \replacewith (0)
    \heuristics (userTaclets3)
  };

  cl_lengthCons {
    \schemaVar \term CharList l;
    \schemaVar \term jchar c;
    \find (length(cons(c,l)))
    \replacewith (length(l)+1)
    \heuristics (userTaclets3)
  };

  /*
   * jchar head(CharList)
   * the first character in the list.
   * head(empty) is unspecified
   */
  cl_headCons {
    \schemaVar \term CharList l;
    \schemaVar \term jchar c;
    \find (head(cons(c,l)))
    \replacewith (c)
    \heuristics (userTaclets3)
  };

  /*cl_headEmpty {
    \find (head(empty))
    \replacewith(0)
    \heuristics (userTaclets3)
  };*/

  /*
   * int charAt (int,CharList)
   * an index < 0 will be mapped to 0
   * ( to force charAt(i,l)=head(substring(i,length(l),l)) )
   * charAt (i,empty) is unspecified and therefore also charAt(i,l)
   * when i >= length(l)
   */
  cl_charAt0 {
    \schemaVar \term CharList l;
    \schemaVar \term jchar c;
    \find (charAt(0,cons(c,l)))
    \replacewith (c)
    \heuristics (userTaclets1)
  };

  cl_charAtI {
    \schemaVar \term CharList l;
    \schemaVar \term jchar c;
    \schemaVar \term int i;
    \find (charAt(i,cons(c,l)))
    \replacewith (\if (i>0) \then (charAt(i-1,l)) 
		            \else (charAt(0,cons(c,l))))
    \heuristics (userTaclets1)
  };

  /*cl_charAtEmpty {
    \schemaVar \term CharList l;
    \schemaVar \term int i;
    \find (charAt(i,empty))
    \replacewith (0)
    \heuristics (userTaclets3)
  };*/

  /*
   * charAt(i,empty)=head(empty)
   */
  cl_charAtHead {
    \schemaVar \term int i;
    \find (charAt(i,empty))
    \replacewith (head(empty))
    \heuristics (userTaclets2)
  };

  /*
   * = (CharList,CharList)
   * the equality predicate
   */
  cl_equalFalse1 {
    \schemaVar \term CharList l;
    \schemaVar \term jchar c;
    \find (empty = cons(c,l))
    \replacewith (false)
    \heuristics (userTaclets3)
  };

  cl_equalFalse2 {
    \schemaVar \term CharList l;
    \schemaVar \term jchar c;
    \find (cons(c,l) = empty)
    \replacewith (false)
    \heuristics (userTaclets3)
  };

  cl_equalReduce {
    \schemaVar \term CharList l1, l2;
    \schemaVar \term jchar c;
    \find (cons(c,l1) = cons(c,l2))
    \replacewith (l1 = l2)
    \heuristics (userTaclets3)
  };

  cl_equalFalse {
    \schemaVar \term CharList l1, l2;
    \schemaVar \term jchar c1, c2;
    \assumes (c1 != c2 ==> )
    \find (cons(c1,l1) = cons(c2,l2))
    \replacewith (false)
    \heuristics (userTaclets3)
  };

  /*
   * structural induction over all CharLists
   */
  cl_induct {
    \schemaVar \variables CharList lv;
    \schemaVar \variables jchar cv;
    \schemaVar \formula phi;
    \varcond ( \notFreeIn(cv,phi)  )
    "Base Case": \add ( ==> {\subst lv; empty}(phi) );
    "Step Case": \add ( ==> \forall lv; \forall cv;
                              ((inChar(cv) & phi) -> {\subst lv; cons(cv,lv)}phi) );
    "Use Case":  \add ( \forall lv; (phi) ==> )
    \heuristics (userTaclets2)
  };

  /*
   * jchar indexOf (jchar,int,CharList)
   */
  cl_indexOf {
    \schemaVar \term CharList l;
    \schemaVar \term jchar c;
    \schemaVar \term int i;
    \schemaVar \variables int iv;
    \find (indexOf (c,i,l))
    \varcond ( \notFreeIn(iv,l), \notFreeIn(iv,c), \notFreeIn(iv,i) )
    \replacewith ( \ifEx iv; ( iv >= 0 & iv >= i & iv < length(l) & charAt(iv,l) = c )
                     \then (iv)
                     \else (-1) )
    \heuristics (userTaclets2)
  };

  /*
   * CharList substring(int,int,CharList)
   * from start index to end index
   */
  cl_substring0 {
    \schemaVar \term CharList l;
    \schemaVar \term int i;
    \schemaVar \term jchar c;
    \find ( substring (0,i,cons(c,l)) )
    \replacewith ( \if (i>0) \then (cons(c,substring(0,i-1,l)))
    		       	     \else (empty) )
    \heuristics (userTaclets1)
  };

  cl_substringI {
    \schemaVar \term CharList l;
    \schemaVar \term jchar c;
    \schemaVar \term int i,j;
    \find ( substring (i,j,cons(c,l)) )
    \replacewith ( \if (i>0) \then (substring(i-1,j-1,l))
    		       	     \else (substring(0,j,cons(c,l))) )
    \heuristics (userTaclets1)
  };

  cl_substringEmpty {
    \schemaVar \term int i,j;
    \find ( substring(i,j,empty) )
    \replacewith ( empty )
    \heuristics (userTaclets1)
  };

  /*
   * endsWith(CharList,CharList)
   * predicate indicating if the first list
   * is a suffix of the second one
   */
  cl_endsWith {
    \schemaVar \term CharList l1, l2;
    \find (endsWith(l1,l2))
    \replacewith ( substring(length(l2)-length(l1),length(l2),l2) = l1 )
    \heuristics (userTaclets3)
  };

  /*
   * startsWith(CharList,CharList)
   * predicate indicating if the first list
   * is a prefix of the second one
   */
  cl_startsWith {
    \schemaVar \term CharList l1,l2;
    \find(startsWith(l1,l2))
    \replacewith ( substring(0,length(l1),l2) = l1 )
    \heuristics (userTaclets3)
  };

  /*
   * CharList concat (CharList,CharList)
   * concatenate the two lists
   */
  cl_concatEmpty1 {
    \schemaVar \term CharList l;
    \find (concat(empty,l))
    \replacewith (l)
    \heuristics (userTaclets3)
  };

  cl_concatEmpty2 {
    \schemaVar \term CharList l;
    \find (concat(l,empty))
    \replacewith (l)
    \heuristics (userTaclets3)
  };

  cl_concatCons {
    \schemaVar \term CharList l1, l2;
    \schemaVar \term jchar c;
    \find (concat(cons(c,l1),l2))
    \replacewith (cons(c,concat(l1,l2)))
    \heuristics (userTaclets2)
  };

  /*
   * contains (CharList,CharList)
   * predicate indicating whether the first list
   * is contained in the second
   */
  cl_contains {
    \schemaVar \term CharList l1, l2;
    \schemaVar \variables int iv;
    \find (contains(l1,l2))
    \varcond ( \notFreeIn (iv,l1), \notFreeIn (iv,l2) )
    \replacewith ( \exists iv; (substring(iv,iv+length(l1),l2) = l1) )
    \heuristics (userTaclets2)
  };

  /*
   * int indexOfStr (CharList,int,CharList)
   */
  cl_indexOfStr {
    \schemaVar \term CharList l1, l2;
    \schemaVar \term int i;
    \schemaVar \variables int iv;
    \find (indexOfStr(l1,i,l2))
    \varcond ( \notFreeIn (iv,l1), \notFreeIn (iv,l2), \notFreeIn (iv,i) )
    \replacewith ( \ifEx iv; (iv >= i
			      & (substring(iv,iv+length(l1),l2) = l1))
                   \then (iv)
                   \else (-1) )
    \heuristics (userTaclets2)
  };

  /*
   * int lastIndexOf (jchar,int,CharList)
   */
  cl_lastIndexOf {
    \schemaVar \term CharList l;
    \schemaVar \term jchar c;
    \schemaVar \term int i;
    \schemaVar \variables int iv;
    \find (lastIndexOf (c,i,l))
    \varcond ( \notFreeIn (iv,c), \notFreeIn (iv,i), \notFreeIn (iv,l) )
    /* minimizing iv will maximize -iv */
    \replacewith ( \ifEx iv; (-iv >= i
			      & charAt(-iv,l) = c)
                   \then (iv)
                   \else (-1) )
    \heuristics (userTaclets2)
  };

  /*
   * int lastIndexOfStr (CharList,int,CharList)
   */
  cl_lastIndexOfStr {
    \schemaVar \term CharList l1, l2;
    \schemaVar \term int i;
    \schemaVar \variables int iv;
    \find (lastIndexOfStr (l1,i,l2))
    \varcond ( \notFreeIn (iv,l1), \notFreeIn (iv,i), \notFreeIn (iv,l2) )
    /* minimizing iv will maximize -iv */
    \replacewith ( \ifEx iv; (-iv >= i
			      & (substring(-iv,length(l1)-iv,l2) = l1))
                   \then (iv)
                   \else (-1) )
    \heuristics (userTaclets2)
  };

  /*
   * CharList replace (jchar,jchar,CharList)
   * replace all occurences of first character
   * against the second character
   */
  cl_replaceEmpty {
    \schemaVar \term jchar c1, c2;
    \find (replace(c1,c2,empty))
    \replacewith (empty)
    \heuristics (userTaclets3)
  };

  cl_replaceCons {
    \schemaVar \term CharList l;
    \schemaVar \term jchar c, c1, c2;
    \find (replace(c1,c2,cons(c,l)))
    \replacewith ( \if (c=c1) \then (cons(c2,replace(c1,c2,l)))
                              \else (cons(c,replace(c1,c2,l))) )
    \heuristics (userTaclets1)
  };

      /**********
       /* Lemmas *
       /**********/

       /*
        * The length of every CharList is at least 0
	*/
       lemma_lengthGEq0 {
           \schemaVar \term CharList l;
	   \add (length(l) >= 0 ==> )
	   \heuristics (userTaclets2)
       };

       /*
        * The substring with startIndex=endIndex is empty
	*/
       lemma_substringII {
           \schemaVar \term CharList l;
	   \schemaVar \term int i;
	   \find (substring(i,i,l))
	   \replacewith (empty)
	   \heuristics (userTaclets3)
       };

       /*
        * With endIndex<startIndex the substring is empty
	*/
       lemma_substringLt {
          \schemaVar \term CharList l;
	  \schemaVar \term int i,j;
	  \find (substring(i,j,l))
	  \replacewith (\if (j<i) \then (empty)
	  	       	    	  \else (substring(i,j,l)) )
	  \heuristics (userTaclets2)
      };

      /*
       * replacing charAt with substring and head
       */
       lemma_charAt {
           \schemaVar \term CharList l;
	   \schemaVar \term int i;
	   \find (charAt(i,l))
	   \replacewith (head(substring(i,length(l),l)))
	   \heuristics (userTaclets2)
       };

       /*
        * Due to specification, a startIndex < 0 is mapped to 0
	*/
       lemma_substringLt0 {
           \schemaVar \term CharList l;
	   \schemaVar \term int i,j;
	   \find (substring (i,j,l))
	   \replacewith (\if (i<0) \then (substring(0,j,l))
	   		     	   \else (substring(i,j,l)) )
	   \heuristics (userTaclets2)
       };

       /*
        * Due to specification, a endIndex>=length(list) is mapped to length(list)
	*/
       lemma_substringGtLength {
           \schemaVar \term CharList l;
	   \schemaVar \term int i,j;
	   \find (substring(i,j,l))
	   \replacewith (\if (j>=length(l)) \then (substring(i,length(l),l))
	   		     		    \else (substring(i,j,l)) )
	   \heuristics (userTaclets2)
       };

       /*
        * The length of a well defined substring is endIndex-startIndex
	*/
       lemma_substringLength {
          \schemaVar \term CharList l;
	  \schemaVar \term int i,j;
	  \find (length(substring(i,j,l)))
	  \replacewith (\if (j>=i & i>=0 & j<=length(l)) \then (j-i)
	  	       	    	    	   		 \else (length(substring(i,j,l))) )
							       /* use other lemmas... */	
	  \heuristics (userTaclets3)
      };

       /*
        * Two succedent substring calls can be combined to one
	*/
       lemma_substringSubstring {
       	   \schemaVar \term CharList l;
	   \schemaVar \term int i,j,k,m;
	   \find (substring(i,j,substring(k,m,l)))
	   \replacewith (\if (i >= 0 & k >= 0 & m >= k+j) \then (substring(i+k,k+j,l))
	   					     	  \else (substring(i,j,substring(k,m,l)))
				      	    	 	  /* use other lemmas... */ )
	   \heuristics (userTaclets2)
       };

       /*
        * Like for substring, charAt(i,l) for i<0 is mapped to charAt(0,l)
	*/
       lemma_charAtLt0 {
           \schemaVar \term CharList l;
	   \schemaVar \term int i;
	   \find (charAt(i,l))
	   \replacewith (\if (i<=0) \then (charAt(0,l))
	   		     	   \else (charAt(i,l)) )
	   \heuristics (userTaclets2)
       };

       /*
        * The length of a concatenated string is the sum of its parts
	*/
       lemma_lengthConcat {
           \schemaVar \term CharList l1,l2;
	   \find (length(concat(l1,l2)))
	   \replacewith (length(l1)+length(l2))
	   \heuristics (userTaclets3)
       };

      /*
       * the substring of a concatenation can be computed as a contatenation of
       * two substring terms:
       * substring(i,j,concat(l1,l2))
       * = concat (substring(i,j,l1),substring(i-length(l1),j-length(l1),l2))
       * Note that the due to the axiomatization of the exception cases for
       * substring, no preconditions are needed
       */
      lemma_substringConcat {
           \schemaVar \term CharList l1,l2;
	   \schemaVar \term int i,j;
	   \find ( substring(i,j,concat(l1,l2)) )
	   \replacewith ( concat(substring(i,j,l1),substring(i-length(l1),j-length(l1),l2)) )
	   \heuristics (userTaclets3)
       };

       /*
        * A replace inside a substring call does not affect the substring method
	*/
       lemma_substringReplace {
           \schemaVar \term CharList l;
	   \schemaVar \term jchar c1,c2;
	   \schemaVar \term int i,j;
	   \find (substring(i,j,replace(c1,c2,l)))
	   \replacewith (replace(c1,c2,substring(i,j,l)))
	   \heuristics (userTaclets3)
       };

       /*
        * The oder way around
	*/
       lemma_replaceSubstring {
           \schemaVar \term CharList l;
	   \schemaVar \term jchar c1,c2;
	   \schemaVar \term int i,j;
	   \find (replace(c1,c2,substring(i,j,l)))
	   \replacewith (substring(i,j,replace(c1,c2,l)))
	   \heuristics (userTaclets1)
       };

       /*
        * l is not equal to cons(c,l)
	*/
       lemma_consEq {
           \schemaVar \term CharList l;
	   \schemaVar \term jchar c;
	   \find ( l = cons(c,l) )
	   \replacewith ( false )
	   \heuristics (userTaclets3)
       };

       /*
        * concatenation of a non empty string changes the original string
	*/
       lemma_concatEqLeft {
           \schemaVar \term CharList l1, l2;
	   \assumes ( ==> l2 = empty)
	   \find ( concat(l1,l2) = l1 )
	   \sameUpdateLevel
	   \replacewith ( false )
	   \heuristics (userTaclets3)
       };

       lemma_concatEqRight {
           \schemaVar \term CharList l1, l2;
	   \assumes ( ==> l1 = empty)
	   \find ( concat(l1,l2) = l2 )
	   \sameUpdateLevel
	   \replacewith ( false )
	   \heuristics (userTaclets3)
       };

       /*
        * Two lists of different length are not equal
	*/
       lemma_lengthNEq1 {
           \schemaVar \term CharList l1,l2;
	   \schemaVar \formula phi;
	   \assumes ( ==> length(l1) = length(l2) )
	   \add ( ==> l1 = l2 )
	   \heuristics (userTaclets3)
       };

       /*
        * Two equal lists have the same length
	*/
	lemma_lengthNEq2 {
	    \schemaVar \term CharList l1,l2;
	    \assumes ( l1 = l2 ==> )
	    \add ( length(l1) = length(l2) ==> )
	    \heuristics (userTaclets3)
	};

      /*
       * empty is the only list having length 0
       */
      lemma_length0 {
          \schemaVar \term CharList l;
	  \assumes (length(l) = 0 ==> )
	  \add (l = empty ==> )
	  \heuristics (userTaclets3)
      };

       /*
        * In a term charAt(i,substring(j,k,l)), the substring can be omitted
	*/
       lemma_charAtSubstring {
           \schemaVar \term CharList l;
           \schemaVar \term int i,j,k;
	   \find (charAt(i,substring(j,k,l)))
	   \replacewith( \if (i<k-j
	   		      & i>=0
	   		      & j>=0
			      & k>j
			      & i+j<length(l))
			 \then (charAt(i+j,l))
			 \else (charAt(i,substring(j,k,l)))
				/* use other lemmas first */ )
	   \heuristics (userTaclets3)		
       };


       //
       // Assignment of a Literal
       //
       stringAssignment  { \find (\modality{#normalassign}{.. #v = #slit; ...}\endmodality(post)) 
                \replacewith ({ #v := java.lang.String::<get>(#v.<nextToCreate>@(java.lang.String)) }{
			     	#v.<nextToCreate>@(java.lang.String) := #v.<nextToCreate>@(java.lang.String)+1 ||
			     	#v.<created>@(java.lang.Object):=TRUE ||
				#v.<initialized>@(java.lang.Object):=TRUE ||
				#v.<transient>@(java.lang.Object):=0 ||
				content(#v):= #slit}
				\modality{#normalassign}{.. ...}\endmodality(post)) 
                \displayname "assignment"
		\heuristics (userTaclets3)
	};

	//
	// The "+" operator
	//
	stringConcat {
	    \find ( \modality{#normalassign}{.. #v = #sstr1 + #sstr2; ...}\endmodality(post))
	    \replacewith ( { #v := java.lang.String::<get>(#v.<nextToCreate>@(java.lang.String)) }{
	    		     #v.<nextToCreate>@(java.lang.String) := #v.<nextToCreate>@(java.lang.String)+1 ||
			     #v.<created>@(java.lang.Object):=TRUE ||
			     #v.<initialized>@(java.lang.Object):=TRUE ||
			     #v.<transient>@(java.lang.Object):=0 ||
			     content(#v) := concat(content(#sstr1),content(#sstr2)) }
	    		   \modality{#normalassign}{.. ...}\endmodality(post) )
	    \displayname "concatenation"
	    \heuristics (userTaclets3)
	};
}
