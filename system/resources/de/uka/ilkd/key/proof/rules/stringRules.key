\rules{
  /***********
   *  AXIOMS  *
   ***********/
  /*
   * CharList translateInt (int)
   * - translating an integer into a CharList
   */
  translate0 {
    \schemaVar \term numbers iz;
    \find (translateInt(Z(0(iz))))
    \replacewith (concat(translateInt(Z(iz)),cons('0',empty)))
    \heuristics (integerToString)
  };

  translate1 {
    \schemaVar \term numbers iz;
    \find (translateInt(Z(1(iz))))
    \replacewith (concat(translateInt(Z(iz)),cons('1',empty)))
    \heuristics (integerToString)
  };

  translate2 {
    \schemaVar \term numbers iz;
    \find (translateInt(Z(2(iz))))
    \replacewith (concat(translateInt(Z(iz)),cons('2',empty)))
    \heuristics (integerToString)
  };

  translate3 {
    \schemaVar \term numbers iz;
    \find (translateInt(Z(3(iz))))
    \replacewith (concat(translateInt(Z(iz)),cons('3',empty)))
    \heuristics (integerToString)
  };

  translate4 {
    \schemaVar \term numbers iz;
    \find (translateInt(Z(4(iz))))
    \replacewith (concat(translateInt(Z(iz)),cons('4',empty)))
    \heuristics (integerToString)
  };

  translate5 {
    \schemaVar \term numbers iz;
    \find (translateInt(Z(5(iz))))
    \replacewith (concat(translateInt(Z(iz)),cons('5',empty)))
    \heuristics (integerToString)
  };

  translate6 {
    \schemaVar \term numbers iz;
    \find (translateInt(Z(6(iz))))
    \replacewith (concat(translateInt(Z(iz)),cons('6',empty)))
    \heuristics (integerToString)
  };

  translate7 {
    \schemaVar \term numbers iz;
    \find (translateInt(Z(7(iz))))
    \replacewith (concat(translateInt(Z(iz)),cons('7',empty)))
    \heuristics (integerToString)
  };

  translate8 {
    \schemaVar \term numbers iz;
    \find (translateInt(Z(8(iz))))
    \replacewith (concat(translateInt(Z(iz)),cons('8',empty)))
    \heuristics (integerToString)
  };

  translate9 {
    \schemaVar \term numbers iz;
    \find (translateInt(Z(9(iz))))
    \replacewith (concat(translateInt(Z(iz)),cons('9',empty)))
    \heuristics (integerToString)
  };

  translate# {
    \find (translateInt(Z(#)))
    \replacewith (empty)
    \heuristics (integerToString)
  };

  translateNegLit {
    \schemaVar \term numbers iz;
    \find (translateInt(Z(neglit(iz))))
    \replacewith (concat(translateInt(Z(iz)),cons('-',empty)))
    \heuristics (integerToString)
  };

  
  /*
   * CharList removeZeros (CharList) - removing '0' from
   * the beginning of a CharList must not lead to the empty list
   */
  removeZeros {
    \schemaVar \term CharList l;
    \schemaVar \term jchar c1, c2;
    \find (removeZeros(cons(c1,cons(c2,l))))
    \replacewith (\if (c1 = '0') \then (removeZeros(cons(c2,l)))
    		      	   	 \else (cons(c1,cons(c2,l))))
    \heuristics (integerToString)
  };

  removeZerosEmpty {
    \schemaVar \term jchar c;
    \find (removeZeros(cons(c,empty)))
    \replacewith (cons(c,empty))
    \heuristics (integerToString)
  };


  /*
   * int length(CharList)
   */
  lengthEmpty {
    \find (length(empty))
    \replacewith (0)
    \heuristics (simplify)
  };

  lengthCons {
    \schemaVar \term CharList l;
    \schemaVar \term jchar c;
    \find (length(cons(c,l)))
    \replacewith (length(l)+1)
    \heuristics (simplify)
  };

  /*
   * int charAt (int,CharList)
   * an index < 0 and >= length(l) in unspecified
   */
  charAt0 {
    \schemaVar \term CharList l;
    \schemaVar \term jchar c;
    \find (charAt(0,cons(c,l)))
    \replacewith (c)
    \heuristics (simplify)
  };

  charAtI {
    \schemaVar \term CharList l;
    \schemaVar \term jchar c;
    \schemaVar \term int i;
    \find (charAt(i,cons(c,l)))
    \replacewith (\if (i>0) \then (charAt(i-1,l)) 
		            \else (charAt(i,cons(c,l))))
    \heuristics (simplify)
  };

  /*
   * = (CharList,CharList)
   * the equality predicate
   */
  equalFalse1 {
    \schemaVar \term CharList l;
    \schemaVar \term jchar c;
    \find (empty = cons(c,l))
    \replacewith (false)
    \heuristics ( simplify_literals )
  };

  equalFalse2 {
    \schemaVar \term CharList l;
    \schemaVar \term jchar c;
    \find (cons(c,l) = empty)
    \replacewith (false)
    \heuristics ( simplify_literals )
  };

  equalReduce {
    \schemaVar \term CharList l1, l2;
    \schemaVar \term jchar c;
    \find (cons(c,l1) = cons(c,l2))
    \replacewith (l1 = l2)
    \heuristics ( simplify_literals ) 
  };

  equalFalse {
    \schemaVar \term CharList l1, l2;
    \schemaVar \term jchar c1, c2;
    \find (cons(c1,l1) = cons(c2,l2))
    \replacewith (\if (c1 = c2) \then (l1 = l2)
    		      	    	\else (false))
    \heuristics ( simplify_literals ) 
  };
  
  equalCharacters {
    \schemaVar \term numbers iz1, iz2;
    \find ( C(iz1) = C(iz2) )
    \replacewith ( Z(iz1) = Z(iz2) )
    \heuristics ( simplify_literals ) 
  };
    
  /*
   * Equality is also axiomatized using charAt...
   */
  equality {
    \schemaVar \term CharList l1, l2;
    \schemaVar \variables int iv;
    \find ( l1 = l2 )
    \varcond ( \notFreeIn(iv,l1), \notFreeIn(iv,l2) )
    \replacewith ( length(l1) = length(l2)
               & \forall iv; ((iv >= 0 & iv < length(l1))
                               -> charAt(iv,l1) = charAt(iv,l2)) )
  };

  /*
   * structural induction over all CharLists
   */
  charlist_induction {
    \schemaVar \variables CharList lv;
    \schemaVar \variables jchar cv;
    \schemaVar \formula phi;
    \varcond ( \notFreeIn(cv,phi)  )
    "Base Case": \add ( ==> {\subst lv; empty}(phi) );
    "Step Case": \add ( ==> \forall lv; \forall cv;
                              ((inChar(cv) & phi)
                               -> {\subst lv; cons(cv,lv)}phi) );
    "Use Case":  \add ( \forall lv; (phi) ==> )
  };

  /*
   * jchar indexOf (jchar,int,CharList)
   */
  indexOf {
    \schemaVar \term CharList l;
    \schemaVar \term jchar c;
    \schemaVar \term int i;
    \schemaVar \variables int iv;
    \find (indexOf (c,i,l))
    \varcond ( \notFreeIn(iv,l),
               \notFreeIn(iv,c),
               \notFreeIn(iv,i) )
    \replacewith ( \ifEx iv; (  iv >= 0
                              & iv >= i
                              & iv < length(l)
                              & charAt(iv,l) = c )
                     \then (iv)
                     \else (-1) )
  };

  /*
   * CharList substring(int,int,CharList)
   * from start index to end index
   * The axiom substring0 uses the indirection through concat,
   * so it does not create a cons term that is not in value form.
   */
  substring0 {
    \schemaVar \term CharList l;
    \schemaVar \term int i;
    \schemaVar \term jchar c;
    \find ( substring (0, i, cons(c,l)) )
    \replacewith ( \if (i > 0)
                   \then (concat(cons(c,empty), substring(0, i-1, l)))
                   \else (substring(0,i,cons(c,l))) )
    \heuristics (stringNormalisationReduce)
  };

  substringI {
    \schemaVar \term CharList l;
    \schemaVar \term jchar c;
    \schemaVar \term int i,j;
    \find ( substring (i,j,cons(c,l)) )
    \replacewith ( \if (i>0 & i<=j) \then (substring(i-1,j-1,l))
    		       	     \else (substring(i,j,cons(c,l))) )
    \heuristics (stringNormalisation1)
  };

  substring00 {
    \schemaVar \term CharList l;
    \find ( substring(0,0,l) )
    \replacewith ( empty )
    \heuristics ( concrete )
  };

  substringIdentity0 {
    \schemaVar \term CharList l;
    \schemaVar \term int len;    
    \assumes (length(l) = len ==>)
    \find ( substring(0,len,l) )
    \sameUpdateLevel
    \replacewith ( l )
    \heuristics (concrete)
    \displayname "substringIdentity"
  };


  substringIdentity1 {
    \schemaVar \term CharList l;
    \find ( substring(0, length(l), l) )
    \replacewith ( l )
    \heuristics (simplify)
    \displayname "substringIdentity"
  };

  zeroLengthIsEmptyString {
    \schemaVar \term CharList l;
    \find ( length(l) = 0 ==> )
    \add ( l = empty ==>)
    \heuristics (simplify)
  };

  /*
   * endsWith(CharList,CharList)
   * predicate indicating if the first list
   * is a suffix of the second one
   */
  endsWith {
    \schemaVar \term CharList l1, l2;
    \find (endsWith(l1,l2))
    \replacewith ( \if (length(l1)>length(l2))
    		   \then (false)
		   \else (substring(length(l2)-length(l1),
                                    length(l2),l2) = l1) )
    \heuristics (stringNormalisationReduce)
  };

  /*
   * startsWith(CharList,CharList)
   * predicate indicating if the first list
   * is a prefix of the second one
   */
  startsWith {
    \schemaVar \term CharList l1,l2;
    \find(startsWith(l1,l2))
    \replacewith ( \if (length(l1)>length(l2))
    		   \then (false)
		   \else (substring(0,length(l1),l2) = l1) )
    \heuristics (stringNormalisationReduce)
  };

  /*
   * CharList concat (CharList,CharList)
   * concatenate the two lists
   */
  concatEmpty1 {
    \schemaVar \term CharList l;
    \find (concat(empty,l))
    \replacewith (l)
    \heuristics (simplify)
  };

  concatEmpty2 {
    \schemaVar \term CharList l;
    \find (concat(l,empty))
    \replacewith (l)
    \heuristics (simplify)
  };

/** concat should not built terms, where a cons subterm is
     not in value form so this axiom should be used with care **/
  concatConsDep {
    \schemaVar \term CharList l1, l2;
    \schemaVar \term jchar c;
    \find (concat(cons(c,l1),l2))
    \replacewith (cons(c,concat(l1,l2)))
    //\heuristics (stringNormalisation1)
  };

  concatCons {
    \schemaVar \term CharList l1, l2;
    \schemaVar \term jchar c1, c2;
    \find (concat(cons(c1,l1),cons(c2,l2)))
    \replacewith (cat(cons(c1,empty),concat(l1,cons(c2,l2))))
    \heuristics ( simplify_literals )
  };

  concat2SubLeft {
     \schemaVar \term CharList s, s1, s2;
     \find ( concat(s1,s2) = s )
     \replacewith (s1 = substring(0, length(s1), s) & s2 = substring(length(s1), length(s1) + length(s2), s) & length(s1) + length(s2) = length(s))
     \heuristics (stringNormalisation1)
  };

  concat2SubRight {
     \schemaVar \term CharList s, s1, s2;
     \find ( s = concat(s1,s2) )
     \replacewith (s1 = substring(0, length(s1), s) & s2 = substring(length(s1), length(s1) + length(s2), s) & length(s1) + length(s2) = length(s))
     \heuristics (stringNormalisation1)
  };
     
  cat {
    \schemaVar \term CharList l;
    \schemaVar \term jchar c1, c2;
    \find (cat(cons(c1,empty),cons(c2,l)))
    \replacewith (cons(c1,cons(c2,l)))
    \heuristics ( simplify_literals )
  };

  /*
   * contains (CharList,CharList)
   * predicate indicating whether the first list
   * is contained in the second
   */
  /*contains2 {
    \schemaVar \term CharList l1, l2;
    \schemaVar \variables int iv;
    \find (contains(l1,l2))
    \varcond ( \notFreeIn (iv,l1), \notFreeIn (iv,l2) )
    \replacewith ( \exists iv; (  (iv >= 0)
                                & (iv+length(l1) <= length(l2))
                                & (substring(iv,iv+length(l1),l2) = l1)) )
  };*/
  contains {
    \schemaVar \term CharList l1, l2;
    \schemaVar \term jchar c;
    \find (contains(l1,cons(c,l2)))
    \replacewith ( length(l1) < length(l2) & (substring(0,length(l1),cons(c,l2)) = l1 | contains(l1,l2)) )
    \heuristics (stringNormalisationReduce)
  };

  /*
   * int indexOfStr (CharList,int,CharList)
   */
  indexOfStr {
    \schemaVar \term CharList l1, l2;
    \schemaVar \term int i;
    \schemaVar \variables int iv;
    \find (indexOfStr(l1,i,l2))
    \varcond ( \notFreeIn (iv,l1), \notFreeIn (iv,l2), \notFreeIn (iv,i) )
    \replacewith ( \ifEx iv; (iv >= i
    		   	      & iv >= 0
    		   	      & iv+length(l1) <= length(l2)
			      & (substring(iv,iv+length(l1),l2) = l1))
                   \then (iv)
                   \else (-1) )
    \heuristics (stringNormalisationReduce)    
  };

  /*
   * int lastIndexOf (jchar,int,CharList)
   */
  lastIndexOf {
      \schemaVar \term CharList l;
      \schemaVar \term jchar c;
      \schemaVar \term int i;
      \schemaVar \variables int iv;
      \find (lastIndexOf (c,i,l))
      \varcond ( \notFreeIn (iv,c), \notFreeIn (iv,i), \notFreeIn (iv,l) )
      \replacewith (\ifEx iv; (  iv > 0
                                & i-iv >= 0
                                & i-iv < length(l)
                                & charAt(i-iv,l) = c)
                    \then (i - iv)
                    \else (-1))
      \heuristics (stringNormalisationReduce)  
  };

  /*
   * int lastIndexOfStr (CharList,int,CharList)
   */
  lastIndexOfStr {
      \schemaVar \term CharList l1,l2;
      \schemaVar \term int i;
      \schemaVar \variables int iv;
      \find (lastIndexOfStr (l1,i,l2))
      \varcond ( \notFreeIn (iv,l1), \notFreeIn (iv,i), \notFreeIn (iv,l2) )
      \replacewith (\ifEx iv; (  iv > 0
                                & i-iv >= 0
                                & length(l1)+i-iv <= length(l2)
                                & (substring(i-iv,length(l1)+i-iv,l2) = l1))
                    \then (i - iv)
                    \else (-1))
      \heuristics (stringNormalisationReduce)
  };

  /*
   * CharList replace (jchar,jchar,CharList)
   * replace all occurences of the first character
   * with the second character
   */
  replaceEmpty {
    \schemaVar \term jchar c1, c2;
    \find (replace(c1,c2,empty))
    \replacewith (empty)
    \heuristics (simplify)
  };

  replaceCons {
    \schemaVar \term CharList l;
    \schemaVar \term jchar c1, c2, c3;
    \find (replace(c1,c2,cons(c3,l)))
    \replacewith ( \if (c1=c3)
                   \then (concat(cons(c2,empty),
                                 replace(c1,c2,l)))
                   \else (concat(cons(c3,empty),
                                 replace(c1,c2,l))) )
    \heuristics (stringNormalisationReduce)
  };

  /**
   * we define only the base case
   */
  hashCodeBase {
    \find (hashCode(empty))
    \replacewith ( 0 )
    \heuristics (concrete)
  };

  /************
   *  LEMMAS  *
   ************/
  /*
   * The length of a well defined substring is
   * endIndex-startIndex
   */
  lengthSubstring {
      \schemaVar \term CharList l;
      \schemaVar \term int i,j;
      \find (length(substring(i,j,l)))
      \replacewith (\if (j>=i & i>=0 & j<=length(l))
                    \then (j-i)
                    \else (length(substring(i,j,l))) )
      \heuristics (simplify)
  };

  lengthSubstring2 {
      \schemaVar \term CharList l, s;
      \schemaVar \term int i,j;
      
      \assumes (substring(i,j,l) = s ==> )
      \find (length(s))
      \sameUpdateLevel     
      \replacewith (\if (j>=i & i>=0 & j<=length(l))
                    \then (j-i)
                    \else (length(substring(i,j,l))) )
      \heuristics (simplify)
      \displayname "lengthSubstring"
  };


  /*
   * The length of a concatenation
   */
  lengthConcat {
      \schemaVar \term CharList l1,l2;
      \find (length(concat(l1,l2)))
      \replacewith (length(l1)+length(l2))
      \heuristics (simplify)
  };

  lengthConcat2 {
      \schemaVar \term CharList l1, l2, s;
      
      \assumes (concat(l1,l2) = s ==>)
      \find (length(s))
      \sameUpdateLevel      
      \replacewith (length(l1)+length(l2))
      \heuristics (simplify)
      \displayname "lengthConcat"
  };


  /*
   * A replace application will not change
   * the length of the string
   */
  lengthReplace {
      \schemaVar \term CharList l;
      \schemaVar \term jchar c1, c2;
      \find (length(replace(c1,c2,l)))
      \replacewith(length(l))
      \heuristics (simplify)
  };

  /*
   * A replace application will not change
   * the length of the string
   */
  lengthReplace2 {
      \schemaVar \term CharList l,s;
      \schemaVar \term jchar c1, c2;
      \assumes (replace(c1,c2,l) = s ==>)
      \find (length(s))
      \sameUpdateLevel      
      \replacewith(length(l))
      \heuristics (simplify)
      \displayname "lengthReplace"
  };


  /*
   * The length of every CharList is at least 0
   */
  lengthGEq0 {
      \schemaVar \term CharList l;
      \add (length(l) >= 0 ==> )
  };

  /*
   * The length of every CharList is at least 0
   */
  lengthNonNegative {
      \schemaVar \term CharList l;
      \find (length(l)) 
      \sameUpdateLevel
      \add (length(l) >= 0 ==> )
      \heuristics (stringAddFacts)
  };

  /*
   * In a term charAt(i,substring(j,k,l)), the substring
   * can be omitted, when adjusting the index
   */
  charAtSubstring {
      \schemaVar \term CharList l;
      \schemaVar \term int i,j,k;
      \find (charAt(i,substring(j,k,l)))
      \replacewith( \if (  i<k-j
                         & i>=0
                         & j>=0
                         & k>=j
                         & k<=length(l))
                    \then (charAt(i+j,l))
                    \else (charAt(i,substring(j,k,l))))
     \heuristics (stringNormalisationReduce)    
  };


  /*
   * charAt applied on a concat will either refer
   * to the first or the second subterm
   */
  charAtConcat {
      \schemaVar \term CharList l1,l2;
      \schemaVar \term int i;
      \find (charAt(i,concat(l1,l2)))
      \replacewith ( \if (i >= 0 & i < length(l1)+length(l2))
                     \then ( \if (i < length(l1))
                             \then (charAt(i,l1))
                             \else (charAt(i-length(l1),l2)) )
                     \else (charAt(i,concat(l1,l2))) )
      \heuristics (stringNormalisationReduce)
  };

  /*
   * Two succedent substring calls can be combined to one
   */
  substringSubstring {
      \schemaVar \term CharList l;
      \schemaVar \term int i,j,k,m;
      \find (substring(i,j,substring(k,m,l)))
      \replacewith (\if (  k >= 0 & m >= k
                         & m <= length(l) & i >= 0
                         & j >= i & j <= m-k)
                    \then (substring(i+k,k+j,l))
                    \else (substring(i,j,substring(k,m,l))) )
      \heuristics (stringNormalisationReduce)      
  };


  substringSubstring2 {
      \schemaVar \term CharList l,s;
      \schemaVar \term int i,j,k,m;
      \assumes ( substring(k,m,l) = s ==> )
      \find (substring(i,j,s))
      \sameUpdateLevel      
      \replacewith (\if (  k >= 0 & m >= k
                         & m <= length(l) & i >= 0
                         & j >= i & j <= m-k)
                    \then (substring(i+k,k+j,l))
                    \else (substring(i,j,substring(k,m,l))) )
      \heuristics (stringNormalisationReduce)
      \displayname "substringSubstring"      
  };

  substringConcat {
      \schemaVar \term CharList l1,l2;
      \schemaVar \term int i,j;
      \find ( substring(i,j,concat(l1,l2)) )
      \replacewith ( \if (  i >= 0 & j >= i
                          & j <= length(l1)+length(l2))
                     \then (\if (j <= length(l1))
                            \then (substring(i,j,l1))
                            \else (\if (i >= length(l1))
                                   \then (substring(
                                           i-length(l1),
                                           j-length(l1),l2))
                                   \else (concat(
                                           substring(i,
                                                     length(l1),
                                                     l1),
                                           substring(0,
                                                     j-length(l1),
                                                     l2)))))
                     \else (substring(i,j,concat(l1,l2))) )
      \heuristics (stringNormalisationReduce)      
  };

  concatConcat {
      \schemaVar \term CharList l1,l2,l3;
      \find (concat(l1,concat(l2,l3)))
      \replacewith (concat(concat(l1,l2),l3))
      \heuristics (stringNormalisation1)      
  };

  replaceSubstring {
      \schemaVar \term CharList l;
      \schemaVar \term jchar c1,c2;
      \schemaVar \term int i,j;
      \find (replace(c1,c2,substring(i,j,l)))
      \replacewith (\if (i >= 0 & j >= i & j <= length(l))
                    \then (substring(i,j,replace(c1,c2,l)))
                    \else (replace(c1,c2,substring(i,j,l))) )
      \heuristics (stringNormalisation1)      
  };

  /*
   * A replace inside a concat application
   * does not affect the concat...
   */
  replaceConcat {
      \schemaVar \term CharList l1, l2;
      \schemaVar \term jchar c1, c2;
      \find (replace(c1, c2, concat(l1,l2)))
      \replacewith (concat(replace(c1,c2,l1),
                           replace(c1,c2,l2)))
      \heuristics (stringNormalisation1)      
   };

  /*
   * empty is the only list having length 0
   */
  length0 {
      \schemaVar \term CharList l;
      \assumes (length(l) = 0 ==> )
      \add (l = empty ==> )
      \heuristics (stringAddFacts)      
  };

  /*
   * l is not equal to cons(c,l)
   */
  consEq {
      \schemaVar \term CharList l;
      \schemaVar \term jchar c;
      \find ( l = cons(c,l) )
      \replacewith ( false )
      \heuristics (concrete)
  };

  /*
   * concatenation of a non empty string
   * changes the original string
   */
  concatEqLeft {
      \schemaVar \term CharList l1, l2;
      \assumes ( ==> l2 = empty)
      \find ( concat(l1,l2) = l1 )
      \sameUpdateLevel
      \replacewith ( false )
      \heuristics (concrete)
  };
  
}
